(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    __markAsModule(target);
    if (typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    if (module && module.__esModule)
      return module;
    return __exportStar(__defProp(__create(__getProtoOf(module)), "default", {value: module, enumerable: true}), module);
  };

  // node_modules/esbuild-wasm/lib/browser.js
  var require_browser = __commonJS((exports) => {
    ((exports2) => {
      var Y = Object.defineProperty, oe = (e) => Y(e, "__esModule", {value: true}), se = (e, r) => {
        oe(e);
        for (var t in r)
          Y(e, t, {get: r[t], enumerable: true});
      }, z = (e, r, t) => new Promise((n, o) => {
        var a = (u) => {
          try {
            s(t.next(u));
          } catch (x) {
            o(x);
          }
        }, c = (u) => {
          try {
            s(t.throw(u));
          } catch (x) {
            o(x);
          }
        }, s = (u) => u.done ? n(u.value) : Promise.resolve(u.value).then(a, c);
        s((t = t.apply(e, r)).next());
      });
      se(exports2, {build: () => ge, buildSync: () => ye, startService: () => be, transform: () => he, transformSync: () => we, version: () => me});
      function H(e) {
        let r = (n) => {
          if (n === null)
            t.write8(0);
          else if (typeof n == "boolean")
            t.write8(1), t.write8(+n);
          else if (typeof n == "number")
            t.write8(2), t.write32(n | 0);
          else if (typeof n == "string")
            t.write8(3), t.write(M(n));
          else if (n instanceof Uint8Array)
            t.write8(4), t.write(n);
          else if (n instanceof Array) {
            t.write8(5), t.write32(n.length);
            for (let o of n)
              r(o);
          } else {
            let o = Object.keys(n);
            t.write8(6), t.write32(o.length);
            for (let a of o)
              t.write(M(a)), r(n[a]);
          }
        }, t = new Q();
        return t.write32(0), t.write32(e.id << 1 | +!e.isRequest), r(e.value), G(t.buf, t.len - 4, 0), t.buf.subarray(0, t.len);
      }
      function X(e) {
        let r = () => {
          switch (t.read8()) {
            case 0:
              return null;
            case 1:
              return !!t.read8();
            case 2:
              return t.read32();
            case 3:
              return K(t.read());
            case 4:
              return t.read();
            case 5: {
              let c = t.read32(), s = [];
              for (let u = 0; u < c; u++)
                s.push(r());
              return s;
            }
            case 6: {
              let c = t.read32(), s = {};
              for (let u = 0; u < c; u++)
                s[K(t.read())] = r();
              return s;
            }
            default:
              throw new Error("Invalid packet");
          }
        }, t = new Q(e), n = t.read32(), o = (n & 1) === 0;
        n >>>= 1;
        let a = r();
        if (t.ptr !== e.length)
          throw new Error("Invalid packet");
        return {id: n, isRequest: o, value: a};
      }
      class Q {
        constructor(e = new Uint8Array(1024)) {
          this.buf = e;
          this.len = 0;
          this.ptr = 0;
        }
        _write(e) {
          if (this.len + e > this.buf.length) {
            let r = new Uint8Array((this.len + e) * 2);
            r.set(this.buf), this.buf = r;
          }
          return this.len += e, this.len - e;
        }
        write8(e) {
          let r = this._write(1);
          this.buf[r] = e;
        }
        write32(e) {
          let r = this._write(4);
          G(this.buf, e, r);
        }
        write(e) {
          let r = this._write(4 + e.length);
          G(this.buf, e.length, r), this.buf.set(e, r + 4);
        }
        _read(e) {
          if (this.ptr + e > this.buf.length)
            throw new Error("Invalid packet");
          return this.ptr += e, this.ptr - e;
        }
        read8() {
          return this.buf[this._read(1)];
        }
        read32() {
          return Z(this.buf, this._read(4));
        }
        read() {
          let e = this.read32(), r = new Uint8Array(e), t = this._read(r.length);
          return r.set(this.buf.subarray(t, t + e)), r;
        }
      }
      let M, K;
      if (typeof TextEncoder != "undefined" && typeof TextDecoder != "undefined") {
        let e = new TextEncoder(), r = new TextDecoder();
        M = (t) => e.encode(t), K = (t) => r.decode(t);
      } else if (typeof Buffer != "undefined")
        M = (e) => Buffer.from(e), K = (e) => Buffer.from(e).toString();
      else
        throw new Error("No UTF-8 codec found");
      function Z(e, r) {
        return e[r++] | e[r++] << 8 | e[r++] << 16 | e[r++] << 24;
      }
      function G(e, r, t) {
        e[t++] = r, e[t++] = r >> 8, e[t++] = r >> 16, e[t++] = r >> 24;
      }
      function ee(e) {
        if (e += "", e.indexOf(",") >= 0)
          throw new Error(`Invalid target: ${e}`);
        return e;
      }
      let L = (e) => typeof e == "boolean" ? null : "a boolean", g = (e) => typeof e == "string" ? null : "a string", te = (e) => e instanceof RegExp ? null : "a RegExp object", N = (e) => typeof e == "number" && e === (e | 0) ? null : "an integer", P = (e) => Array.isArray(e) ? null : "an array", q = (e) => typeof e == "object" && e !== null && !Array.isArray(e) ? null : "an object", ae = (e) => typeof e == "object" && !Array.isArray(e) ? null : "an object or null", re = (e) => typeof e == "string" || typeof e == "boolean" ? null : "a string or a boolean", ue = (e) => typeof e == "string" || typeof e == "object" && e !== null && !Array.isArray(e) ? null : "a string or an object", ce = (e) => typeof e == "string" || Array.isArray(e) ? null : "a string or an array", fe = (e) => typeof e == "string" || e instanceof Uint8Array ? null : "a string or a Uint8Array";
      function i(e, r, t, n) {
        let o = e[t];
        if (r[t + ""] = true, o === void 0)
          return;
        let a = n(o);
        if (a !== null)
          throw new Error(`"${t}" must be ${a}`);
        return o;
      }
      function I(e, r) {
        for (let t in e)
          if (!(t in r))
            throw new Error(`Invalid option: "${t}"`);
      }
      function W(e, r, t, n, o) {
        let a = i(r, t, "color", L), c = i(r, t, "logLevel", g), s = i(r, t, "errorLimit", N);
        a ? e.push(`--color=${a}`) : n && e.push("--color=true"), e.push(`--log-level=${c || o}`), e.push(`--error-limit=${s || 0}`);
      }
      function ne(e, r, t) {
        let n = i(r, t, "target", ce), o = i(r, t, "format", g), a = i(r, t, "globalName", g), c = i(r, t, "minify", L), s = i(r, t, "minifySyntax", L), u = i(r, t, "minifyWhitespace", L), x = i(r, t, "minifyIdentifiers", L), $ = i(r, t, "charset", g), A = i(r, t, "jsxFactory", g), T = i(r, t, "jsxFragment", g), B = i(r, t, "define", q), C = i(r, t, "pure", P), D = i(r, t, "avoidTDZ", L);
        if (n && (Array.isArray(n) ? e.push(`--target=${Array.from(n).map(ee).join(",")}`) : e.push(`--target=${ee(n)}`)), o && e.push(`--format=${o}`), a && e.push(`--global-name=${a}`), c && e.push("--minify"), s && e.push("--minify-syntax"), u && e.push("--minify-whitespace"), x && e.push("--minify-identifiers"), $ && e.push(`--charset=${$}`), A && e.push(`--jsx-factory=${A}`), T && e.push(`--jsx-fragment=${T}`), B)
          for (let d in B) {
            if (d.indexOf("=") >= 0)
              throw new Error(`Invalid define: ${d}`);
            e.push(`--define:${d}=${B[d]}`);
          }
        if (C)
          for (let d of C)
            e.push(`--pure:${d}`);
        D && e.push("--avoid-tdz");
      }
      function de(e, r, t) {
        let n = [], o = Object.create(null), a = null, c = null;
        W(n, e, o, r, t), ne(n, e, o);
        let s = i(e, o, "sourcemap", re), u = i(e, o, "bundle", L), x = i(e, o, "splitting", L), $ = i(e, o, "metafile", g), A = i(e, o, "outfile", g), T = i(e, o, "outdir", g), B = i(e, o, "outbase", g), C = i(e, o, "platform", g), D = i(e, o, "tsconfig", g), d = i(e, o, "resolveExtensions", P), m = i(e, o, "mainFields", P), f = i(e, o, "external", P), O = i(e, o, "loader", q), S = i(e, o, "outExtension", q), U = i(e, o, "publicPath", g), F = i(e, o, "inject", P), y = i(e, o, "entryPoints", P), p = i(e, o, "stdin", q), E = i(e, o, "write", L) !== false, w = i(e, o, "plugins", P);
        if (I(e, o), s && n.push(`--sourcemap${s === true ? "" : `=${s}`}`), u && n.push("--bundle"), x && n.push("--splitting"), $ && n.push(`--metafile=${$}`), A && n.push(`--outfile=${A}`), T && n.push(`--outdir=${T}`), B && n.push(`--outbase=${B}`), C && n.push(`--platform=${C}`), D && n.push(`--tsconfig=${D}`), d && n.push(`--resolve-extensions=${d.join(",")}`), U && n.push(`--public-path=${U}`), m && n.push(`--main-fields=${m.join(",")}`), f)
          for (let l of f)
            n.push(`--external:${l}`);
        if (F)
          for (let l of F)
            n.push(`--inject:${l}`);
        if (O)
          for (let l in O) {
            if (l.indexOf("=") >= 0)
              throw new Error(`Invalid extension: ${l}`);
            n.push(`--loader:${l}=${O[l]}`);
          }
        if (S)
          for (let l in S) {
            if (l.indexOf("=") >= 0)
              throw new Error(`Invalid extension: ${l}`);
            n.push(`--out-extension:${l}=${S[l]}`);
          }
        if (y)
          for (let l of y) {
            if (l += "", l.startsWith("-"))
              throw new Error(`Invalid entry point: ${l}`);
            n.push(l);
          }
        if (p) {
          let l = Object.create(null), h = i(p, l, "contents", g), b = i(p, l, "resolveDir", g), v = i(p, l, "sourcefile", g), k = i(p, l, "loader", g);
          I(p, l), v && n.push(`--sourcefile=${v}`), k && n.push(`--loader=${k}`), b && (c = b + ""), a = h ? h + "" : "";
        }
        return [n, E, w, a, c];
      }
      function pe(e, r, t) {
        let n = [], o = Object.create(null);
        W(n, e, o, r, t), ne(n, e, o);
        let a = i(e, o, "sourcemap", re), c = i(e, o, "tsconfigRaw", ue), s = i(e, o, "sourcefile", g), u = i(e, o, "loader", g);
        return I(e, o), a && n.push(`--sourcemap=${a === true ? "external" : a}`), c && n.push(`--tsconfig-raw=${typeof c == "string" ? c : JSON.stringify(c)}`), s && n.push(`--sourcefile=${s}`), u && n.push(`--loader=${u}`), n;
      }
      function le(e) {
        let r = new Map(), t = new Map(), n = false, o = 0, a = 0, c = new Uint8Array(16 * 1024), s = 0, u = (d) => {
          let m = s + d.length;
          if (m > c.length) {
            let O = new Uint8Array(m * 2);
            O.set(c), c = O;
          }
          c.set(d, s), s += d.length;
          let f = 0;
          for (; f + 4 <= s; ) {
            let O = Z(c, f);
            if (f + 4 + O > s)
              break;
            f += 4, C(c.slice(f, f + O)), f += O;
          }
          f > 0 && (c.set(c.slice(f)), s -= f);
        }, x = () => {
          n = true;
          for (let d of r.values())
            d("The service was stopped", null);
          r.clear();
        }, $ = (d, m) => {
          if (n)
            return m("The service is no longer running", null);
          let f = o++;
          r.set(f, m), e.writeToStdin(H({id: f, isRequest: true, value: d}));
        }, A = (d, m) => {
          if (n)
            throw new Error("The service is no longer running");
          e.writeToStdin(H({id: d, isRequest: false, value: m}));
        }, T = (d, m) => z(this, null, function* () {
          try {
            switch (m.command) {
              case "resolve": {
                let f = t.get(m.key);
                A(d, yield f(m));
                break;
              }
              case "load": {
                let f = t.get(m.key);
                A(d, yield f(m));
                break;
              }
              default:
                throw new Error("Invalid command: " + m.command);
            }
          } catch (f) {
            A(d, {errors: [yield _(f, e)]});
          }
        }), B = true, C = (d) => {
          if (B) {
            B = false;
            let f = String.fromCharCode(...d);
            if (f !== "0.8.4")
              throw new Error(`Cannot start service: Host version "0.8.4" does not match binary version ${JSON.stringify(f)}`);
            return;
          }
          let m = X(d);
          if (m.isRequest)
            T(m.id, m.value);
          else {
            let f = r.get(m.id);
            r.delete(m.id), m.value.error ? f(m.value.error, {}) : f(null, m.value);
          }
        }, D = (d, m, f) => {
          if (e.isSync)
            throw new Error("Cannot use plugins in synchronous API calls");
          let O = {}, S = {}, U = 0, F = 0;
          m.plugins = [];
          for (let y of d) {
            let p = y.name, E = y.setup, w = {name: p + "", onResolve: [], onLoad: []};
            if (typeof p != "string" || p === "")
              throw new Error(`Plugin at index ${F} is missing a name`);
            if (typeof E != "function")
              throw new Error(`[${w.name}] Missing a setup function`);
            F++, E({onResolve(l, h) {
              let b = {}, v = i(l, b, "filter", te), k = i(l, b, "namespace", g);
              if (I(l, b), v == null)
                throw new Error(`[${w.name}] "onResolve" is missing a filter`);
              let R = U++;
              O[R] = h, w.onResolve.push({id: R, filter: v.source, namespace: k || ""});
            }, onLoad(l, h) {
              let b = {}, v = i(l, b, "filter", te), k = i(l, b, "namespace", g);
              if (I(l, b), v == null)
                throw new Error(`[${w.name}] "onLoad" is missing a filter`);
              let R = U++;
              S[R] = h, w.onLoad.push({id: R, filter: v.source, namespace: k || ""});
            }}), m.plugins.push(w);
          }
          return t.set(f, (y) => z(this, null, function* () {
            switch (y.command) {
              case "resolve": {
                let p = {};
                for (let E of y.ids)
                  try {
                    let w = O[E], l = yield w({path: y.path, importer: y.importer, namespace: y.namespace, resolveDir: y.resolveDir});
                    if (l != null) {
                      if (typeof l != "object")
                        throw new Error("Expected resolver plugin to return an object");
                      let h = {}, b = i(l, h, "pluginName", g), v = i(l, h, "path", g), k = i(l, h, "namespace", g), R = i(l, h, "external", L), j = i(l, h, "errors", P), V = i(l, h, "warnings", P);
                      I(l, h), p.id = E, b != null && (p.pluginName = b), v != null && (p.path = v), k != null && (p.namespace = k), R != null && (p.external = R), j != null && (p.errors = J(j)), V != null && (p.warnings = J(V));
                      break;
                    }
                  } catch (w) {
                    return {id: E, errors: [yield _(w, e)]};
                  }
                return p;
              }
              case "load": {
                let p = {};
                for (let E of y.ids)
                  try {
                    let w = S[E], l = yield w({path: y.path, namespace: y.namespace});
                    if (l != null) {
                      if (typeof l != "object")
                        throw new Error("Expected loader plugin to return an object");
                      let h = {}, b = i(l, h, "pluginName", g), v = i(l, h, "contents", fe), k = i(l, h, "resolveDir", g), R = i(l, h, "loader", g), j = i(l, h, "errors", P), V = i(l, h, "warnings", P);
                      I(l, h), p.id = E, b != null && (p.pluginName = b), v instanceof Uint8Array ? p.contents = v : v != null && (p.contents = M(v)), k != null && (p.resolveDir = k), R != null && (p.loader = R), j != null && (p.errors = J(j)), V != null && (p.warnings = J(V));
                      break;
                    }
                  } catch (w) {
                    return {id: E, errors: [yield _(w, e)]};
                  }
                return p;
              }
              default:
                throw new Error("Invalid command: " + y.command);
            }
          })), () => t.delete(f);
        };
        return {readFromStdout: u, afterClose: x, service: {build(d, m, f) {
          const O = "info";
          try {
            let S = a++, [U, F, y, p, E] = de(d, m, O), w = {command: "build", key: S, flags: U, write: F, stdin: p, resolveDir: E}, l = y && y.length > 0 && D(y, w, S);
            $(w, (h, b) => {
              if (l && l(), h)
                return f(new Error(h), null);
              let v = b.errors, k = b.warnings;
              if (v.length > 0)
                return f(ie("Build failed", v, k), null);
              let R = {warnings: k};
              F || (R.outputFiles = b.outputFiles), f(null, R);
            });
          } catch (S) {
            let U = [];
            try {
              W(U, d, {}, m, O);
            } catch (F) {
            }
            $({command: "error", flags: U, error: _(S, e)}, () => {
              f(S, null);
            });
          }
        }, transform(d, m, f, O, S) {
          const U = "silent";
          let F = (y) => {
            try {
              let p = pe(m, f, U), E = {command: "transform", flags: p, inputFS: y !== null, input: y !== null ? y : d + ""};
              $(E, (w, l) => {
                if (w)
                  return S(new Error(w), null);
                let h = l.errors, b = l.warnings, v = 1, k = () => --v === 0 && S(null, {warnings: b, code: l.code, map: l.map});
                if (h.length > 0)
                  return S(ie("Transform failed", h, b), null);
                l.codeFS && (v++, O.readFile(l.code, (R, j) => {
                  R !== null ? S(R, null) : (l.code = j, k());
                })), l.mapFS && (v++, O.readFile(l.map, (R, j) => {
                  R !== null ? S(R, null) : (l.map = j, k());
                })), k();
              });
            } catch (p) {
              let E = [];
              try {
                W(E, m, {}, f, U);
              } catch (w) {
              }
              $({command: "error", flags: E, error: _(p, e)}, () => {
                S(p, null);
              });
            }
          };
          if (typeof d == "string" && d.length > 1024 * 1024) {
            let y = F;
            F = () => O.writeFile(d, y);
          }
          F(null);
        }}};
      }
      function _(e, r) {
        let t = "Internal error", n = null;
        try {
          t = (e && e.message || e) + "";
        } catch (o) {
        }
        try {
          let o = e.stack + "", a = o.split(`
`, 3), c = "    at ";
          if (r.readFileSync && !a[0].startsWith(c) && a[1].startsWith(c)) {
            let s = a[1].slice(c.length);
            for (; ; ) {
              let u = /^\S+ \((.*)\)$/.exec(s);
              if (u) {
                s = u[1];
                continue;
              }
              if (u = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(s), u) {
                s = u[1];
                continue;
              }
              if (u = /^(\S+):(\d+):(\d+)$/.exec(s), u) {
                let x = r.readFileSync(u[1], "utf8"), $ = x.split(/\r\n|\r|\n|\u2028|\u2029/)[+u[2] - 1] || "";
                n = {file: u[1], namespace: "file", line: +u[2], column: +u[3] - 1, length: 0, lineText: $ + `
` + a.slice(1).join(`
`)};
              }
              break;
            }
          }
        } catch (o) {
        }
        return {text: t, location: n};
      }
      function ie(e, r, t) {
        let n = 5, o = r.length < 1 ? "" : ` with ${r.length} error${r.length < 2 ? "" : "s"}:` + r.slice(0, n + 1).map((c, s) => {
          if (s === n)
            return `
...`;
          if (!c.location)
            return `
error: ${c.text}`;
          let {file: u, line: x, column: $} = c.location;
          return `
${u}:${x}:${$}: error: ${c.text}`;
        }).join(""), a = new Error(`${e}${o}`);
        return a.errors = r, a.warnings = t, a;
      }
      function J(e) {
        let r = [];
        for (const t of e) {
          let n = {}, o = i(t, n, "text", g), a = i(t, n, "location", ae);
          I(t, n);
          let c = null;
          if (a != null) {
            let s = {}, u = i(a, s, "file", g), x = i(a, s, "namespace", g), $ = i(a, s, "line", N), A = i(a, s, "column", N), T = i(a, s, "length", N), B = i(a, s, "lineText", g);
            I(a, s), c = {file: u || "", namespace: x || "", line: $ || 0, column: A || 0, length: T || 0, lineText: B || ""};
          }
          r.push({text: o || "", location: c});
        }
        return r;
      }
      let me = "0.8.4";
      const ge = (e) => {
        throw new Error('The "build" API only works in node');
      }, he = (e, r) => {
        throw new Error('The "transform" API only works in node');
      }, ye = (e) => {
        throw new Error('The "buildSync" API only works in node');
      }, we = (e, r) => {
        throw new Error('The "transformSync" API only works in node');
      }, be = (e) => {
        if (!e)
          throw new Error('Must provide an options object to "startService"');
        if (!e.wasmURL)
          throw new Error('Must provide the "wasmURL" option');
        return fetch(e.wasmURL).then((r) => r.arrayBuffer()).then((r) => {
          let t = '{let global={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))global[k]=self[k];\n// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n(()=>{if(!(typeof global!="undefined"))if(typeof window!="undefined")window.global=window;else if(typeof self!="undefined")self.global=self;else throw new Error("cannot export Go (neither global, window nor self is defined)");if(!global.require&&typeof require!="undefined"&&(global.require=require),!global.fs&&global.require){const r=require("fs");Object.keys(r)!==0&&(global.fs=r)}const l=()=>{const r=new Error("not implemented");return r.code="ENOSYS",r};if(!global.fs){let r="";global.fs={constants:{O_WRONLY:-1,O_RDWR:-1,O_CREAT:-1,O_TRUNC:-1,O_APPEND:-1,O_EXCL:-1},writeSync(n,s){r+=g.decode(s);const i=r.lastIndexOf(`\n`);return i!=-1&&(console.log(r.substr(0,i)),r=r.substr(i+1)),s.length},write(n,s,i,c,m,u){if(i!==0||c!==s.length||m!==null){u(l());return}const h=this.writeSync(n,s);u(null,h)},chmod(n,s,i){i(l())},chown(n,s,i,c){c(l())},close(n,s){s(l())},fchmod(n,s,i){i(l())},fchown(n,s,i,c){c(l())},fstat(n,s){s(l())},fsync(n,s){s(null)},ftruncate(n,s,i){i(l())},lchown(n,s,i,c){c(l())},link(n,s,i){i(l())},lstat(n,s){s(l())},mkdir(n,s,i){i(l())},open(n,s,i,c){c(l())},read(n,s,i,c,m,u){u(l())},readdir(n,s){s(l())},readlink(n,s){s(l())},rename(n,s,i){i(l())},rmdir(n,s){s(l())},stat(n,s){s(l())},symlink(n,s,i){i(l())},truncate(n,s,i){i(l())},unlink(n,s){s(l())},utimes(n,s,i,c){c(l())}}}if(global.process||(global.process={getuid(){return-1},getgid(){return-1},geteuid(){return-1},getegid(){return-1},getgroups(){throw l()},pid:-1,ppid:-1,umask(){throw l()},cwd(){throw l()},chdir(){throw l()}}),!global.crypto){const r=require("crypto");global.crypto={getRandomValues(n){r.randomFillSync(n)}}}global.performance||(global.performance={now(){const[r,n]=process.hrtime();return r*1e3+n/1e6}}),global.TextEncoder||(global.TextEncoder=require("util").TextEncoder),global.TextDecoder||(global.TextDecoder=require("util").TextDecoder);const d=new TextEncoder("utf-8"),g=new TextDecoder("utf-8");if(global.Go=class{constructor(){this.argv=["js"],this.env={},this.exit=e=>{e!==0&&console.warn("exit code:",e)},this._exitPromise=new Promise(e=>{this._resolveExitPromise=e}),this._pendingEvent=null,this._scheduledTimeouts=new Map,this._nextCallbackTimeoutID=1;const r=(e,t)=>{this.mem.setUint32(e+0,t,!0),this.mem.setUint32(e+4,Math.floor(t/4294967296),!0)},n=e=>{const t=this.mem.getUint32(e+0,!0),o=this.mem.getInt32(e+4,!0);return t+o*4294967296},s=e=>{const t=this.mem.getFloat64(e,!0);if(t===0)return;if(!isNaN(t))return t;const o=this.mem.getUint32(e,!0);return this._values[o]},i=(e,t)=>{const o=2146959360;if(typeof t=="number"&&t!==0){if(isNaN(t)){this.mem.setUint32(e+4,o,!0),this.mem.setUint32(e,0,!0);return}this.mem.setFloat64(e,t,!0);return}if(t===void 0){this.mem.setFloat64(e,0,!0);return}let a=this._ids.get(t);a===void 0&&(a=this._idPool.pop(),a===void 0&&(a=this._values.length),this._values[a]=t,this._goRefCounts[a]=0,this._ids.set(t,a)),this._goRefCounts[a]++;let f=0;switch(typeof t){case"object":t!==null&&(f=1);break;case"string":f=2;break;case"symbol":f=3;break;case"function":f=4;break}this.mem.setUint32(e+4,o|f,!0),this.mem.setUint32(e,a,!0)},c=e=>{const t=n(e+0),o=n(e+8);return new Uint8Array(this._inst.exports.mem.buffer,t,o)},m=e=>{const t=n(e+0),o=n(e+8),a=new Array(o);for(let f=0;f<o;f++)a[f]=s(t+f*8);return a},u=e=>{const t=n(e+0),o=n(e+8);return g.decode(new DataView(this._inst.exports.mem.buffer,t,o))},h=Date.now()-performance.now();this.importObject={go:{"runtime.wasmExit":e=>{const t=this.mem.getInt32(e+8,!0);this.exited=!0,delete this._inst,delete this._values,delete this._goRefCounts,delete this._ids,delete this._idPool,this.exit(t)},"runtime.wasmWrite":e=>{const t=n(e+8),o=n(e+16),a=this.mem.getInt32(e+24,!0);fs.writeSync(t,new Uint8Array(this._inst.exports.mem.buffer,o,a))},"runtime.resetMemoryDataView":e=>{this.mem=new DataView(this._inst.exports.mem.buffer)},"runtime.nanotime1":e=>{r(e+8,(h+performance.now())*1e6)},"runtime.walltime1":e=>{const t=new Date().getTime();r(e+8,t/1e3),this.mem.setInt32(e+16,t%1e3*1e6,!0)},"runtime.scheduleTimeoutEvent":e=>{const t=this._nextCallbackTimeoutID;this._nextCallbackTimeoutID++,this._scheduledTimeouts.set(t,setTimeout(()=>{for(this._resume();this._scheduledTimeouts.has(t);)console.warn("scheduleTimeoutEvent: missed timeout event"),this._resume()},n(e+8)+1)),this.mem.setInt32(e+16,t,!0)},"runtime.clearTimeoutEvent":e=>{const t=this.mem.getInt32(e+8,!0);clearTimeout(this._scheduledTimeouts.get(t)),this._scheduledTimeouts.delete(t)},"runtime.getRandomData":e=>{crypto.getRandomValues(c(e+8))},"syscall/js.finalizeRef":e=>{const t=this.mem.getUint32(e+8,!0);if(this._goRefCounts[t]--,this._goRefCounts[t]===0){const o=this._values[t];this._values[t]=null,this._ids.delete(o),this._idPool.push(t)}},"syscall/js.stringVal":e=>{i(e+24,u(e+8))},"syscall/js.valueGet":e=>{const t=Reflect.get(s(e+8),u(e+16));e=this._inst.exports.getsp(),i(e+32,t)},"syscall/js.valueSet":e=>{Reflect.set(s(e+8),u(e+16),s(e+32))},"syscall/js.valueDelete":e=>{Reflect.deleteProperty(s(e+8),u(e+16))},"syscall/js.valueIndex":e=>{i(e+24,Reflect.get(s(e+8),n(e+16)))},"syscall/js.valueSetIndex":e=>{Reflect.set(s(e+8),n(e+16),s(e+24))},"syscall/js.valueCall":e=>{try{const t=s(e+8),o=Reflect.get(t,u(e+16)),a=m(e+32),f=Reflect.apply(o,t,a);e=this._inst.exports.getsp(),i(e+56,f),this.mem.setUint8(e+64,1)}catch(t){i(e+56,t),this.mem.setUint8(e+64,0)}},"syscall/js.valueInvoke":e=>{try{const t=s(e+8),o=m(e+16),a=Reflect.apply(t,void 0,o);e=this._inst.exports.getsp(),i(e+40,a),this.mem.setUint8(e+48,1)}catch(t){i(e+40,t),this.mem.setUint8(e+48,0)}},"syscall/js.valueNew":e=>{try{const t=s(e+8),o=m(e+16),a=Reflect.construct(t,o);e=this._inst.exports.getsp(),i(e+40,a),this.mem.setUint8(e+48,1)}catch(t){i(e+40,t),this.mem.setUint8(e+48,0)}},"syscall/js.valueLength":e=>{r(e+16,parseInt(s(e+8).length))},"syscall/js.valuePrepareString":e=>{const t=d.encode(String(s(e+8)));i(e+16,t),r(e+24,t.length)},"syscall/js.valueLoadString":e=>{const t=s(e+8);c(e+16).set(t)},"syscall/js.valueInstanceOf":e=>{this.mem.setUint8(e+24,s(e+8)instanceof s(e+16)?1:0)},"syscall/js.copyBytesToGo":e=>{const t=c(e+8),o=s(e+32);if(!(o instanceof Uint8Array||o instanceof Uint8ClampedArray)){this.mem.setUint8(e+48,0);return}const a=o.subarray(0,t.length);t.set(a),r(e+40,a.length),this.mem.setUint8(e+48,1)},"syscall/js.copyBytesToJS":e=>{const t=s(e+8),o=c(e+16);if(!(t instanceof Uint8Array||t instanceof Uint8ClampedArray)){this.mem.setUint8(e+48,0);return}const a=o.subarray(0,t.length);t.set(a),r(e+40,a.length),this.mem.setUint8(e+48,1)},debug:e=>{console.log(e)}}}}async run(r){this._inst=r,this.mem=new DataView(this._inst.exports.mem.buffer),this._values=[NaN,0,null,!0,!1,global,this],this._goRefCounts=new Array(this._values.length).fill(Infinity),this._ids=new Map([[0,1],[null,2],[!0,3],[!1,4],[global,5],[this,6]]),this._idPool=[],this.exited=!1;let n=4096;const s=h=>{const e=n,t=d.encode(h+"\\0");return new Uint8Array(this.mem.buffer,n,t.length).set(t),n+=t.length,n%8!==0&&(n+=8-n%8),e},i=this.argv.length,c=[];this.argv.forEach(h=>{c.push(s(h))}),c.push(0);const m=Object.keys(this.env).sort();m.forEach(h=>{c.push(s(`${h}=${this.env[h]}`))}),c.push(0);const u=n;c.forEach(h=>{this.mem.setUint32(n,h,!0),this.mem.setUint32(n+4,0,!0),n+=8}),this._inst.exports.run(i,u),this.exited&&this._resolveExitPromise(),await this._exitPromise}_resume(){if(this.exited)throw new Error("Go program has already exited");this._inst.exports.resume(),this.exited&&this._resolveExitPromise()}_makeFuncWrapper(r){const n=this;return function(){const s={id:r,this:this,args:arguments};return n._pendingEvent=s,n._resume(),s.result}}},global.require&&global.require.main===module&&global.process&&global.process.versions&&!global.process.versions.electron){process.argv.length<3&&(console.error("usage: go_js_wasm_exec [wasm binary] [arguments]"),process.exit(1));const r=new Go;r.argv=process.argv.slice(2),r.env=Object.assign({TMPDIR:require("os").tmpdir()},process.env),r.exit=process.exit,WebAssembly.instantiate(fs.readFileSync(process.argv[2]),r.importObject).then(n=>(process.on("exit",s=>{s===0&&!r.exited&&(r._pendingEvent={id:0},r._resume())}),r.run(n.instance))).catch(n=>{console.error(n),process.exit(1)})}})();\nonmessage=({data:m})=>{let w=new TextDecoder,s=global.fs,i="";s.writeSync=(e,t)=>{if(e===1)self.postMessage(t);else if(e===2){i+=w.decode(t);let r=i.split(`\n`);r.length>1&&console.log(r.slice(0,-1).join(`\n`)),i=r[r.length-1]}else throw new Error("Bad write");return t.length};let l=[],a,n=0;onmessage=({data:e})=>{e.length>0&&(l.push(e),a&&a())},s.read=(e,t,r,d,u,c)=>{if(e!==0||r!==0||d!==t.length||u!==null)throw new Error("Bad read");if(l.length===0){a=()=>s.read(e,t,r,d,u,c);return}let g=l[0],h=Math.max(0,Math.min(d,g.length-n));t.set(g.subarray(n,n+h),r),n+=h,n===g.length&&(l.shift(),n=0),c(null,h)};let o=new global.Go;o.argv=["","--service=0.8.4"],WebAssembly.instantiate(m,o.importObject).then(({instance:e})=>o.run(e))};}', n;
          if (e.worker !== false) {
            let s = new Blob([t], {type: "application/javascript"});
            n = new Worker(URL.createObjectURL(s));
          } else {
            let s = new Function("postMessage", t + "var onmessage; return m => onmessage(m)"), u = s((x) => n.onmessage({data: x}));
            n = {onmessage: null, postMessage: (x) => u({data: x}), terminate() {
            }};
          }
          n.postMessage(r), n.onmessage = ({data: s}) => o(s);
          let {readFromStdout: o, afterClose: a, service: c} = le({writeToStdin(s) {
            n.postMessage(s);
          }, isSync: false});
          return {build(s) {
            throw new Error('The "build" API only works in node');
          }, transform: (s, u) => new Promise((x, $) => c.transform(s, u || {}, false, {readFile(A, T) {
            T(new Error("Internal error"), null);
          }, writeFile(A, T) {
            T(null);
          }}, (A, T) => A ? $(A) : x(T))), stop() {
            n.terminate(), a();
          }};
        });
      };
    })(typeof exports === "object" ? exports : (typeof self !== "undefined" ? self : exports).esbuild = {});
  });

  // node_modules/prettier/standalone.js
  var require_standalone = __commonJS((exports, module) => {
    !function(e, t) {
      typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).prettier = t();
    }(exports, function() {
      "use strict";
      function e(e2, t2) {
        if (e2 == null)
          return {};
        var n2, r2, u2 = {}, o2 = Object.keys(e2);
        for (r2 = 0; r2 < o2.length; r2++)
          n2 = o2[r2], t2.indexOf(n2) >= 0 || (u2[n2] = e2[n2]);
        return u2;
      }
      function t(e2, t2) {
        return t2 || (t2 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, {raw: {value: Object.freeze(t2)}}));
      }
      var n = "Prettier is an opinionated code formatter", r = "./bin/prettier.js", u = {node: ">=10.13.0"}, o = ["index.js", "standalone.js", "src", "bin"], a = {"@angular/compiler": "10.0.12", "@babel/code-frame": "7.10.4", "@babel/parser": "7.11.2", "@glimmer/syntax": "0.59.0", "@iarna/toml": "2.2.5", "@typescript-eslint/typescript-estree": "3.10.0", "angular-estree-parser": "2.2.0", "angular-html-parser": "1.7.1", camelcase: "6.0.0", chalk: "4.1.0", "ci-info": "watson/ci-info#f43f6a1cefff47fb361c88cf4b943fdbcaafe540", "cjk-regex": "2.0.0", cosmiconfig: "7.0.0", dashify: "2.0.0", diff: "4.0.2", editorconfig: "0.15.3", "editorconfig-to-prettier": "0.1.1", "escape-string-regexp": "4.0.0", esutils: "2.0.3", "fast-glob": "3.2.4", "fast-json-stable-stringify": "2.1.0", "find-parent-dir": "0.3.0", "flow-parser": "0.132.0", "get-stream": "6.0.0", globby: "11.0.1", graphql: "15.3.0", "html-element-attributes": "2.2.1", "html-styles": "1.0.0", "html-tag-names": "1.1.5", "html-void-elements": "1.0.5", ignore: "4.0.6", "jest-docblock": "26.0.0", json5: "2.1.3", leven: "3.1.0", "lines-and-columns": "1.1.6", "linguist-languages": "7.10.0", lodash: "4.17.20", mem: "6.1.0", minimatch: "3.0.4", minimist: "1.2.5", "n-readlines": "1.0.0", outdent: "0.7.1", "parse-srcset": "ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee", "please-upgrade-node": "3.2.0", "postcss-less": "3.1.4", "postcss-media-query-parser": "0.2.3", "postcss-scss": "2.1.1", "postcss-selector-parser": "2.2.3", "postcss-values-parser": "2.0.1", "regexp-util": "1.2.2", "remark-footnotes": "2.0.0", "remark-math": "1.0.6", "remark-parse": "8.0.3", resolve: "1.17.0", semver: "7.3.2", "string-width": "4.2.0", typescript: "4.0.2", "unicode-regex": "3.0.0", unified: "9.2.0", vnopts: "1.0.2", "yaml-unist-parser": "1.3.1"}, i = {"@babel/core": "7.11.4", "@babel/preset-env": "7.11.0", "@babel/types": "7.11.0", "@glimmer/reference": "0.59.0", "@rollup/plugin-alias": "3.1.1", "@rollup/plugin-babel": "5.2.0", "@rollup/plugin-commonjs": "14.0.0", "@rollup/plugin-json": "4.1.0", "@rollup/plugin-node-resolve": "9.0.0", "@rollup/plugin-replace": "2.3.3", "@types/estree": "0.0.45", "@types/node": "14.6.0", "@typescript-eslint/types": "3.10.0", "babel-loader": "8.1.0", benchmark: "2.1.4", "builtin-modules": "3.1.0", "cross-env": "7.0.2", cspell: "4.1.0", eslint: "7.7.0", "eslint-config-prettier": "6.11.0", "eslint-formatter-friendly": "7.0.0", "eslint-plugin-import": "2.22.0", "eslint-plugin-jest": "23.20.0", "eslint-plugin-prettier-internal-rules": "file:scripts/tools/eslint-plugin-prettier-internal-rules", "eslint-plugin-react": "7.20.6", "eslint-plugin-unicorn": "21.0.0", execa: "4.0.3", jest: "26.4.2", "jest-snapshot-serializer-ansi": "1.0.0", "jest-snapshot-serializer-raw": "1.1.0", "jest-watch-typeahead": "0.6.0", "npm-run-all": "4.1.5", prettier: "2.1.1", rimraf: "3.0.2", rollup: "2.26.5", "rollup-plugin-node-globals": "1.4.0", "rollup-plugin-terser": "7.0.0", shelljs: "0.8.4", "snapshot-diff": "0.8.1", "strip-ansi": "6.0.0", "synchronous-promise": "2.0.13", tempy: "0.6.0", "terser-webpack-plugin": "4.1.0", webpack: "4.44.1"}, s = {prepublishOnly: 'echo "Error: must publish from dist/" && exit 1', "prepare-release": "yarn && yarn build && yarn test:dist", test: "jest", "test:dev-package": "cross-env INSTALL_PACKAGE=1 jest", "test:dist": "cross-env NODE_ENV=production jest", "test:dist-standalone": "cross-env NODE_ENV=production TEST_STANDALONE=1 jest", "test:integration": "jest tests_integration", "perf:repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", "perf:repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", "perf:benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", lint: "run-p lint:*", "lint:typecheck": "tsc", "lint:eslint": "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly", "lint:changelog": "node ./scripts/lint-changelog.js", "lint:prettier": 'prettier . "!test*" --check', "lint:dist": 'eslint --no-eslintrc --no-ignore --env=es6,browser --parser-options=ecmaVersion:2016 "dist/!(bin-prettier|index|third-party).js"', "lint:spellcheck": 'cspell "**/*" ".github/**/*"', "lint:deps": "node ./scripts/check-deps.js", fix: "run-s fix:eslint fix:prettier", "fix:eslint": "yarn lint:eslint --fix", "fix:prettier": "yarn lint:prettier --write", build: "node ./scripts/build/build.js", "build-docs": "node ./scripts/build-docs.js"}, l = {name: "prettier", version: "2.1.2", description: n, bin: r, repository: "prettier/prettier", homepage: "https://prettier.io", author: "James Long", license: "MIT", main: "./index.js", browser: "./standalone.js", unpkg: "./standalone.js", engines: u, files: o, dependencies: a, devDependencies: i, scripts: s}, c = Object.freeze({__proto__: null, name: "prettier", version: "2.1.2", description: n, bin: r, repository: "prettier/prettier", homepage: "https://prettier.io", author: "James Long", license: "MIT", main: "./index.js", browser: "./standalone.js", unpkg: "./standalone.js", engines: u, files: o, dependencies: a, devDependencies: i, scripts: s, default: l});
      function p() {
      }
      function d(e2, t2, n2, r2, u2) {
        for (var o2 = 0, a2 = t2.length, i2 = 0, s2 = 0; o2 < a2; o2++) {
          var l2 = t2[o2];
          if (l2.removed) {
            if (l2.value = e2.join(r2.slice(s2, s2 + l2.count)), s2 += l2.count, o2 && t2[o2 - 1].added) {
              var c2 = t2[o2 - 1];
              t2[o2 - 1] = t2[o2], t2[o2] = c2;
            }
          } else {
            if (!l2.added && u2) {
              var p2 = n2.slice(i2, i2 + l2.count);
              p2 = p2.map(function(e3, t3) {
                var n3 = r2[s2 + t3];
                return n3.length > e3.length ? n3 : e3;
              }), l2.value = e2.join(p2);
            } else
              l2.value = e2.join(n2.slice(i2, i2 + l2.count));
            i2 += l2.count, l2.added || (s2 += l2.count);
          }
        }
        var d2 = t2[a2 - 1];
        return a2 > 1 && typeof d2.value == "string" && (d2.added || d2.removed) && e2.equals("", d2.value) && (t2[a2 - 2].value += d2.value, t2.pop()), t2;
      }
      function f(e2) {
        return {newPos: e2.newPos, components: e2.components.slice(0)};
      }
      p.prototype = {diff: function(e2, t2) {
        var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r2 = n2.callback;
        typeof n2 == "function" && (r2 = n2, n2 = {}), this.options = n2;
        var u2 = this;
        function o2(e3) {
          return r2 ? (setTimeout(function() {
            r2(void 0, e3);
          }, 0), true) : e3;
        }
        e2 = this.castInput(e2), t2 = this.castInput(t2), e2 = this.removeEmpty(this.tokenize(e2));
        var a2 = (t2 = this.removeEmpty(this.tokenize(t2))).length, i2 = e2.length, s2 = 1, l2 = a2 + i2, c2 = [{newPos: -1, components: []}], p2 = this.extractCommon(c2[0], t2, e2, 0);
        if (c2[0].newPos + 1 >= a2 && p2 + 1 >= i2)
          return o2([{value: this.join(t2), count: t2.length}]);
        function h2() {
          for (var n3 = -1 * s2; n3 <= s2; n3 += 2) {
            var r3 = void 0, l3 = c2[n3 - 1], p3 = c2[n3 + 1], h3 = (p3 ? p3.newPos : 0) - n3;
            l3 && (c2[n3 - 1] = void 0);
            var m3 = l3 && l3.newPos + 1 < a2, g2 = p3 && 0 <= h3 && h3 < i2;
            if (m3 || g2) {
              if (!m3 || g2 && l3.newPos < p3.newPos ? (r3 = f(p3), u2.pushComponent(r3.components, void 0, true)) : ((r3 = l3).newPos++, u2.pushComponent(r3.components, true, void 0)), h3 = u2.extractCommon(r3, t2, e2, n3), r3.newPos + 1 >= a2 && h3 + 1 >= i2)
                return o2(d(u2, r3.components, t2, e2, u2.useLongestToken));
              c2[n3] = r3;
            } else
              c2[n3] = void 0;
          }
          s2++;
        }
        if (r2)
          !function e3() {
            setTimeout(function() {
              if (s2 > l2)
                return r2();
              h2() || e3();
            }, 0);
          }();
        else
          for (; s2 <= l2; ) {
            var m2 = h2();
            if (m2)
              return m2;
          }
      }, pushComponent: function(e2, t2, n2) {
        var r2 = e2[e2.length - 1];
        r2 && r2.added === t2 && r2.removed === n2 ? e2[e2.length - 1] = {count: r2.count + 1, added: t2, removed: n2} : e2.push({count: 1, added: t2, removed: n2});
      }, extractCommon: function(e2, t2, n2, r2) {
        for (var u2 = t2.length, o2 = n2.length, a2 = e2.newPos, i2 = a2 - r2, s2 = 0; a2 + 1 < u2 && i2 + 1 < o2 && this.equals(t2[a2 + 1], n2[i2 + 1]); )
          a2++, i2++, s2++;
        return s2 && e2.components.push({count: s2}), e2.newPos = a2, i2;
      }, equals: function(e2, t2) {
        return this.options.comparator ? this.options.comparator(e2, t2) : e2 === t2 || this.options.ignoreCase && e2.toLowerCase() === t2.toLowerCase();
      }, removeEmpty: function(e2) {
        for (var t2 = [], n2 = 0; n2 < e2.length; n2++)
          e2[n2] && t2.push(e2[n2]);
        return t2;
      }, castInput: function(e2) {
        return e2;
      }, tokenize: function(e2) {
        return e2.split("");
      }, join: function(e2) {
        return e2.join("");
      }};
      var h = new p();
      function m(e2, t2) {
        if (typeof e2 == "function")
          t2.callback = e2;
        else if (e2)
          for (var n2 in e2)
            e2.hasOwnProperty(n2) && (t2[n2] = e2[n2]);
        return t2;
      }
      var g = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, D = /\S/, y = new p();
      y.equals = function(e2, t2) {
        return this.options.ignoreCase && (e2 = e2.toLowerCase(), t2 = t2.toLowerCase()), e2 === t2 || this.options.ignoreWhitespace && !D.test(e2) && !D.test(t2);
      }, y.tokenize = function(e2) {
        for (var t2 = e2.split(/(\s+|[()[\]{}'"]|\b)/), n2 = 0; n2 < t2.length - 1; n2++)
          !t2[n2 + 1] && t2[n2 + 2] && g.test(t2[n2]) && g.test(t2[n2 + 2]) && (t2[n2] += t2[n2 + 2], t2.splice(n2 + 1, 2), n2--);
        return t2;
      };
      var E = new p();
      function C(e2, t2, n2) {
        return E.diff(e2, t2, n2);
      }
      E.tokenize = function(e2) {
        var t2 = [], n2 = e2.split(/(\n|\r\n)/);
        n2[n2.length - 1] || n2.pop();
        for (var r2 = 0; r2 < n2.length; r2++) {
          var u2 = n2[r2];
          r2 % 2 && !this.options.newlineIsToken ? t2[t2.length - 1] += u2 : (this.options.ignoreWhitespace && (u2 = u2.trim()), t2.push(u2));
        }
        return t2;
      };
      var b = new p();
      b.tokenize = function(e2) {
        return e2.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      var A = new p();
      function v(e2) {
        return (v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        })(e2);
      }
      function F(e2) {
        return function(e3) {
          if (Array.isArray(e3)) {
            for (var t2 = 0, n2 = new Array(e3.length); t2 < e3.length; t2++)
              n2[t2] = e3[t2];
            return n2;
          }
        }(e2) || function(e3) {
          if (Symbol.iterator in Object(e3) || Object.prototype.toString.call(e3) === "[object Arguments]")
            return Array.from(e3);
        }(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
      }
      A.tokenize = function(e2) {
        return e2.split(/([{}:;,]|\s+)/);
      };
      var x = Object.prototype.toString, S = new p();
      function w(e2, t2, n2, r2, u2) {
        var o2, a2;
        for (t2 = t2 || [], n2 = n2 || [], r2 && (e2 = r2(u2, e2)), o2 = 0; o2 < t2.length; o2 += 1)
          if (t2[o2] === e2)
            return n2[o2];
        if (x.call(e2) === "[object Array]") {
          for (t2.push(e2), a2 = new Array(e2.length), n2.push(a2), o2 = 0; o2 < e2.length; o2 += 1)
            a2[o2] = w(e2[o2], t2, n2, r2, u2);
          return t2.pop(), n2.pop(), a2;
        }
        if (e2 && e2.toJSON && (e2 = e2.toJSON()), v(e2) === "object" && e2 !== null) {
          t2.push(e2), a2 = {}, n2.push(a2);
          var i2, s2 = [];
          for (i2 in e2)
            e2.hasOwnProperty(i2) && s2.push(i2);
          for (s2.sort(), o2 = 0; o2 < s2.length; o2 += 1)
            a2[i2 = s2[o2]] = w(e2[i2], t2, n2, r2, i2);
          t2.pop(), n2.pop();
        } else
          a2 = e2;
        return a2;
      }
      S.useLongestToken = true, S.tokenize = E.tokenize, S.castInput = function(e2) {
        var t2 = this.options, n2 = t2.undefinedReplacement, r2 = t2.stringifyReplacer, u2 = r2 === void 0 ? function(e3, t3) {
          return t3 === void 0 ? n2 : t3;
        } : r2;
        return typeof e2 == "string" ? e2 : JSON.stringify(w(e2, null, null, u2), u2, "  ");
      }, S.equals = function(e2, t2) {
        return p.prototype.equals.call(S, e2.replace(/,([\r\n])/g, "$1"), t2.replace(/,([\r\n])/g, "$1"));
      };
      var B = new p();
      function T(e2) {
        var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e2.split(/\r\n|[\n\v\f\r\x85]/), r2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], u2 = [], o2 = 0;
        function a2() {
          var e3 = {};
          for (u2.push(e3); o2 < n2.length; ) {
            var r3 = n2[o2];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
              break;
            var a3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
            a3 && (e3.index = a3[1]), o2++;
          }
          for (i2(e3), i2(e3), e3.hunks = []; o2 < n2.length; ) {
            var l2 = n2[o2];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(l2))
              break;
            if (/^@@/.test(l2))
              e3.hunks.push(s2());
            else {
              if (l2 && t2.strict)
                throw new Error("Unknown line " + (o2 + 1) + " " + JSON.stringify(l2));
              o2++;
            }
          }
        }
        function i2(e3) {
          var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[o2]);
          if (t3) {
            var r3 = t3[1] === "---" ? "old" : "new", u3 = t3[2].split("	", 2), a3 = u3[0].replace(/\\\\/g, "\\");
            /^".*"$/.test(a3) && (a3 = a3.substr(1, a3.length - 2)), e3[r3 + "FileName"] = a3, e3[r3 + "Header"] = (u3[1] || "").trim(), o2++;
          }
        }
        function s2() {
          for (var e3 = o2, u3 = n2[o2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), a3 = {oldStart: +u3[1], oldLines: +u3[2] || 1, newStart: +u3[3], newLines: +u3[4] || 1, lines: [], linedelimiters: []}, i3 = 0, s3 = 0; o2 < n2.length && !(n2[o2].indexOf("--- ") === 0 && o2 + 2 < n2.length && n2[o2 + 1].indexOf("+++ ") === 0 && n2[o2 + 2].indexOf("@@") === 0); o2++) {
            var l2 = n2[o2].length == 0 && o2 != n2.length - 1 ? " " : n2[o2][0];
            if (l2 !== "+" && l2 !== "-" && l2 !== " " && l2 !== "\\")
              break;
            a3.lines.push(n2[o2]), a3.linedelimiters.push(r2[o2] || "\n"), l2 === "+" ? i3++ : l2 === "-" ? s3++ : l2 === " " && (i3++, s3++);
          }
          if (i3 || a3.newLines !== 1 || (a3.newLines = 0), s3 || a3.oldLines !== 1 || (a3.oldLines = 0), t2.strict) {
            if (i3 !== a3.newLines)
              throw new Error("Added line count did not match for hunk at line " + (e3 + 1));
            if (s3 !== a3.oldLines)
              throw new Error("Removed line count did not match for hunk at line " + (e3 + 1));
          }
          return a3;
        }
        for (; o2 < n2.length; )
          a2();
        return u2;
      }
      function k(e2, t2, n2) {
        var r2 = true, u2 = false, o2 = false, a2 = 1;
        return function i2() {
          if (r2 && !o2) {
            if (u2 ? a2++ : r2 = false, e2 + a2 <= n2)
              return a2;
            o2 = true;
          }
          if (!u2)
            return o2 || (r2 = true), t2 <= e2 - a2 ? -a2++ : (u2 = true, i2());
        };
      }
      function N(e2, t2) {
        var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (typeof t2 == "string" && (t2 = T(t2)), Array.isArray(t2)) {
          if (t2.length > 1)
            throw new Error("applyPatch only works with a single input.");
          t2 = t2[0];
        }
        var r2, u2, o2 = e2.split(/\r\n|[\n\v\f\r\x85]/), a2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], i2 = t2.hunks, s2 = n2.compareLine || function(e3, t3, n3, r3) {
          return t3 === r3;
        }, l2 = 0, c2 = n2.fuzzFactor || 0, p2 = 0, d2 = 0;
        function f2(e3, t3) {
          for (var n3 = 0; n3 < e3.lines.length; n3++) {
            var r3 = e3.lines[n3], u3 = r3.length > 0 ? r3[0] : " ", a3 = r3.length > 0 ? r3.substr(1) : r3;
            if (u3 === " " || u3 === "-") {
              if (!s2(t3 + 1, o2[t3], u3, a3) && ++l2 > c2)
                return false;
              t3++;
            }
          }
          return true;
        }
        for (var h2 = 0; h2 < i2.length; h2++) {
          for (var m2 = i2[h2], g2 = o2.length - m2.oldLines, D2 = 0, y2 = d2 + m2.oldStart - 1, E2 = k(y2, p2, g2); D2 !== void 0; D2 = E2())
            if (f2(m2, y2 + D2)) {
              m2.offset = d2 += D2;
              break;
            }
          if (D2 === void 0)
            return false;
          p2 = m2.offset + m2.oldStart + m2.oldLines;
        }
        for (var C2 = 0, b2 = 0; b2 < i2.length; b2++) {
          var A2 = i2[b2], v2 = A2.oldStart + A2.offset + C2 - 1;
          C2 += A2.newLines - A2.oldLines, v2 < 0 && (v2 = 0);
          for (var F2 = 0; F2 < A2.lines.length; F2++) {
            var x2 = A2.lines[F2], S2 = x2.length > 0 ? x2[0] : " ", w2 = x2.length > 0 ? x2.substr(1) : x2, B2 = A2.linedelimiters[F2];
            if (S2 === " ")
              v2++;
            else if (S2 === "-")
              o2.splice(v2, 1), a2.splice(v2, 1);
            else if (S2 === "+")
              o2.splice(v2, 0, w2), a2.splice(v2, 0, B2), v2++;
            else if (S2 === "\\") {
              var N2 = A2.lines[F2 - 1] ? A2.lines[F2 - 1][0] : null;
              N2 === "+" ? r2 = true : N2 === "-" && (u2 = true);
            }
          }
        }
        if (r2)
          for (; !o2[o2.length - 1]; )
            o2.pop(), a2.pop();
        else
          u2 && (o2.push(""), a2.push("\n"));
        for (var O2 = 0; O2 < o2.length - 1; O2++)
          o2[O2] = o2[O2] + a2[O2];
        return o2.join("");
      }
      function O(e2, t2, n2, r2, u2, o2, a2) {
        a2 || (a2 = {}), a2.context === void 0 && (a2.context = 4);
        var i2 = C(n2, r2, a2);
        function s2(e3) {
          return e3.map(function(e4) {
            return " " + e4;
          });
        }
        i2.push({value: "", lines: []});
        for (var l2 = [], c2 = 0, p2 = 0, d2 = [], f2 = 1, h2 = 1, m2 = function(e3) {
          var t3 = i2[e3], u3 = t3.lines || t3.value.replace(/\n$/, "").split("\n");
          if (t3.lines = u3, t3.added || t3.removed) {
            var o3;
            if (!c2) {
              var m3 = i2[e3 - 1];
              c2 = f2, p2 = h2, m3 && (d2 = a2.context > 0 ? s2(m3.lines.slice(-a2.context)) : [], c2 -= d2.length, p2 -= d2.length);
            }
            (o3 = d2).push.apply(o3, F(u3.map(function(e4) {
              return (t3.added ? "+" : "-") + e4;
            }))), t3.added ? h2 += u3.length : f2 += u3.length;
          } else {
            if (c2)
              if (u3.length <= 2 * a2.context && e3 < i2.length - 2) {
                var g3;
                (g3 = d2).push.apply(g3, F(s2(u3)));
              } else {
                var D2, y2 = Math.min(u3.length, a2.context);
                (D2 = d2).push.apply(D2, F(s2(u3.slice(0, y2))));
                var E2 = {oldStart: c2, oldLines: f2 - c2 + y2, newStart: p2, newLines: h2 - p2 + y2, lines: d2};
                if (e3 >= i2.length - 2 && u3.length <= a2.context) {
                  var C2 = /\n$/.test(n2), b2 = /\n$/.test(r2), A2 = u3.length == 0 && d2.length > E2.oldLines;
                  !C2 && A2 && d2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C2 || A2) && b2 || d2.push("\\ No newline at end of file");
                }
                l2.push(E2), c2 = 0, p2 = 0, d2 = [];
              }
            f2 += u3.length, h2 += u3.length;
          }
        }, g2 = 0; g2 < i2.length; g2++)
          m2(g2);
        return {oldFileName: e2, newFileName: t2, oldHeader: u2, newHeader: o2, hunks: l2};
      }
      function P(e2, t2, n2, r2, u2, o2, a2) {
        var i2 = O(e2, t2, n2, r2, u2, o2, a2), s2 = [];
        e2 == t2 && s2.push("Index: " + e2), s2.push("==================================================================="), s2.push("--- " + i2.oldFileName + (i2.oldHeader === void 0 ? "" : "	" + i2.oldHeader)), s2.push("+++ " + i2.newFileName + (i2.newHeader === void 0 ? "" : "	" + i2.newHeader));
        for (var l2 = 0; l2 < i2.hunks.length; l2++) {
          var c2 = i2.hunks[l2];
          s2.push("@@ -" + c2.oldStart + "," + c2.oldLines + " +" + c2.newStart + "," + c2.newLines + " @@"), s2.push.apply(s2, c2.lines);
        }
        return s2.join("\n") + "\n";
      }
      function _(e2, t2) {
        if (t2.length > e2.length)
          return false;
        for (var n2 = 0; n2 < t2.length; n2++)
          if (t2[n2] !== e2[n2])
            return false;
        return true;
      }
      function I(e2) {
        var t2 = function e3(t3) {
          var n3 = 0, r3 = 0;
          return t3.forEach(function(t4) {
            if (typeof t4 != "string") {
              var u2 = e3(t4.mine), o2 = e3(t4.theirs);
              n3 !== void 0 && (u2.oldLines === o2.oldLines ? n3 += u2.oldLines : n3 = void 0), r3 !== void 0 && (u2.newLines === o2.newLines ? r3 += u2.newLines : r3 = void 0);
            } else
              r3 === void 0 || t4[0] !== "+" && t4[0] !== " " || r3++, n3 === void 0 || t4[0] !== "-" && t4[0] !== " " || n3++;
          }), {oldLines: n3, newLines: r3};
        }(e2.lines), n2 = t2.oldLines, r2 = t2.newLines;
        n2 !== void 0 ? e2.oldLines = n2 : delete e2.oldLines, r2 !== void 0 ? e2.newLines = r2 : delete e2.newLines;
      }
      function j(e2, t2) {
        if (typeof e2 == "string") {
          if (/^@@/m.test(e2) || /^Index:/m.test(e2))
            return T(e2)[0];
          if (!t2)
            throw new Error("Must provide a base reference or pass in a patch");
          return O(void 0, void 0, t2, e2);
        }
        return e2;
      }
      function M(e2) {
        return e2.newFileName && e2.newFileName !== e2.oldFileName;
      }
      function L(e2, t2, n2) {
        return t2 === n2 ? t2 : (e2.conflict = true, {mine: t2, theirs: n2});
      }
      function R(e2, t2) {
        return e2.oldStart < t2.oldStart && e2.oldStart + e2.oldLines < t2.oldStart;
      }
      function q(e2, t2) {
        return {oldStart: e2.oldStart, oldLines: e2.oldLines, newStart: e2.newStart + t2, newLines: e2.newLines, lines: e2.lines};
      }
      function V(e2, t2, n2, r2, u2) {
        var o2 = {offset: t2, lines: n2, index: 0}, a2 = {offset: r2, lines: u2, index: 0};
        for (z(e2, o2, a2), z(e2, a2, o2); o2.index < o2.lines.length && a2.index < a2.lines.length; ) {
          var i2 = o2.lines[o2.index], s2 = a2.lines[a2.index];
          if (i2[0] !== "-" && i2[0] !== "+" || s2[0] !== "-" && s2[0] !== "+")
            if (i2[0] === "+" && s2[0] === " ") {
              var l2;
              (l2 = e2.lines).push.apply(l2, F(G(o2)));
            } else if (s2[0] === "+" && i2[0] === " ") {
              var c2;
              (c2 = e2.lines).push.apply(c2, F(G(a2)));
            } else
              i2[0] === "-" && s2[0] === " " ? $(e2, o2, a2) : s2[0] === "-" && i2[0] === " " ? $(e2, a2, o2, true) : i2 === s2 ? (e2.lines.push(i2), o2.index++, a2.index++) : U(e2, G(o2), G(a2));
          else
            W(e2, o2, a2);
        }
        J(e2, o2), J(e2, a2), I(e2);
      }
      function W(e2, t2, n2) {
        var r2 = G(t2), u2 = G(n2);
        if (H(r2) && H(u2)) {
          var o2, a2;
          if (_(r2, u2) && X(n2, r2, r2.length - u2.length))
            return void (o2 = e2.lines).push.apply(o2, F(r2));
          if (_(u2, r2) && X(t2, u2, u2.length - r2.length))
            return void (a2 = e2.lines).push.apply(a2, F(u2));
        } else if (function(e3, t3) {
          return e3.length === t3.length && _(e3, t3);
        }(r2, u2)) {
          var i2;
          return void (i2 = e2.lines).push.apply(i2, F(r2));
        }
        U(e2, r2, u2);
      }
      function $(e2, t2, n2, r2) {
        var u2, o2 = G(t2), a2 = function(e3, t3) {
          var n3 = [], r3 = [], u3 = 0, o3 = false, a3 = false;
          for (; u3 < t3.length && e3.index < e3.lines.length; ) {
            var i2 = e3.lines[e3.index], s2 = t3[u3];
            if (s2[0] === "+")
              break;
            if (o3 = o3 || i2[0] !== " ", r3.push(s2), u3++, i2[0] === "+")
              for (a3 = true; i2[0] === "+"; )
                n3.push(i2), i2 = e3.lines[++e3.index];
            s2.substr(1) === i2.substr(1) ? (n3.push(i2), e3.index++) : a3 = true;
          }
          (t3[u3] || "")[0] === "+" && o3 && (a3 = true);
          if (a3)
            return n3;
          for (; u3 < t3.length; )
            r3.push(t3[u3++]);
          return {merged: r3, changes: n3};
        }(n2, o2);
        a2.merged ? (u2 = e2.lines).push.apply(u2, F(a2.merged)) : U(e2, r2 ? a2 : o2, r2 ? o2 : a2);
      }
      function U(e2, t2, n2) {
        e2.conflict = true, e2.lines.push({conflict: true, mine: t2, theirs: n2});
      }
      function z(e2, t2, n2) {
        for (; t2.offset < n2.offset && t2.index < t2.lines.length; ) {
          var r2 = t2.lines[t2.index++];
          e2.lines.push(r2), t2.offset++;
        }
      }
      function J(e2, t2) {
        for (; t2.index < t2.lines.length; ) {
          var n2 = t2.lines[t2.index++];
          e2.lines.push(n2);
        }
      }
      function G(e2) {
        for (var t2 = [], n2 = e2.lines[e2.index][0]; e2.index < e2.lines.length; ) {
          var r2 = e2.lines[e2.index];
          if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
            break;
          t2.push(r2), e2.index++;
        }
        return t2;
      }
      function H(e2) {
        return e2.reduce(function(e3, t2) {
          return e3 && t2[0] === "-";
        }, true);
      }
      function X(e2, t2, n2) {
        for (var r2 = 0; r2 < n2; r2++) {
          var u2 = t2[t2.length - n2 + r2].substr(1);
          if (e2.lines[e2.index + r2] !== " " + u2)
            return false;
        }
        return e2.index += n2, true;
      }
      function Y(e2) {
        var t2 = e2;
        return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
      }
      B.tokenize = function(e2) {
        return e2.slice();
      }, B.join = B.removeEmpty = function(e2) {
        return e2;
      };
      var K = Object.freeze({__proto__: null, Diff: p, diffChars: function(e2, t2, n2) {
        return h.diff(e2, t2, n2);
      }, diffWords: function(e2, t2, n2) {
        return n2 = m(n2, {ignoreWhitespace: true}), y.diff(e2, t2, n2);
      }, diffWordsWithSpace: function(e2, t2, n2) {
        return y.diff(e2, t2, n2);
      }, diffLines: C, diffTrimmedLines: function(e2, t2, n2) {
        var r2 = m(n2, {ignoreWhitespace: true});
        return E.diff(e2, t2, r2);
      }, diffSentences: function(e2, t2, n2) {
        return b.diff(e2, t2, n2);
      }, diffCss: function(e2, t2, n2) {
        return A.diff(e2, t2, n2);
      }, diffJson: function(e2, t2, n2) {
        return S.diff(e2, t2, n2);
      }, diffArrays: function(e2, t2, n2) {
        return B.diff(e2, t2, n2);
      }, structuredPatch: O, createTwoFilesPatch: P, createPatch: function(e2, t2, n2, r2, u2, o2) {
        return P(e2, e2, t2, n2, r2, u2, o2);
      }, applyPatch: N, applyPatches: function(e2, t2) {
        typeof e2 == "string" && (e2 = T(e2));
        var n2 = 0;
        !function r2() {
          var u2 = e2[n2++];
          if (!u2)
            return t2.complete();
          t2.loadFile(u2, function(e3, n3) {
            if (e3)
              return t2.complete(e3);
            var o2 = N(n3, u2, t2);
            t2.patched(u2, o2, function(e4) {
              if (e4)
                return t2.complete(e4);
              r2();
            });
          });
        }();
      }, parsePatch: T, merge: function(e2, t2, n2) {
        e2 = j(e2, n2), t2 = j(t2, n2);
        var r2 = {};
        (e2.index || t2.index) && (r2.index = e2.index || t2.index), (e2.newFileName || t2.newFileName) && (M(e2) ? M(t2) ? (r2.oldFileName = L(r2, e2.oldFileName, t2.oldFileName), r2.newFileName = L(r2, e2.newFileName, t2.newFileName), r2.oldHeader = L(r2, e2.oldHeader, t2.oldHeader), r2.newHeader = L(r2, e2.newHeader, t2.newHeader)) : (r2.oldFileName = e2.oldFileName, r2.newFileName = e2.newFileName, r2.oldHeader = e2.oldHeader, r2.newHeader = e2.newHeader) : (r2.oldFileName = t2.oldFileName || e2.oldFileName, r2.newFileName = t2.newFileName || e2.newFileName, r2.oldHeader = t2.oldHeader || e2.oldHeader, r2.newHeader = t2.newHeader || e2.newHeader)), r2.hunks = [];
        for (var u2 = 0, o2 = 0, a2 = 0, i2 = 0; u2 < e2.hunks.length || o2 < t2.hunks.length; ) {
          var s2 = e2.hunks[u2] || {oldStart: 1 / 0}, l2 = t2.hunks[o2] || {oldStart: 1 / 0};
          if (R(s2, l2))
            r2.hunks.push(q(s2, a2)), u2++, i2 += s2.newLines - s2.oldLines;
          else if (R(l2, s2))
            r2.hunks.push(q(l2, i2)), o2++, a2 += l2.newLines - l2.oldLines;
          else {
            var c2 = {oldStart: Math.min(s2.oldStart, l2.oldStart), oldLines: 0, newStart: Math.min(s2.newStart + a2, l2.oldStart + i2), newLines: 0, lines: []};
            V(c2, s2.oldStart, s2.lines, l2.oldStart, l2.lines), o2++, u2++, r2.hunks.push(c2);
          }
        }
        return r2;
      }, convertChangesToDMP: function(e2) {
        for (var t2, n2, r2 = [], u2 = 0; u2 < e2.length; u2++)
          n2 = (t2 = e2[u2]).added ? 1 : t2.removed ? -1 : 0, r2.push([n2, t2.value]);
        return r2;
      }, convertChangesToXML: function(e2) {
        for (var t2 = [], n2 = 0; n2 < e2.length; n2++) {
          var r2 = e2[n2];
          r2.added ? t2.push("<ins>") : r2.removed && t2.push("<del>"), t2.push(Y(r2.value)), r2.added ? t2.push("</ins>") : r2.removed && t2.push("</del>");
        }
        return t2.join("");
      }, canonicalize: w});
      function Q(e2) {
        return {type: "concat", parts: e2};
      }
      function Z(e2) {
        return {type: "indent", contents: e2};
      }
      function ee(e2, t2) {
        return {type: "align", contents: t2, n: e2};
      }
      function te(e2, t2) {
        return {type: "group", id: (t2 = t2 || {}).id, contents: e2, break: !!t2.shouldBreak, expandedStates: t2.expandedStates};
      }
      const ne = {type: "break-parent"}, re = Q([{type: "line", hard: true}, ne]), ue = Q([{type: "line", hard: true, literal: true}, ne]);
      var oe = {concat: Q, join: function(e2, t2) {
        const n2 = [];
        for (let r2 = 0; r2 < t2.length; r2++)
          r2 !== 0 && n2.push(e2), n2.push(t2[r2]);
        return Q(n2);
      }, line: {type: "line"}, softline: {type: "line", soft: true}, hardline: re, literalline: ue, group: te, conditionalGroup: function(e2, t2) {
        return te(e2[0], Object.assign({}, t2, {expandedStates: e2}));
      }, fill: function(e2) {
        return {type: "fill", parts: e2};
      }, lineSuffix: function(e2) {
        return {type: "line-suffix", contents: e2};
      }, lineSuffixBoundary: {type: "line-suffix-boundary"}, cursor: {type: "cursor", placeholder: Symbol("cursor")}, breakParent: ne, ifBreak: function(e2, t2, n2) {
        return {type: "if-break", breakContents: e2, flatContents: t2, groupId: (n2 = n2 || {}).groupId};
      }, trim: {type: "trim"}, indent: Z, align: ee, addAlignmentToDoc: function(e2, t2, n2) {
        let r2 = e2;
        if (t2 > 0) {
          for (let e3 = 0; e3 < Math.floor(t2 / n2); ++e3)
            r2 = Z(r2);
          r2 = ee(t2 % n2, r2), r2 = ee(-1 / 0, r2);
        }
        return r2;
      }, markAsRoot: function(e2) {
        return ee({type: "root"}, e2);
      }, dedentToRoot: function(e2) {
        return ee(-1 / 0, e2);
      }, dedent: function(e2) {
        return ee(-1, e2);
      }}, ae = (e2) => typeof e2 == "string" ? e2.replace((({onlyFirst: e3 = false} = {}) => {
        const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(t2, e3 ? void 0 : "g");
      })(), "") : e2;
      const ie = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
      var se = ie, le = ie;
      se.default = le;
      const ce = (e2) => {
        if (typeof (e2 = e2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) != "string" || e2.length === 0)
          return 0;
        e2 = ae(e2);
        let t2 = 0;
        for (let n2 = 0; n2 < e2.length; n2++) {
          const r2 = e2.codePointAt(n2);
          r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t2 += se(r2) ? 2 : 1));
        }
        return t2;
      };
      var pe = ce, de = ce;
      pe.default = de;
      var fe = (e2) => {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      }, he = (e2) => e2[e2.length - 1], me = typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
      function ge() {
        throw new Error("setTimeout has not been defined");
      }
      function De() {
        throw new Error("clearTimeout has not been defined");
      }
      var ye = ge, Ee = De;
      function Ce(e2) {
        if (ye === setTimeout)
          return setTimeout(e2, 0);
        if ((ye === ge || !ye) && setTimeout)
          return ye = setTimeout, setTimeout(e2, 0);
        try {
          return ye(e2, 0);
        } catch (t2) {
          try {
            return ye.call(null, e2, 0);
          } catch (t3) {
            return ye.call(this, e2, 0);
          }
        }
      }
      typeof me.setTimeout == "function" && (ye = setTimeout), typeof me.clearTimeout == "function" && (Ee = clearTimeout);
      var be, Ae = [], ve = false, Fe = -1;
      function xe() {
        ve && be && (ve = false, be.length ? Ae = be.concat(Ae) : Fe = -1, Ae.length && Se());
      }
      function Se() {
        if (!ve) {
          var e2 = Ce(xe);
          ve = true;
          for (var t2 = Ae.length; t2; ) {
            for (be = Ae, Ae = []; ++Fe < t2; )
              be && be[Fe].run();
            Fe = -1, t2 = Ae.length;
          }
          be = null, ve = false, function(e3) {
            if (Ee === clearTimeout)
              return clearTimeout(e3);
            if ((Ee === De || !Ee) && clearTimeout)
              return Ee = clearTimeout, clearTimeout(e3);
            try {
              Ee(e3);
            } catch (t3) {
              try {
                return Ee.call(null, e3);
              } catch (t4) {
                return Ee.call(this, e3);
              }
            }
          }(e2);
        }
      }
      function we(e2, t2) {
        this.fun = e2, this.array = t2;
      }
      we.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      function Be() {
      }
      var Te = Be, ke = Be, Ne = Be, Oe = Be, Pe = Be, _e = Be, Ie = Be;
      var je = me.performance || {}, Me = je.now || je.mozNow || je.msNow || je.oNow || je.webkitNow || function() {
        return new Date().getTime();
      };
      var Le = new Date();
      var Re = {nextTick: function(e2) {
        var t2 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n2 = 1; n2 < arguments.length; n2++)
            t2[n2 - 1] = arguments[n2];
        Ae.push(new we(e2, t2)), Ae.length !== 1 || ve || Ce(Se);
      }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Te, addListener: ke, once: Ne, off: Oe, removeListener: Pe, removeAllListeners: _e, emit: Ie, binding: function(e2) {
        throw new Error("process.binding is not supported");
      }, cwd: function() {
        return "/";
      }, chdir: function(e2) {
        throw new Error("process.chdir is not supported");
      }, umask: function() {
        return 0;
      }, hrtime: function(e2) {
        var t2 = 1e-3 * Me.call(je), n2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
        return e2 && (n2 -= e2[0], (r2 -= e2[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
      }, platform: "browser", release: {}, config: {}, uptime: function() {
        return (new Date() - Le) / 1e3;
      }};
      var qe = typeof Re == "object" && Re.env && Re.env.NODE_DEBUG && /\bsemver\b/i.test(Re.env.NODE_DEBUG) ? (...e2) => console.error("SEMVER", ...e2) : () => {
      };
      var Ve = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, We = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function $e(e2, t2, n2) {
        return e2(n2 = {path: t2, exports: {}, require: function(e3, t3) {
          return function() {
            throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
          }(t3 == null && n2.path);
        }}, n2.exports), n2.exports;
      }
      function Ue(e2) {
        return e2 && e2.default || e2;
      }
      var ze = $e(function(e2, t2) {
        const {MAX_SAFE_COMPONENT_LENGTH: n2} = Ve, r2 = (t2 = e2.exports = {}).re = [], u2 = t2.src = [], o2 = t2.t = {};
        let a2 = 0;
        const i2 = (e3, t3, n3) => {
          const i3 = a2++;
          qe(i3, t3), o2[e3] = i3, u2[i3] = t3, r2[i3] = new RegExp(t3, n3 ? "g" : void 0);
        };
        i2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), i2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), i2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), i2("MAINVERSION", "(".concat(u2[o2.NUMERICIDENTIFIER], ")\\.") + "(".concat(u2[o2.NUMERICIDENTIFIER], ")\\.") + "(".concat(u2[o2.NUMERICIDENTIFIER], ")")), i2("MAINVERSIONLOOSE", "(".concat(u2[o2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(u2[o2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(u2[o2.NUMERICIDENTIFIERLOOSE], ")")), i2("PRERELEASEIDENTIFIER", "(?:".concat(u2[o2.NUMERICIDENTIFIER], "|").concat(u2[o2.NONNUMERICIDENTIFIER], ")")), i2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(u2[o2.NUMERICIDENTIFIERLOOSE], "|").concat(u2[o2.NONNUMERICIDENTIFIER], ")")), i2("PRERELEASE", "(?:-(".concat(u2[o2.PRERELEASEIDENTIFIER], "(?:\\.").concat(u2[o2.PRERELEASEIDENTIFIER], ")*))")), i2("PRERELEASELOOSE", "(?:-?(".concat(u2[o2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(u2[o2.PRERELEASEIDENTIFIERLOOSE], ")*))")), i2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), i2("BUILD", "(?:\\+(".concat(u2[o2.BUILDIDENTIFIER], "(?:\\.").concat(u2[o2.BUILDIDENTIFIER], ")*))")), i2("FULLPLAIN", "v?".concat(u2[o2.MAINVERSION]).concat(u2[o2.PRERELEASE], "?").concat(u2[o2.BUILD], "?")), i2("FULL", "^".concat(u2[o2.FULLPLAIN], "$")), i2("LOOSEPLAIN", "[v=\\s]*".concat(u2[o2.MAINVERSIONLOOSE]).concat(u2[o2.PRERELEASELOOSE], "?").concat(u2[o2.BUILD], "?")), i2("LOOSE", "^".concat(u2[o2.LOOSEPLAIN], "$")), i2("GTLT", "((?:<|>)?=?)"), i2("XRANGEIDENTIFIERLOOSE", "".concat(u2[o2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), i2("XRANGEIDENTIFIER", "".concat(u2[o2.NUMERICIDENTIFIER], "|x|X|\\*")), i2("XRANGEPLAIN", "[v=\\s]*(".concat(u2[o2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(u2[o2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(u2[o2.XRANGEIDENTIFIER], ")") + "(?:".concat(u2[o2.PRERELEASE], ")?").concat(u2[o2.BUILD], "?") + ")?)?"), i2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(u2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(u2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(u2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(u2[o2.PRERELEASELOOSE], ")?").concat(u2[o2.BUILD], "?") + ")?)?"), i2("XRANGE", "^".concat(u2[o2.GTLT], "\\s*").concat(u2[o2.XRANGEPLAIN], "$")), i2("XRANGELOOSE", "^".concat(u2[o2.GTLT], "\\s*").concat(u2[o2.XRANGEPLAINLOOSE], "$")), i2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n2, "})") + "(?:\\.(\\d{1,".concat(n2, "}))?") + "(?:\\.(\\d{1,".concat(n2, "}))?") + "(?:$|[^\\d])"), i2("COERCERTL", u2[o2.COERCE], true), i2("LONETILDE", "(?:~>?)"), i2("TILDETRIM", "(\\s*)".concat(u2[o2.LONETILDE], "\\s+"), true), t2.tildeTrimReplace = "$1~", i2("TILDE", "^".concat(u2[o2.LONETILDE]).concat(u2[o2.XRANGEPLAIN], "$")), i2("TILDELOOSE", "^".concat(u2[o2.LONETILDE]).concat(u2[o2.XRANGEPLAINLOOSE], "$")), i2("LONECARET", "(?:\\^)"), i2("CARETTRIM", "(\\s*)".concat(u2[o2.LONECARET], "\\s+"), true), t2.caretTrimReplace = "$1^", i2("CARET", "^".concat(u2[o2.LONECARET]).concat(u2[o2.XRANGEPLAIN], "$")), i2("CARETLOOSE", "^".concat(u2[o2.LONECARET]).concat(u2[o2.XRANGEPLAINLOOSE], "$")), i2("COMPARATORLOOSE", "^".concat(u2[o2.GTLT], "\\s*(").concat(u2[o2.LOOSEPLAIN], ")$|^$")), i2("COMPARATOR", "^".concat(u2[o2.GTLT], "\\s*(").concat(u2[o2.FULLPLAIN], ")$|^$")), i2("COMPARATORTRIM", "(\\s*)".concat(u2[o2.GTLT], "\\s*(").concat(u2[o2.LOOSEPLAIN], "|").concat(u2[o2.XRANGEPLAIN], ")"), true), t2.comparatorTrimReplace = "$1$2$3", i2("HYPHENRANGE", "^\\s*(".concat(u2[o2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(u2[o2.XRANGEPLAIN], ")") + "\\s*$"), i2("HYPHENRANGELOOSE", "^\\s*(".concat(u2[o2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(u2[o2.XRANGEPLAINLOOSE], ")") + "\\s*$"), i2("STAR", "(<|>)?=?\\s*\\*"), i2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), i2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      });
      const Je = /^[0-9]+$/, Ge = (e2, t2) => {
        const n2 = Je.test(e2), r2 = Je.test(t2);
        return n2 && r2 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e2 < t2 ? -1 : 1;
      };
      var He = {compareIdentifiers: Ge, rcompareIdentifiers: (e2, t2) => Ge(t2, e2)};
      const {MAX_LENGTH: Xe, MAX_SAFE_INTEGER: Ye} = Ve, {re: Ke, t: Qe} = ze, {compareIdentifiers: Ze} = He;
      class et {
        constructor(e2, t2) {
          if (t2 && typeof t2 == "object" || (t2 = {loose: !!t2, includePrerelease: false}), e2 instanceof et) {
            if (e2.loose === !!t2.loose && e2.includePrerelease === !!t2.includePrerelease)
              return e2;
            e2 = e2.version;
          } else if (typeof e2 != "string")
            throw new TypeError("Invalid Version: ".concat(e2));
          if (e2.length > Xe)
            throw new TypeError("version is longer than ".concat(Xe, " characters"));
          qe("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
          const n2 = e2.trim().match(t2.loose ? Ke[Qe.LOOSE] : Ke[Qe.FULL]);
          if (!n2)
            throw new TypeError("Invalid Version: ".concat(e2));
          if (this.raw = e2, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > Ye || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > Ye || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > Ye || this.patch < 0)
            throw new TypeError("Invalid patch version");
          n2[4] ? this.prerelease = n2[4].split(".").map((e3) => {
            if (/^[0-9]+$/.test(e3)) {
              const t3 = +e3;
              if (t3 >= 0 && t3 < Ye)
                return t3;
            }
            return e3;
          }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
        }
        format() {
          return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
        }
        toString() {
          return this.version;
        }
        compare(e2) {
          if (qe("SemVer.compare", this.version, this.options, e2), !(e2 instanceof et)) {
            if (typeof e2 == "string" && e2 === this.version)
              return 0;
            e2 = new et(e2, this.options);
          }
          return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
        }
        compareMain(e2) {
          return e2 instanceof et || (e2 = new et(e2, this.options)), Ze(this.major, e2.major) || Ze(this.minor, e2.minor) || Ze(this.patch, e2.patch);
        }
        comparePre(e2) {
          if (e2 instanceof et || (e2 = new et(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
            return -1;
          if (!this.prerelease.length && e2.prerelease.length)
            return 1;
          if (!this.prerelease.length && !e2.prerelease.length)
            return 0;
          let t2 = 0;
          do {
            const n2 = this.prerelease[t2], r2 = e2.prerelease[t2];
            if (qe("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
              return 0;
            if (r2 === void 0)
              return 1;
            if (n2 === void 0)
              return -1;
            if (n2 !== r2)
              return Ze(n2, r2);
          } while (++t2);
        }
        compareBuild(e2) {
          e2 instanceof et || (e2 = new et(e2, this.options));
          let t2 = 0;
          do {
            const n2 = this.build[t2], r2 = e2.build[t2];
            if (qe("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
              return 0;
            if (r2 === void 0)
              return 1;
            if (n2 === void 0)
              return -1;
            if (n2 !== r2)
              return Ze(n2, r2);
          } while (++t2);
        }
        inc(e2, t2) {
          switch (e2) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0)
                this.prerelease = [0];
              else {
                let e3 = this.prerelease.length;
                for (; --e3 >= 0; )
                  typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
                e3 === -1 && this.prerelease.push(0);
              }
              t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
              break;
            default:
              throw new Error("invalid increment argument: ".concat(e2));
          }
          return this.format(), this.raw = this.version, this;
        }
      }
      var tt = et;
      var nt = (e2, t2, n2) => new tt(e2, n2).compare(new tt(t2, n2));
      var rt = (e2, t2, n2) => nt(e2, t2, n2) < 0;
      var ut = (e2, t2, n2) => nt(e2, t2, n2) >= 0, ot = $e(function(e2, t2) {
        function n2() {
          for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
            e3[t3] = arguments[t3];
        }
        function r2() {
          return typeof WeakMap != "undefined" ? new WeakMap() : {add: n2, delete: n2, get: n2, set: n2, has: function(e3) {
            return false;
          }};
        }
        Object.defineProperty(t2, "__esModule", {value: true});
        var u2 = Object.prototype.hasOwnProperty, o2 = function(e3, t3) {
          return u2.call(e3, t3);
        };
        function a2(e3, t3) {
          for (var n3 in t3)
            o2(t3, n3) && (e3[n3] = t3[n3]);
          return e3;
        }
        var i2 = /^[ \t]*(?:\r\n|\r|\n)/, s2 = /(?:\r\n|\r|\n)[ \t]*$/, l2 = /^(?:[\r\n]|$)/, c2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function d2(e3, t3, n3) {
          var r3 = 0, u3 = e3[0].match(c2);
          u3 && (r3 = u3[1].length);
          var o3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
          t3 && (e3 = e3.slice(1));
          var a3 = n3.newline, l3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, d3 = typeof a3 == "string", f3 = e3.length;
          return e3.map(function(e4, t4) {
            return e4 = e4.replace(o3, "$1"), t4 === 0 && l3 && (e4 = e4.replace(i2, "")), t4 === f3 - 1 && p3 && (e4 = e4.replace(s2, "")), d3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
              return a3;
            })), e4;
          });
        }
        function f2(e3, t3) {
          for (var n3 = "", r3 = 0, u3 = e3.length; r3 < u3; r3++)
            n3 += e3[r3], r3 < u3 - 1 && (n3 += t3[r3]);
          return n3;
        }
        function h2(e3) {
          return o2(e3, "raw") && o2(e3, "length");
        }
        var m2 = function e3(t3) {
          var n3 = r2(), u3 = r2();
          return a2(function r3(o3) {
            for (var i3 = [], s3 = 1; s3 < arguments.length; s3++)
              i3[s3 - 1] = arguments[s3];
            if (h2(o3)) {
              var c3 = o3, g2 = (i3[0] === r3 || i3[0] === m2) && p2.test(c3[0]) && l2.test(c3[1]), D2 = g2 ? u3 : n3, y2 = D2.get(c3);
              if (y2 || (y2 = d2(c3, g2, t3), D2.set(c3, y2)), i3.length === 0)
                return y2[0];
              var E2 = f2(y2, g2 ? i3.slice(1) : i3);
              return E2;
            }
            return e3(a2(a2({}, t3), o3 || {}));
          }, {string: function(e4) {
            return d2([e4], false, t3)[0];
          }});
        }({trimLeadingNewline: true, trimTrailingNewline: true});
        t2.outdent = m2, t2.default = m2;
        try {
          e2.exports = m2, Object.defineProperty(m2, "__esModule", {value: true}), m2.default = m2, m2.outdent = m2;
        } catch (e3) {
        }
      });
      function at() {
        const e2 = t(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]);
        return at = function() {
          return e2;
        }, e2;
      }
      function it() {
        const e2 = t(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]);
        return it = function() {
          return e2;
        }, e2;
      }
      function st() {
        const e2 = t(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]);
        return st = function() {
          return e2;
        }, e2;
      }
      function lt() {
        const e2 = t(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]);
        return lt = function() {
          return e2;
        }, e2;
      }
      function ct() {
        const e2 = t(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]);
        return ct = function() {
          return e2;
        }, e2;
      }
      function pt() {
        const e2 = t(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]);
        return pt = function() {
          return e2;
        }, e2;
      }
      const {outdent: dt} = ot;
      var ft = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: 1 / 0, step: 1}, description: dt(pt()), cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: dt(ct())}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: null, description: "Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: dt(lt()), exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: 1 / 0, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: 1 / 0, range: {start: 0, end: 1 / 0, step: 1}, description: dt(st()), cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: 1 / 0, step: 1}, description: dt(it()), cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: dt(at()), cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: 1 / 0, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}}}, ht = Ue(c);
      const mt = {compare: nt, lt: rt, gte: ut}, gt = ht.version, Dt = ft.options;
      var yt = {getSupportInfo: function({plugins: t2 = [], showUnreleased: n2 = false, showDeprecated: r2 = false, showInternal: u2 = false} = {}) {
        const o2 = gt.split("-", 1)[0], a2 = t2.reduce((e2, t3) => e2.concat(t3.languages || []), []).filter(s2), i2 = ((e2, t3) => Object.entries(e2).map(([e3, n3]) => Object.assign({[t3]: e3}, n3)))(Object.assign({}, ...t2.map(({options: e2}) => e2), Dt), "name").filter((e2) => s2(e2) && l2(e2)).sort((e2, t3) => e2.name === t3.name ? 0 : e2.name < t3.name ? -1 : 1).map(function(t3) {
          if (u2)
            return t3;
          return e(t3, ["cliName", "cliCategory", "cliDescription"]);
        }).map((e2) => {
          e2 = Object.assign({}, e2), Array.isArray(e2.default) && (e2.default = e2.default.length === 1 ? e2.default[0].value : e2.default.filter(s2).sort((e3, t3) => mt.compare(t3.since, e3.since))[0].value), Array.isArray(e2.choices) && (e2.choices = e2.choices.filter((e3) => s2(e3) && l2(e3)), e2.name === "parser" && function(e3, t3, n4) {
            const r3 = new Set(e3.choices.map((e4) => e4.value));
            for (const u3 of t3)
              if (u3.parsers) {
                for (const t4 of u3.parsers)
                  if (!r3.has(t4)) {
                    r3.add(t4);
                    const o3 = n4.find((e4) => e4.parsers && e4.parsers[t4]);
                    let a3 = u3.name;
                    o3 && o3.name && (a3 += " (plugin: ".concat(o3.name, ")")), e3.choices.push({value: t4, description: a3});
                  }
              }
          }(e2, a2, t2));
          const n3 = t2.filter((t3) => t3.defaultOptions && t3.defaultOptions[e2.name] !== void 0).reduce((t3, n4) => (t3[n4.name] = n4.defaultOptions[e2.name], t3), {});
          return Object.assign({}, e2, {pluginDefaults: n3});
        });
        return {languages: a2, options: i2};
        function s2(e2) {
          return n2 || !("since" in e2) || e2.since && mt.gte(o2, e2.since);
        }
        function l2(e2) {
          return r2 || !("deprecated" in e2) || e2.deprecated && mt.lt(o2, e2.deprecated);
        }
      }};
      const Et = /[^\x20-\x7F]/;
      function Ct(e2) {
        return (t2, n2, r2) => {
          const u2 = r2 && r2.backwards;
          if (n2 === false)
            return false;
          const {length: o2} = t2;
          let a2 = n2;
          for (; a2 >= 0 && a2 < o2; ) {
            const n3 = t2.charAt(a2);
            if (e2 instanceof RegExp) {
              if (!e2.test(n3))
                return a2;
            } else if (!e2.includes(n3))
              return a2;
            u2 ? a2-- : a2++;
          }
          return (a2 === -1 || a2 === o2) && a2;
        };
      }
      const bt = Ct(/\s/), At = Ct(" 	"), vt = Ct(",; 	"), Ft = Ct(/[^\n\r]/);
      function xt(e2, t2) {
        if (t2 === false)
          return false;
        if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
          for (let n2 = t2 + 2; n2 < e2.length; ++n2)
            if (e2.charAt(n2) === "*" && e2.charAt(n2 + 1) === "/")
              return n2 + 2;
        }
        return t2;
      }
      function St(e2, t2) {
        return t2 !== false && (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? Ft(e2, t2) : t2);
      }
      function wt(e2, t2, n2) {
        const r2 = n2 && n2.backwards;
        if (t2 === false)
          return false;
        const u2 = e2.charAt(t2);
        if (r2) {
          if (e2.charAt(t2 - 1) === "\r" && u2 === "\n")
            return t2 - 2;
          if (u2 === "\n" || u2 === "\r" || u2 === "\u2028" || u2 === "\u2029")
            return t2 - 1;
        } else {
          if (u2 === "\r" && e2.charAt(t2 + 1) === "\n")
            return t2 + 2;
          if (u2 === "\n" || u2 === "\r" || u2 === "\u2028" || u2 === "\u2029")
            return t2 + 1;
        }
        return t2;
      }
      function Bt(e2, t2, n2) {
        const r2 = At(e2, (n2 = n2 || {}).backwards ? t2 - 1 : t2, n2);
        return r2 !== wt(e2, r2, n2);
      }
      function Tt(e2, t2) {
        let n2 = null, r2 = t2;
        for (; r2 !== n2; )
          n2 = r2, r2 = vt(e2, r2), r2 = xt(e2, r2), r2 = At(e2, r2);
        return r2 = St(e2, r2), r2 = wt(e2, r2), r2 !== false && Bt(e2, r2);
      }
      function kt(e2, t2) {
        let n2 = null, r2 = t2;
        for (; r2 !== n2; )
          n2 = r2, r2 = At(e2, r2), r2 = xt(e2, r2), r2 = St(e2, r2), r2 = wt(e2, r2);
        return r2;
      }
      function Nt(e2, t2, n2) {
        return kt(e2, n2(t2));
      }
      function Ot(e2, t2, n2) {
        let r2 = 0;
        for (let u2 = n2 = n2 || 0; u2 < e2.length; ++u2)
          e2[u2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
        return r2;
      }
      function Pt(e2, t2) {
        const n2 = e2.slice(1, -1), r2 = {quote: '"', regex: /"/g}, u2 = {quote: "'", regex: /'/g}, o2 = t2 === "'" ? u2 : r2, a2 = o2 === u2 ? r2 : u2;
        let i2 = o2.quote;
        if (n2.includes(o2.quote) || n2.includes(a2.quote)) {
          i2 = (n2.match(o2.regex) || []).length > (n2.match(a2.regex) || []).length ? a2.quote : o2.quote;
        }
        return i2;
      }
      function _t(e2, t2, n2) {
        const r2 = t2 === '"' ? "'" : '"', u2 = e2.replace(/\\([\S\s])|(["'])/g, (e3, u3, o2) => u3 === r2 ? u3 : o2 === t2 ? "\\" + o2 : o2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(u3) ? u3 : "\\" + u3));
        return t2 + u2 + t2;
      }
      function It(e2) {
        return e2 && (e2.comments && e2.comments.length > 0 && e2.comments.some((e3) => jt(e3) && !e3.unignore) || e2.prettierIgnore);
      }
      function jt(e2) {
        return e2.value.trim() === "prettier-ignore";
      }
      function Mt(e2, t2) {
        (e2.comments || (e2.comments = [])).push(t2), t2.printed = false, e2.type === "JSXText" && (t2.printed = true);
      }
      var Lt = {replaceEndOfLineWith: function(e2, t2) {
        const n2 = [];
        for (const r2 of e2.split("\n"))
          n2.length !== 0 && n2.push(t2), n2.push(r2);
        return n2;
      }, getStringWidth: function(e2) {
        return e2 ? Et.test(e2) ? pe(e2) : e2.length : 0;
      }, getMaxContinuousCount: function(e2, t2) {
        const n2 = e2.match(new RegExp("(".concat(fe(t2), ")+"), "g"));
        return n2 === null ? 0 : n2.reduce((e3, n3) => Math.max(e3, n3.length / t2.length), 0);
      }, getMinNotPresentContinuousCount: function(e2, t2) {
        const n2 = e2.match(new RegExp("(".concat(fe(t2), ")+"), "g"));
        if (n2 === null)
          return 0;
        const r2 = new Map();
        let u2 = 0;
        for (const e3 of n2) {
          const n3 = e3.length / t2.length;
          r2.set(n3, true), n3 > u2 && (u2 = n3);
        }
        for (let e3 = 1; e3 < u2; e3++)
          if (!r2.get(e3))
            return e3;
        return u2 + 1;
      }, getParserName: function(e2, t2) {
        const n2 = yt.getSupportInfo({plugins: t2.plugins}).languages.find((t3) => t3.name.toLowerCase() === e2 || t3.aliases && t3.aliases.includes(e2) || t3.extensions && t3.extensions.some((t4) => t4 === ".".concat(e2)));
        return n2 ? n2.parsers[0] : null;
      }, getPenultimate: (e2) => e2[e2.length - 2], getLast: he, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: kt, getNextNonSpaceNonCommentCharacterIndex: Nt, getNextNonSpaceNonCommentCharacter: function(e2, t2, n2) {
        return e2.charAt(Nt(e2, t2, n2));
      }, skip: Ct, skipWhitespace: bt, skipSpaces: At, skipToLineEnd: vt, skipEverythingButNewLine: Ft, skipInlineComment: xt, skipTrailingComment: St, skipNewline: wt, isNextLineEmptyAfterIndex: Tt, isNextLineEmpty: function(e2, t2, n2) {
        return Tt(e2, n2(t2));
      }, isPreviousLineEmpty: function(e2, t2, n2) {
        let r2 = n2(t2) - 1;
        return r2 = At(e2, r2, {backwards: true}), r2 = wt(e2, r2, {backwards: true}), r2 = At(e2, r2, {backwards: true}), r2 !== wt(e2, r2, {backwards: true});
      }, hasNewline: Bt, hasNewlineInRange: function(e2, t2, n2) {
        for (let r2 = t2; r2 < n2; ++r2)
          if (e2.charAt(r2) === "\n")
            return true;
        return false;
      }, hasSpaces: function(e2, t2, n2) {
        return At(e2, (n2 = n2 || {}).backwards ? t2 - 1 : t2, n2) !== t2;
      }, getAlignmentSize: Ot, getIndentSize: function(e2, t2) {
        const n2 = e2.lastIndexOf("\n");
        return n2 === -1 ? 0 : Ot(e2.slice(n2 + 1).match(/^[\t ]*/)[0], t2);
      }, getPreferredQuote: Pt, printString: function(e2, t2, n2) {
        const r2 = e2.slice(1, -1), u2 = !r2.includes('"') && !r2.includes("'"), o2 = t2.parser === "json" ? '"' : t2.__isInHtmlAttribute ? "'" : Pt(e2, t2.singleQuote ? "'" : '"');
        return n2 ? u2 ? o2 + r2 + o2 : e2 : _t(r2, o2, !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.embeddedInHtml));
      }, printNumber: function(e2) {
        return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
      }, hasIgnoreComment: function(e2) {
        return It(e2.getValue());
      }, hasNodeIgnoreComment: It, isNodeIgnoreComment: jt, makeString: _t, addLeadingComment: function(e2, t2) {
        t2.leading = true, t2.trailing = false, Mt(e2, t2);
      }, addDanglingComment: function(e2, t2, n2) {
        t2.leading = false, t2.trailing = false, n2 && (t2.marker = n2), Mt(e2, t2);
      }, addTrailingComment: function(e2, t2) {
        t2.leading = false, t2.trailing = true, Mt(e2, t2);
      }, isWithinParentArrayProperty: function(e2, t2) {
        const n2 = e2.getValue(), r2 = e2.getParentNode();
        if (r2 == null)
          return false;
        if (!Array.isArray(r2[t2]))
          return false;
        const u2 = e2.getName();
        return r2[t2][u2] === n2;
      }, isFrontMatterNode: function(e2) {
        return e2 && e2.type === "front-matter";
      }, getShebang: function(e2) {
        if (!e2.startsWith("#!"))
          return "";
        const t2 = e2.indexOf("\n");
        return t2 === -1 ? e2 : e2.slice(0, t2);
      }};
      var Rt = {guessEndOfLine: function(e2) {
        const t2 = e2.indexOf("\r");
        return t2 >= 0 ? e2.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
      }, convertEndOfLineToChars: function(e2) {
        switch (e2) {
          case "cr":
            return "\r";
          case "crlf":
            return "\r\n";
          default:
            return "\n";
        }
      }, countEndOfLineChars: function(e2, t2) {
        let n2;
        if (t2 === "\n")
          n2 = /\n/g;
        else if (t2 === "\r")
          n2 = /\r/g;
        else {
          if (t2 !== "\r\n")
            throw new Error('Unexpected "eol" '.concat(JSON.stringify(t2), "."));
          n2 = /\r\n/g;
        }
        const r2 = e2.match(n2);
        return r2 ? r2.length : 0;
      }, normalizeEndOfLine: function(e2) {
        return e2.replace(/\r\n?/g, "\n");
      }};
      const {getStringWidth: qt} = Lt, {convertEndOfLineToChars: Vt} = Rt, {concat: Wt, fill: $t, cursor: Ut} = oe;
      let zt;
      function Jt(e2, t2) {
        return Ht(e2, {type: "indent"}, t2);
      }
      function Gt(e2, t2, n2) {
        if (t2 === -1 / 0)
          return e2.root || {value: "", length: 0, queue: []};
        if (t2 < 0)
          return Ht(e2, {type: "dedent"}, n2);
        if (!t2)
          return e2;
        if (t2.type === "root")
          return Object.assign({}, e2, {root: e2});
        return Ht(e2, {type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2}, n2);
      }
      function Ht(e2, t2, n2) {
        const r2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : e2.queue.concat(t2);
        let u2 = "", o2 = 0, a2 = 0, i2 = 0;
        for (const e3 of r2)
          switch (e3.type) {
            case "indent":
              c2(), n2.useTabs ? s2(1) : l2(n2.tabWidth);
              break;
            case "stringAlign":
              c2(), u2 += e3.n, o2 += e3.n.length;
              break;
            case "numberAlign":
              a2 += 1, i2 += e3.n;
              break;
            default:
              throw new Error("Unexpected type '".concat(e3.type, "'"));
          }
        return p2(), Object.assign({}, e2, {value: u2, length: o2, queue: r2});
        function s2(e3) {
          u2 += "	".repeat(e3), o2 += n2.tabWidth * e3;
        }
        function l2(e3) {
          u2 += " ".repeat(e3), o2 += e3;
        }
        function c2() {
          n2.useTabs ? function() {
            a2 > 0 && s2(a2);
            d2();
          }() : p2();
        }
        function p2() {
          i2 > 0 && l2(i2), d2();
        }
        function d2() {
          a2 = 0, i2 = 0;
        }
      }
      function Xt(e2) {
        if (e2.length === 0)
          return 0;
        let t2 = 0;
        for (; e2.length > 0 && typeof e2[e2.length - 1] == "string" && e2[e2.length - 1].match(/^[\t ]*$/); )
          t2 += e2.pop().length;
        if (e2.length && typeof e2[e2.length - 1] == "string") {
          const n2 = e2[e2.length - 1].replace(/[\t ]*$/, "");
          t2 += e2[e2.length - 1].length - n2.length, e2[e2.length - 1] = n2;
        }
        return t2;
      }
      function Yt(e2, t2, n2, r2, u2) {
        let o2 = t2.length;
        const a2 = [e2], i2 = [];
        for (; n2 >= 0; ) {
          if (a2.length === 0) {
            if (o2 === 0)
              return true;
            a2.push(t2[o2 - 1]), o2--;
            continue;
          }
          const [e3, s2, l2] = a2.pop();
          if (typeof l2 == "string")
            i2.push(l2), n2 -= qt(l2);
          else
            switch (l2.type) {
              case "concat":
                for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
                  a2.push([e3, s2, l2.parts[t3]]);
                break;
              case "indent":
                a2.push([Jt(e3, r2), s2, l2.contents]);
                break;
              case "align":
                a2.push([Gt(e3, l2.n, r2), s2, l2.contents]);
                break;
              case "trim":
                n2 += Xt(i2);
                break;
              case "group":
                if (u2 && l2.break)
                  return false;
                a2.push([e3, l2.break ? 1 : s2, l2.contents]), l2.id && (zt[l2.id] = a2[a2.length - 1][1]);
                break;
              case "fill":
                for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
                  a2.push([e3, s2, l2.parts[t3]]);
                break;
              case "if-break": {
                const t3 = l2.groupId ? zt[l2.groupId] : s2;
                t3 === 1 && l2.breakContents && a2.push([e3, s2, l2.breakContents]), t3 === 2 && l2.flatContents && a2.push([e3, s2, l2.flatContents]);
                break;
              }
              case "line":
                switch (s2) {
                  case 2:
                    if (!l2.hard) {
                      l2.soft || (i2.push(" "), n2 -= 1);
                      break;
                    }
                    return true;
                  case 1:
                    return true;
                }
            }
        }
        return false;
      }
      var Kt = {printDocToString: function(e2, t2) {
        zt = {};
        const n2 = t2.printWidth, r2 = Vt(t2.endOfLine);
        let u2 = 0;
        const o2 = [[{value: "", length: 0, queue: []}, 1, e2]], a2 = [];
        let i2 = false, s2 = [];
        for (; o2.length !== 0; ) {
          const [e3, l3, c2] = o2.pop();
          if (typeof c2 == "string") {
            const e4 = r2 !== "\n" && c2.includes("\n") ? c2.replace(/\n/g, r2) : c2;
            a2.push(e4), u2 += qt(e4);
          } else
            switch (c2.type) {
              case "cursor":
                a2.push(Ut.placeholder);
                break;
              case "concat":
                for (let t3 = c2.parts.length - 1; t3 >= 0; t3--)
                  o2.push([e3, l3, c2.parts[t3]]);
                break;
              case "indent":
                o2.push([Jt(e3, t2), l3, c2.contents]);
                break;
              case "align":
                o2.push([Gt(e3, c2.n, t2), l3, c2.contents]);
                break;
              case "trim":
                u2 -= Xt(a2);
                break;
              case "group":
                switch (l3) {
                  case 2:
                    if (!i2) {
                      o2.push([e3, c2.break ? 1 : 2, c2.contents]);
                      break;
                    }
                  case 1: {
                    i2 = false;
                    const r3 = [e3, 2, c2.contents], a3 = n2 - u2;
                    if (!c2.break && Yt(r3, o2, a3, t2))
                      o2.push(r3);
                    else if (c2.expandedStates) {
                      const n3 = c2.expandedStates[c2.expandedStates.length - 1];
                      if (c2.break) {
                        o2.push([e3, 1, n3]);
                        break;
                      }
                      for (let r4 = 1; r4 < c2.expandedStates.length + 1; r4++) {
                        if (r4 >= c2.expandedStates.length) {
                          o2.push([e3, 1, n3]);
                          break;
                        }
                        {
                          const n4 = [e3, 2, c2.expandedStates[r4]];
                          if (Yt(n4, o2, a3, t2)) {
                            o2.push(n4);
                            break;
                          }
                        }
                      }
                    } else
                      o2.push([e3, 1, c2.contents]);
                    break;
                  }
                }
                c2.id && (zt[c2.id] = o2[o2.length - 1][1]);
                break;
              case "fill": {
                const r3 = n2 - u2, {parts: a3} = c2;
                if (a3.length === 0)
                  break;
                const [i3, s3] = a3, p2 = [e3, 2, i3], d2 = [e3, 1, i3], f2 = Yt(p2, [], r3, t2, true);
                if (a3.length === 1) {
                  f2 ? o2.push(p2) : o2.push(d2);
                  break;
                }
                const h2 = [e3, 2, s3], m2 = [e3, 1, s3];
                if (a3.length === 2) {
                  f2 ? (o2.push(h2), o2.push(p2)) : (o2.push(m2), o2.push(d2));
                  break;
                }
                a3.splice(0, 2);
                const g2 = [e3, l3, $t(a3)], D2 = a3[0];
                Yt([e3, 2, Wt([i3, s3, D2])], [], r3, t2, true) ? (o2.push(g2), o2.push(h2), o2.push(p2)) : f2 ? (o2.push(g2), o2.push(m2), o2.push(p2)) : (o2.push(g2), o2.push(m2), o2.push(d2));
                break;
              }
              case "if-break": {
                const t3 = c2.groupId ? zt[c2.groupId] : l3;
                t3 === 1 && c2.breakContents && o2.push([e3, l3, c2.breakContents]), t3 === 2 && c2.flatContents && o2.push([e3, l3, c2.flatContents]);
                break;
              }
              case "line-suffix":
                s2.push([e3, l3, c2.contents]);
                break;
              case "line-suffix-boundary":
                s2.length > 0 && o2.push([e3, l3, {type: "line", hard: true}]);
                break;
              case "line":
                switch (l3) {
                  case 2:
                    if (!c2.hard) {
                      c2.soft || (a2.push(" "), u2 += 1);
                      break;
                    }
                    i2 = true;
                  case 1:
                    if (s2.length) {
                      o2.push([e3, l3, c2]), o2.push(...s2.reverse()), s2 = [];
                      break;
                    }
                    c2.literal ? e3.root ? (a2.push(r2, e3.root.value), u2 = e3.root.length) : (a2.push(r2), u2 = 0) : (u2 -= Xt(a2), a2.push(r2 + e3.value), u2 = e3.length);
                }
            }
        }
        const l2 = a2.indexOf(Ut.placeholder);
        if (l2 !== -1) {
          const e3 = a2.indexOf(Ut.placeholder, l2 + 1), t3 = a2.slice(0, l2).join(""), n3 = a2.slice(l2 + 1, e3).join("");
          return {formatted: t3 + n3 + a2.slice(e3 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: n3};
        }
        return {formatted: a2.join("")};
      }};
      const {literalline: Qt, concat: Zt} = oe, en = {};
      function tn(e2, t2, n2, r2) {
        const u2 = [e2];
        for (; u2.length !== 0; ) {
          const e3 = u2.pop();
          if (e3 !== en) {
            if (n2 && u2.push(e3, en), !t2 || t2(e3) !== false)
              if (e3.type === "concat" || e3.type === "fill")
                for (let t3 = e3.parts.length - 1; t3 >= 0; --t3)
                  u2.push(e3.parts[t3]);
              else if (e3.type === "if-break")
                e3.flatContents && u2.push(e3.flatContents), e3.breakContents && u2.push(e3.breakContents);
              else if (e3.type === "group" && e3.expandedStates)
                if (r2)
                  for (let t3 = e3.expandedStates.length - 1; t3 >= 0; --t3)
                    u2.push(e3.expandedStates[t3]);
                else
                  u2.push(e3.contents);
              else
                e3.contents && u2.push(e3.contents);
          } else
            n2(u2.pop());
        }
      }
      function nn(e2, t2) {
        if (e2.type === "concat" || e2.type === "fill") {
          const n2 = e2.parts.map((e3) => nn(e3, t2));
          return t2(Object.assign({}, e2, {parts: n2}));
        }
        if (e2.type === "if-break") {
          const n2 = e2.breakContents && nn(e2.breakContents, t2), r2 = e2.flatContents && nn(e2.flatContents, t2);
          return t2(Object.assign({}, e2, {breakContents: n2, flatContents: r2}));
        }
        if (e2.contents) {
          const n2 = nn(e2.contents, t2);
          return t2(Object.assign({}, e2, {contents: n2}));
        }
        return t2(e2);
      }
      function rn(e2, t2, n2) {
        let r2 = n2, u2 = false;
        return tn(e2, function(e3) {
          const n3 = t2(e3);
          if (n3 !== void 0 && (u2 = true, r2 = n3), u2)
            return false;
        }), r2;
      }
      function un(e2) {
        return typeof e2 != "string" && (e2.type === "line" || void 0);
      }
      function on(e2) {
        return !(e2.type !== "group" || !e2.break) || (!(e2.type !== "line" || !e2.hard) || (e2.type === "break-parent" || void 0));
      }
      function an(e2) {
        if (e2.length > 0) {
          const t2 = e2[e2.length - 1];
          t2.expandedStates || (t2.break = true);
        }
        return null;
      }
      function sn(e2) {
        return e2.type !== "line" || e2.hard ? e2.type === "if-break" ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
      }
      function ln(e2) {
        const t2 = [], n2 = e2.filter(Boolean);
        for (; n2.length !== 0; ) {
          const e3 = n2.shift();
          e3 && (e3.type !== "concat" ? t2.length === 0 || typeof t2[t2.length - 1] != "string" || typeof e3 != "string" ? t2.push(e3) : t2[t2.length - 1] += e3 : n2.unshift(...e3.parts));
        }
        return t2;
      }
      function cn(e2) {
        if (e2.type === "concat") {
          const t2 = [];
          for (let n2 = 0; n2 < e2.parts.length; ++n2) {
            const r2 = e2.parts[n2];
            if (typeof r2 != "string" && r2.type === "concat")
              t2.push(...cn(r2).parts);
            else {
              const e3 = cn(r2);
              e3 !== "" && t2.push(e3);
            }
          }
          return Object.assign({}, e2, {parts: t2});
        }
        return e2.type === "if-break" ? Object.assign({}, e2, {breakContents: e2.breakContents != null ? cn(e2.breakContents) : null, flatContents: e2.flatContents != null ? cn(e2.flatContents) : null}) : e2.type === "group" ? Object.assign({}, e2, {contents: cn(e2.contents), expandedStates: e2.expandedStates ? e2.expandedStates.map(cn) : e2.expandedStates}) : e2.contents ? Object.assign({}, e2, {contents: cn(e2.contents)}) : e2;
      }
      function pn(e2) {
        if (typeof e2 == "string")
          return JSON.stringify(e2);
        if (e2.type === "line")
          return e2.literal ? "literalline" : e2.hard ? "hardline" : e2.soft ? "softline" : "line";
        if (e2.type === "break-parent")
          return "breakParent";
        if (e2.type === "trim")
          return "trim";
        if (e2.type === "concat")
          return "[" + e2.parts.map(pn).join(", ") + "]";
        if (e2.type === "indent")
          return "indent(" + pn(e2.contents) + ")";
        if (e2.type === "align")
          return e2.n === -1 / 0 ? "dedentToRoot(" + pn(e2.contents) + ")" : e2.n < 0 ? "dedent(" + pn(e2.contents) + ")" : e2.n.type === "root" ? "markAsRoot(" + pn(e2.contents) + ")" : "align(" + JSON.stringify(e2.n) + ", " + pn(e2.contents) + ")";
        if (e2.type === "if-break")
          return "ifBreak(" + pn(e2.breakContents) + (e2.flatContents ? ", " + pn(e2.flatContents) : "") + ")";
        if (e2.type === "group")
          return e2.expandedStates ? "conditionalGroup([" + e2.expandedStates.map(pn).join(",") + "])" : (e2.break ? "wrappedGroup" : "group") + "(" + pn(e2.contents) + ")";
        if (e2.type === "fill")
          return "fill(" + e2.parts.map(pn).join(", ") + ")";
        if (e2.type === "line-suffix")
          return "lineSuffix(" + pn(e2.contents) + ")";
        if (e2.type === "line-suffix-boundary")
          return "lineSuffixBoundary";
        throw new Error("Unknown doc type " + e2.type);
      }
      var dn = {builders: oe, printer: Kt, utils: {isEmpty: function(e2) {
        return typeof e2 == "string" && e2.length === 0;
      }, willBreak: function(e2) {
        return rn(e2, on, false);
      }, isLineNext: function(e2) {
        return rn(e2, un, false);
      }, traverseDoc: tn, findInDoc: rn, mapDoc: nn, propagateBreaks: function(e2) {
        const t2 = new Set(), n2 = [];
        tn(e2, function(e3) {
          if (e3.type === "break-parent" && an(n2), e3.type === "group") {
            if (n2.push(e3), t2.has(e3))
              return false;
            t2.add(e3);
          }
        }, function(e3) {
          if (e3.type === "group") {
            n2.pop().break && an(n2);
          }
        }, true);
      }, removeLines: function(e2) {
        return nn(e2, sn);
      }, stripTrailingHardline: function e2(t2, n2 = false) {
        if (t2.type === "concat" && t2.parts.length !== 0) {
          const r2 = n2 ? function(e3) {
            let t3, {parts: n3} = e3;
            for (let r3 = e3.parts.length; r3 > 0 && !t3; r3--)
              t3 = n3[r3 - 1];
            return t3.type === "group" && (n3 = t3.contents.parts), n3;
          }(t2) : t2.parts, u2 = r2[r2.length - 1];
          if (u2.type === "concat")
            return u2.parts.length === 2 && u2.parts[0].hard && u2.parts[1].type === "break-parent" ? {type: "concat", parts: r2.slice(0, -1)} : {type: "concat", parts: t2.parts.slice(0, -1).concat(e2(u2))};
        }
        return t2;
      }, normalizeParts: ln, normalizeDoc: function(e2) {
        return nn(e2, (e3) => e3.parts ? Object.assign({}, e3, {parts: ln(e3.parts)}) : e3);
      }, replaceNewlinesWithLiterallines: function(e2) {
        return nn(e2, (e3) => typeof e3 == "string" && e3.includes("\n") ? Zt(e3.split(/(\n)/g).map((e4, t2) => t2 % 2 == 0 ? e4 : Qt)) : e3);
      }}, debug: {printDocToDebug: (e2) => pn(cn(e2))}}, fn = Object.freeze({__proto__: null, default: {}});
      const hn = /[/\\]/;
      function mn(e2) {
        return e2.split(hn).pop();
      }
      var gn = Object.freeze({__proto__: null, extname: function(e2) {
        const t2 = mn(e2), n2 = t2.lastIndexOf(".");
        return n2 === -1 ? "" : t2.slice(n2);
      }, basename: mn, isAbsolute: function() {
        return true;
      }}), Dn = [], yn = [], En = typeof Uint8Array != "undefined" ? Uint8Array : Array, Cn = false;
      function bn() {
        Cn = true;
        for (var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, n2 = e2.length; t2 < n2; ++t2)
          Dn[t2] = e2[t2], yn[e2.charCodeAt(t2)] = t2;
        yn["-".charCodeAt(0)] = 62, yn["_".charCodeAt(0)] = 63;
      }
      function An(e2, t2, n2) {
        for (var r2, u2, o2 = [], a2 = t2; a2 < n2; a2 += 3)
          r2 = (e2[a2] << 16) + (e2[a2 + 1] << 8) + e2[a2 + 2], o2.push(Dn[(u2 = r2) >> 18 & 63] + Dn[u2 >> 12 & 63] + Dn[u2 >> 6 & 63] + Dn[63 & u2]);
        return o2.join("");
      }
      function vn(e2) {
        var t2;
        Cn || bn();
        for (var n2 = e2.length, r2 = n2 % 3, u2 = "", o2 = [], a2 = 0, i2 = n2 - r2; a2 < i2; a2 += 16383)
          o2.push(An(e2, a2, a2 + 16383 > i2 ? i2 : a2 + 16383));
        return r2 === 1 ? (t2 = e2[n2 - 1], u2 += Dn[t2 >> 2], u2 += Dn[t2 << 4 & 63], u2 += "==") : r2 === 2 && (t2 = (e2[n2 - 2] << 8) + e2[n2 - 1], u2 += Dn[t2 >> 10], u2 += Dn[t2 >> 4 & 63], u2 += Dn[t2 << 2 & 63], u2 += "="), o2.push(u2), o2.join("");
      }
      function Fn(e2, t2, n2, r2, u2) {
        var o2, a2, i2 = 8 * u2 - r2 - 1, s2 = (1 << i2) - 1, l2 = s2 >> 1, c2 = -7, p2 = n2 ? u2 - 1 : 0, d2 = n2 ? -1 : 1, f2 = e2[t2 + p2];
        for (p2 += d2, o2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += i2; c2 > 0; o2 = 256 * o2 + e2[t2 + p2], p2 += d2, c2 -= 8)
          ;
        for (a2 = o2 & (1 << -c2) - 1, o2 >>= -c2, c2 += r2; c2 > 0; a2 = 256 * a2 + e2[t2 + p2], p2 += d2, c2 -= 8)
          ;
        if (o2 === 0)
          o2 = 1 - l2;
        else {
          if (o2 === s2)
            return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
          a2 += Math.pow(2, r2), o2 -= l2;
        }
        return (f2 ? -1 : 1) * a2 * Math.pow(2, o2 - r2);
      }
      function xn(e2, t2, n2, r2, u2, o2) {
        var a2, i2, s2, l2 = 8 * o2 - u2 - 1, c2 = (1 << l2) - 1, p2 = c2 >> 1, d2 = u2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = r2 ? 0 : o2 - 1, h2 = r2 ? 1 : -1, m2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
        for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (i2 = isNaN(t2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (s2 = Math.pow(2, -a2)) < 1 && (a2--, s2 *= 2), (t2 += a2 + p2 >= 1 ? d2 / s2 : d2 * Math.pow(2, 1 - p2)) * s2 >= 2 && (a2++, s2 /= 2), a2 + p2 >= c2 ? (i2 = 0, a2 = c2) : a2 + p2 >= 1 ? (i2 = (t2 * s2 - 1) * Math.pow(2, u2), a2 += p2) : (i2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, u2), a2 = 0)); u2 >= 8; e2[n2 + f2] = 255 & i2, f2 += h2, i2 /= 256, u2 -= 8)
          ;
        for (a2 = a2 << u2 | i2, l2 += u2; l2 > 0; e2[n2 + f2] = 255 & a2, f2 += h2, a2 /= 256, l2 -= 8)
          ;
        e2[n2 + f2 - h2] |= 128 * m2;
      }
      var Sn = {}.toString, wn = Array.isArray || function(e2) {
        return Sn.call(e2) == "[object Array]";
      };
      function Bn() {
        return kn.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function Tn(e2, t2) {
        if (Bn() < t2)
          throw new RangeError("Invalid typed array length");
        return kn.TYPED_ARRAY_SUPPORT ? (e2 = new Uint8Array(t2)).__proto__ = kn.prototype : (e2 === null && (e2 = new kn(t2)), e2.length = t2), e2;
      }
      function kn(e2, t2, n2) {
        if (!(kn.TYPED_ARRAY_SUPPORT || this instanceof kn))
          return new kn(e2, t2, n2);
        if (typeof e2 == "number") {
          if (typeof t2 == "string")
            throw new Error("If encoding is specified then the first argument must be a string");
          return Pn(this, e2);
        }
        return Nn(this, e2, t2, n2);
      }
      function Nn(e2, t2, n2, r2) {
        if (typeof t2 == "number")
          throw new TypeError('"value" argument must not be a number');
        return typeof ArrayBuffer != "undefined" && t2 instanceof ArrayBuffer ? function(e3, t3, n3, r3) {
          if (t3.byteLength, n3 < 0 || t3.byteLength < n3)
            throw new RangeError("'offset' is out of bounds");
          if (t3.byteLength < n3 + (r3 || 0))
            throw new RangeError("'length' is out of bounds");
          t3 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t3) : r3 === void 0 ? new Uint8Array(t3, n3) : new Uint8Array(t3, n3, r3);
          kn.TYPED_ARRAY_SUPPORT ? (e3 = t3).__proto__ = kn.prototype : e3 = _n(e3, t3);
          return e3;
        }(e2, t2, n2, r2) : typeof t2 == "string" ? function(e3, t3, n3) {
          typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
          if (!kn.isEncoding(n3))
            throw new TypeError('"encoding" must be a valid string encoding');
          var r3 = 0 | Mn(t3, n3), u2 = (e3 = Tn(e3, r3)).write(t3, n3);
          u2 !== r3 && (e3 = e3.slice(0, u2));
          return e3;
        }(e2, t2, n2) : function(e3, t3) {
          if (jn(t3)) {
            var n3 = 0 | In(t3.length);
            return (e3 = Tn(e3, n3)).length === 0 || t3.copy(e3, 0, 0, n3), e3;
          }
          if (t3) {
            if (typeof ArrayBuffer != "undefined" && t3.buffer instanceof ArrayBuffer || "length" in t3)
              return typeof t3.length != "number" || (r3 = t3.length) != r3 ? Tn(e3, 0) : _n(e3, t3);
            if (t3.type === "Buffer" && wn(t3.data))
              return _n(e3, t3.data);
          }
          var r3;
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }(e2, t2);
      }
      function On(e2) {
        if (typeof e2 != "number")
          throw new TypeError('"size" argument must be a number');
        if (e2 < 0)
          throw new RangeError('"size" argument must not be negative');
      }
      function Pn(e2, t2) {
        if (On(t2), e2 = Tn(e2, t2 < 0 ? 0 : 0 | In(t2)), !kn.TYPED_ARRAY_SUPPORT)
          for (var n2 = 0; n2 < t2; ++n2)
            e2[n2] = 0;
        return e2;
      }
      function _n(e2, t2) {
        var n2 = t2.length < 0 ? 0 : 0 | In(t2.length);
        e2 = Tn(e2, n2);
        for (var r2 = 0; r2 < n2; r2 += 1)
          e2[r2] = 255 & t2[r2];
        return e2;
      }
      function In(e2) {
        if (e2 >= Bn())
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Bn().toString(16) + " bytes");
        return 0 | e2;
      }
      function jn(e2) {
        return !(e2 == null || !e2._isBuffer);
      }
      function Mn(e2, t2) {
        if (jn(e2))
          return e2.length;
        if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer))
          return e2.byteLength;
        typeof e2 != "string" && (e2 = "" + e2);
        var n2 = e2.length;
        if (n2 === 0)
          return 0;
        for (var r2 = false; ; )
          switch (t2) {
            case "ascii":
            case "latin1":
            case "binary":
              return n2;
            case "utf8":
            case "utf-8":
            case void 0:
              return lr(e2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * n2;
            case "hex":
              return n2 >>> 1;
            case "base64":
              return cr(e2).length;
            default:
              if (r2)
                return lr(e2).length;
              t2 = ("" + t2).toLowerCase(), r2 = true;
          }
      }
      function Ln(e2, t2, n2) {
        var r2 = false;
        if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length)
          return "";
        if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
          return "";
        if ((n2 >>>= 0) <= (t2 >>>= 0))
          return "";
        for (e2 || (e2 = "utf8"); ; )
          switch (e2) {
            case "hex":
              return Qn(this, t2, n2);
            case "utf8":
            case "utf-8":
              return Xn(this, t2, n2);
            case "ascii":
              return Yn(this, t2, n2);
            case "latin1":
            case "binary":
              return Kn(this, t2, n2);
            case "base64":
              return Hn(this, t2, n2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Zn(this, t2, n2);
            default:
              if (r2)
                throw new TypeError("Unknown encoding: " + e2);
              e2 = (e2 + "").toLowerCase(), r2 = true;
          }
      }
      function Rn(e2, t2, n2) {
        var r2 = e2[t2];
        e2[t2] = e2[n2], e2[n2] = r2;
      }
      function qn(e2, t2, n2, r2, u2) {
        if (e2.length === 0)
          return -1;
        if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = u2 ? 0 : e2.length - 1), n2 < 0 && (n2 = e2.length + n2), n2 >= e2.length) {
          if (u2)
            return -1;
          n2 = e2.length - 1;
        } else if (n2 < 0) {
          if (!u2)
            return -1;
          n2 = 0;
        }
        if (typeof t2 == "string" && (t2 = kn.from(t2, r2)), jn(t2))
          return t2.length === 0 ? -1 : Vn(e2, t2, n2, r2, u2);
        if (typeof t2 == "number")
          return t2 &= 255, kn.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? u2 ? Uint8Array.prototype.indexOf.call(e2, t2, n2) : Uint8Array.prototype.lastIndexOf.call(e2, t2, n2) : Vn(e2, [t2], n2, r2, u2);
        throw new TypeError("val must be string, number or Buffer");
      }
      function Vn(e2, t2, n2, r2, u2) {
        var o2, a2 = 1, i2 = e2.length, s2 = t2.length;
        if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
          if (e2.length < 2 || t2.length < 2)
            return -1;
          a2 = 2, i2 /= 2, s2 /= 2, n2 /= 2;
        }
        function l2(e3, t3) {
          return a2 === 1 ? e3[t3] : e3.readUInt16BE(t3 * a2);
        }
        if (u2) {
          var c2 = -1;
          for (o2 = n2; o2 < i2; o2++)
            if (l2(e2, o2) === l2(t2, c2 === -1 ? 0 : o2 - c2)) {
              if (c2 === -1 && (c2 = o2), o2 - c2 + 1 === s2)
                return c2 * a2;
            } else
              c2 !== -1 && (o2 -= o2 - c2), c2 = -1;
        } else
          for (n2 + s2 > i2 && (n2 = i2 - s2), o2 = n2; o2 >= 0; o2--) {
            for (var p2 = true, d2 = 0; d2 < s2; d2++)
              if (l2(e2, o2 + d2) !== l2(t2, d2)) {
                p2 = false;
                break;
              }
            if (p2)
              return o2;
          }
        return -1;
      }
      function Wn(e2, t2, n2, r2) {
        n2 = Number(n2) || 0;
        var u2 = e2.length - n2;
        r2 ? (r2 = Number(r2)) > u2 && (r2 = u2) : r2 = u2;
        var o2 = t2.length;
        if (o2 % 2 != 0)
          throw new TypeError("Invalid hex string");
        r2 > o2 / 2 && (r2 = o2 / 2);
        for (var a2 = 0; a2 < r2; ++a2) {
          var i2 = parseInt(t2.substr(2 * a2, 2), 16);
          if (isNaN(i2))
            return a2;
          e2[n2 + a2] = i2;
        }
        return a2;
      }
      function $n(e2, t2, n2, r2) {
        return pr(lr(t2, e2.length - n2), e2, n2, r2);
      }
      function Un(e2, t2, n2, r2) {
        return pr(function(e3) {
          for (var t3 = [], n3 = 0; n3 < e3.length; ++n3)
            t3.push(255 & e3.charCodeAt(n3));
          return t3;
        }(t2), e2, n2, r2);
      }
      function zn(e2, t2, n2, r2) {
        return Un(e2, t2, n2, r2);
      }
      function Jn(e2, t2, n2, r2) {
        return pr(cr(t2), e2, n2, r2);
      }
      function Gn(e2, t2, n2, r2) {
        return pr(function(e3, t3) {
          for (var n3, r3, u2, o2 = [], a2 = 0; a2 < e3.length && !((t3 -= 2) < 0); ++a2)
            r3 = (n3 = e3.charCodeAt(a2)) >> 8, u2 = n3 % 256, o2.push(u2), o2.push(r3);
          return o2;
        }(t2, e2.length - n2), e2, n2, r2);
      }
      function Hn(e2, t2, n2) {
        return t2 === 0 && n2 === e2.length ? vn(e2) : vn(e2.slice(t2, n2));
      }
      function Xn(e2, t2, n2) {
        n2 = Math.min(e2.length, n2);
        for (var r2 = [], u2 = t2; u2 < n2; ) {
          var o2, a2, i2, s2, l2 = e2[u2], c2 = null, p2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
          if (u2 + p2 <= n2)
            switch (p2) {
              case 1:
                l2 < 128 && (c2 = l2);
                break;
              case 2:
                (192 & (o2 = e2[u2 + 1])) == 128 && (s2 = (31 & l2) << 6 | 63 & o2) > 127 && (c2 = s2);
                break;
              case 3:
                o2 = e2[u2 + 1], a2 = e2[u2 + 2], (192 & o2) == 128 && (192 & a2) == 128 && (s2 = (15 & l2) << 12 | (63 & o2) << 6 | 63 & a2) > 2047 && (s2 < 55296 || s2 > 57343) && (c2 = s2);
                break;
              case 4:
                o2 = e2[u2 + 1], a2 = e2[u2 + 2], i2 = e2[u2 + 3], (192 & o2) == 128 && (192 & a2) == 128 && (192 & i2) == 128 && (s2 = (15 & l2) << 18 | (63 & o2) << 12 | (63 & a2) << 6 | 63 & i2) > 65535 && s2 < 1114112 && (c2 = s2);
            }
          c2 === null ? (c2 = 65533, p2 = 1) : c2 > 65535 && (c2 -= 65536, r2.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), r2.push(c2), u2 += p2;
        }
        return function(e3) {
          var t3 = e3.length;
          if (t3 <= 4096)
            return String.fromCharCode.apply(String, e3);
          var n3 = "", r3 = 0;
          for (; r3 < t3; )
            n3 += String.fromCharCode.apply(String, e3.slice(r3, r3 += 4096));
          return n3;
        }(r2);
      }
      kn.TYPED_ARRAY_SUPPORT = me.TYPED_ARRAY_SUPPORT === void 0 || me.TYPED_ARRAY_SUPPORT, kn.poolSize = 8192, kn._augment = function(e2) {
        return e2.__proto__ = kn.prototype, e2;
      }, kn.from = function(e2, t2, n2) {
        return Nn(null, e2, t2, n2);
      }, kn.TYPED_ARRAY_SUPPORT && (kn.prototype.__proto__ = Uint8Array.prototype, kn.__proto__ = Uint8Array), kn.alloc = function(e2, t2, n2) {
        return function(e3, t3, n3, r2) {
          return On(t3), t3 <= 0 ? Tn(e3, t3) : n3 !== void 0 ? typeof r2 == "string" ? Tn(e3, t3).fill(n3, r2) : Tn(e3, t3).fill(n3) : Tn(e3, t3);
        }(null, e2, t2, n2);
      }, kn.allocUnsafe = function(e2) {
        return Pn(null, e2);
      }, kn.allocUnsafeSlow = function(e2) {
        return Pn(null, e2);
      }, kn.isBuffer = function(e2) {
        return e2 != null && (!!e2._isBuffer || dr(e2) || function(e3) {
          return typeof e3.readFloatLE == "function" && typeof e3.slice == "function" && dr(e3.slice(0, 0));
        }(e2));
      }, kn.compare = function(e2, t2) {
        if (!jn(e2) || !jn(t2))
          throw new TypeError("Arguments must be Buffers");
        if (e2 === t2)
          return 0;
        for (var n2 = e2.length, r2 = t2.length, u2 = 0, o2 = Math.min(n2, r2); u2 < o2; ++u2)
          if (e2[u2] !== t2[u2]) {
            n2 = e2[u2], r2 = t2[u2];
            break;
          }
        return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
      }, kn.isEncoding = function(e2) {
        switch (String(e2).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, kn.concat = function(e2, t2) {
        if (!wn(e2))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (e2.length === 0)
          return kn.alloc(0);
        var n2;
        if (t2 === void 0)
          for (t2 = 0, n2 = 0; n2 < e2.length; ++n2)
            t2 += e2[n2].length;
        var r2 = kn.allocUnsafe(t2), u2 = 0;
        for (n2 = 0; n2 < e2.length; ++n2) {
          var o2 = e2[n2];
          if (!jn(o2))
            throw new TypeError('"list" argument must be an Array of Buffers');
          o2.copy(r2, u2), u2 += o2.length;
        }
        return r2;
      }, kn.byteLength = Mn, kn.prototype._isBuffer = true, kn.prototype.swap16 = function() {
        var e2 = this.length;
        if (e2 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t2 = 0; t2 < e2; t2 += 2)
          Rn(this, t2, t2 + 1);
        return this;
      }, kn.prototype.swap32 = function() {
        var e2 = this.length;
        if (e2 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t2 = 0; t2 < e2; t2 += 4)
          Rn(this, t2, t2 + 3), Rn(this, t2 + 1, t2 + 2);
        return this;
      }, kn.prototype.swap64 = function() {
        var e2 = this.length;
        if (e2 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t2 = 0; t2 < e2; t2 += 8)
          Rn(this, t2, t2 + 7), Rn(this, t2 + 1, t2 + 6), Rn(this, t2 + 2, t2 + 5), Rn(this, t2 + 3, t2 + 4);
        return this;
      }, kn.prototype.toString = function() {
        var e2 = 0 | this.length;
        return e2 === 0 ? "" : arguments.length === 0 ? Xn(this, 0, e2) : Ln.apply(this, arguments);
      }, kn.prototype.equals = function(e2) {
        if (!jn(e2))
          throw new TypeError("Argument must be a Buffer");
        return this === e2 || kn.compare(this, e2) === 0;
      }, kn.prototype.inspect = function() {
        var e2 = "";
        return this.length > 0 && (e2 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e2 += " ... ")), "<Buffer " + e2 + ">";
      }, kn.prototype.compare = function(e2, t2, n2, r2, u2) {
        if (!jn(e2))
          throw new TypeError("Argument must be a Buffer");
        if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e2 ? e2.length : 0), r2 === void 0 && (r2 = 0), u2 === void 0 && (u2 = this.length), t2 < 0 || n2 > e2.length || r2 < 0 || u2 > this.length)
          throw new RangeError("out of range index");
        if (r2 >= u2 && t2 >= n2)
          return 0;
        if (r2 >= u2)
          return -1;
        if (t2 >= n2)
          return 1;
        if (this === e2)
          return 0;
        for (var o2 = (u2 >>>= 0) - (r2 >>>= 0), a2 = (n2 >>>= 0) - (t2 >>>= 0), i2 = Math.min(o2, a2), s2 = this.slice(r2, u2), l2 = e2.slice(t2, n2), c2 = 0; c2 < i2; ++c2)
          if (s2[c2] !== l2[c2]) {
            o2 = s2[c2], a2 = l2[c2];
            break;
          }
        return o2 < a2 ? -1 : a2 < o2 ? 1 : 0;
      }, kn.prototype.includes = function(e2, t2, n2) {
        return this.indexOf(e2, t2, n2) !== -1;
      }, kn.prototype.indexOf = function(e2, t2, n2) {
        return qn(this, e2, t2, n2, true);
      }, kn.prototype.lastIndexOf = function(e2, t2, n2) {
        return qn(this, e2, t2, n2, false);
      }, kn.prototype.write = function(e2, t2, n2, r2) {
        if (t2 === void 0)
          r2 = "utf8", n2 = this.length, t2 = 0;
        else if (n2 === void 0 && typeof t2 == "string")
          r2 = t2, n2 = this.length, t2 = 0;
        else {
          if (!isFinite(t2))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          t2 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
        }
        var u2 = this.length - t2;
        if ((n2 === void 0 || n2 > u2) && (n2 = u2), e2.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        r2 || (r2 = "utf8");
        for (var o2 = false; ; )
          switch (r2) {
            case "hex":
              return Wn(this, e2, t2, n2);
            case "utf8":
            case "utf-8":
              return $n(this, e2, t2, n2);
            case "ascii":
              return Un(this, e2, t2, n2);
            case "latin1":
            case "binary":
              return zn(this, e2, t2, n2);
            case "base64":
              return Jn(this, e2, t2, n2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Gn(this, e2, t2, n2);
            default:
              if (o2)
                throw new TypeError("Unknown encoding: " + r2);
              r2 = ("" + r2).toLowerCase(), o2 = true;
          }
      }, kn.prototype.toJSON = function() {
        return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)};
      };
      function Yn(e2, t2, n2) {
        var r2 = "";
        n2 = Math.min(e2.length, n2);
        for (var u2 = t2; u2 < n2; ++u2)
          r2 += String.fromCharCode(127 & e2[u2]);
        return r2;
      }
      function Kn(e2, t2, n2) {
        var r2 = "";
        n2 = Math.min(e2.length, n2);
        for (var u2 = t2; u2 < n2; ++u2)
          r2 += String.fromCharCode(e2[u2]);
        return r2;
      }
      function Qn(e2, t2, n2) {
        var r2 = e2.length;
        (!t2 || t2 < 0) && (t2 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
        for (var u2 = "", o2 = t2; o2 < n2; ++o2)
          u2 += sr(e2[o2]);
        return u2;
      }
      function Zn(e2, t2, n2) {
        for (var r2 = e2.slice(t2, n2), u2 = "", o2 = 0; o2 < r2.length; o2 += 2)
          u2 += String.fromCharCode(r2[o2] + 256 * r2[o2 + 1]);
        return u2;
      }
      function er(e2, t2, n2) {
        if (e2 % 1 != 0 || e2 < 0)
          throw new RangeError("offset is not uint");
        if (e2 + t2 > n2)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function tr(e2, t2, n2, r2, u2, o2) {
        if (!jn(e2))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t2 > u2 || t2 < o2)
          throw new RangeError('"value" argument is out of bounds');
        if (n2 + r2 > e2.length)
          throw new RangeError("Index out of range");
      }
      function nr(e2, t2, n2, r2) {
        t2 < 0 && (t2 = 65535 + t2 + 1);
        for (var u2 = 0, o2 = Math.min(e2.length - n2, 2); u2 < o2; ++u2)
          e2[n2 + u2] = (t2 & 255 << 8 * (r2 ? u2 : 1 - u2)) >>> 8 * (r2 ? u2 : 1 - u2);
      }
      function rr(e2, t2, n2, r2) {
        t2 < 0 && (t2 = 4294967295 + t2 + 1);
        for (var u2 = 0, o2 = Math.min(e2.length - n2, 4); u2 < o2; ++u2)
          e2[n2 + u2] = t2 >>> 8 * (r2 ? u2 : 3 - u2) & 255;
      }
      function ur(e2, t2, n2, r2, u2, o2) {
        if (n2 + r2 > e2.length)
          throw new RangeError("Index out of range");
        if (n2 < 0)
          throw new RangeError("Index out of range");
      }
      function or(e2, t2, n2, r2, u2) {
        return u2 || ur(e2, 0, n2, 4), xn(e2, t2, n2, r2, 23, 4), n2 + 4;
      }
      function ar(e2, t2, n2, r2, u2) {
        return u2 || ur(e2, 0, n2, 8), xn(e2, t2, n2, r2, 52, 8), n2 + 8;
      }
      kn.prototype.slice = function(e2, t2) {
        var n2, r2 = this.length;
        if ((e2 = ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), (t2 = t2 === void 0 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e2 && (t2 = e2), kn.TYPED_ARRAY_SUPPORT)
          (n2 = this.subarray(e2, t2)).__proto__ = kn.prototype;
        else {
          var u2 = t2 - e2;
          n2 = new kn(u2, void 0);
          for (var o2 = 0; o2 < u2; ++o2)
            n2[o2] = this[o2 + e2];
        }
        return n2;
      }, kn.prototype.readUIntLE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || er(e2, t2, this.length);
        for (var r2 = this[e2], u2 = 1, o2 = 0; ++o2 < t2 && (u2 *= 256); )
          r2 += this[e2 + o2] * u2;
        return r2;
      }, kn.prototype.readUIntBE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || er(e2, t2, this.length);
        for (var r2 = this[e2 + --t2], u2 = 1; t2 > 0 && (u2 *= 256); )
          r2 += this[e2 + --t2] * u2;
        return r2;
      }, kn.prototype.readUInt8 = function(e2, t2) {
        return t2 || er(e2, 1, this.length), this[e2];
      }, kn.prototype.readUInt16LE = function(e2, t2) {
        return t2 || er(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
      }, kn.prototype.readUInt16BE = function(e2, t2) {
        return t2 || er(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
      }, kn.prototype.readUInt32LE = function(e2, t2) {
        return t2 || er(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
      }, kn.prototype.readUInt32BE = function(e2, t2) {
        return t2 || er(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
      }, kn.prototype.readIntLE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || er(e2, t2, this.length);
        for (var r2 = this[e2], u2 = 1, o2 = 0; ++o2 < t2 && (u2 *= 256); )
          r2 += this[e2 + o2] * u2;
        return r2 >= (u2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
      }, kn.prototype.readIntBE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || er(e2, t2, this.length);
        for (var r2 = t2, u2 = 1, o2 = this[e2 + --r2]; r2 > 0 && (u2 *= 256); )
          o2 += this[e2 + --r2] * u2;
        return o2 >= (u2 *= 128) && (o2 -= Math.pow(2, 8 * t2)), o2;
      }, kn.prototype.readInt8 = function(e2, t2) {
        return t2 || er(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
      }, kn.prototype.readInt16LE = function(e2, t2) {
        t2 || er(e2, 2, this.length);
        var n2 = this[e2] | this[e2 + 1] << 8;
        return 32768 & n2 ? 4294901760 | n2 : n2;
      }, kn.prototype.readInt16BE = function(e2, t2) {
        t2 || er(e2, 2, this.length);
        var n2 = this[e2 + 1] | this[e2] << 8;
        return 32768 & n2 ? 4294901760 | n2 : n2;
      }, kn.prototype.readInt32LE = function(e2, t2) {
        return t2 || er(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
      }, kn.prototype.readInt32BE = function(e2, t2) {
        return t2 || er(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
      }, kn.prototype.readFloatLE = function(e2, t2) {
        return t2 || er(e2, 4, this.length), Fn(this, e2, true, 23, 4);
      }, kn.prototype.readFloatBE = function(e2, t2) {
        return t2 || er(e2, 4, this.length), Fn(this, e2, false, 23, 4);
      }, kn.prototype.readDoubleLE = function(e2, t2) {
        return t2 || er(e2, 8, this.length), Fn(this, e2, true, 52, 8);
      }, kn.prototype.readDoubleBE = function(e2, t2) {
        return t2 || er(e2, 8, this.length), Fn(this, e2, false, 52, 8);
      }, kn.prototype.writeUIntLE = function(e2, t2, n2, r2) {
        (e2 = +e2, t2 |= 0, n2 |= 0, r2) || tr(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
        var u2 = 1, o2 = 0;
        for (this[t2] = 255 & e2; ++o2 < n2 && (u2 *= 256); )
          this[t2 + o2] = e2 / u2 & 255;
        return t2 + n2;
      }, kn.prototype.writeUIntBE = function(e2, t2, n2, r2) {
        (e2 = +e2, t2 |= 0, n2 |= 0, r2) || tr(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
        var u2 = n2 - 1, o2 = 1;
        for (this[t2 + u2] = 255 & e2; --u2 >= 0 && (o2 *= 256); )
          this[t2 + u2] = e2 / o2 & 255;
        return t2 + n2;
      }, kn.prototype.writeUInt8 = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 1, 255, 0), kn.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t2] = 255 & e2, t2 + 1;
      }, kn.prototype.writeUInt16LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 2, 65535, 0), kn.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : nr(this, e2, t2, true), t2 + 2;
      }, kn.prototype.writeUInt16BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 2, 65535, 0), kn.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : nr(this, e2, t2, false), t2 + 2;
      }, kn.prototype.writeUInt32LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 4, 4294967295, 0), kn.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e2 >>> 24, this[t2 + 2] = e2 >>> 16, this[t2 + 1] = e2 >>> 8, this[t2] = 255 & e2) : rr(this, e2, t2, true), t2 + 4;
      }, kn.prototype.writeUInt32BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 4, 4294967295, 0), kn.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : rr(this, e2, t2, false), t2 + 4;
      }, kn.prototype.writeIntLE = function(e2, t2, n2, r2) {
        if (e2 = +e2, t2 |= 0, !r2) {
          var u2 = Math.pow(2, 8 * n2 - 1);
          tr(this, e2, t2, n2, u2 - 1, -u2);
        }
        var o2 = 0, a2 = 1, i2 = 0;
        for (this[t2] = 255 & e2; ++o2 < n2 && (a2 *= 256); )
          e2 < 0 && i2 === 0 && this[t2 + o2 - 1] !== 0 && (i2 = 1), this[t2 + o2] = (e2 / a2 >> 0) - i2 & 255;
        return t2 + n2;
      }, kn.prototype.writeIntBE = function(e2, t2, n2, r2) {
        if (e2 = +e2, t2 |= 0, !r2) {
          var u2 = Math.pow(2, 8 * n2 - 1);
          tr(this, e2, t2, n2, u2 - 1, -u2);
        }
        var o2 = n2 - 1, a2 = 1, i2 = 0;
        for (this[t2 + o2] = 255 & e2; --o2 >= 0 && (a2 *= 256); )
          e2 < 0 && i2 === 0 && this[t2 + o2 + 1] !== 0 && (i2 = 1), this[t2 + o2] = (e2 / a2 >> 0) - i2 & 255;
        return t2 + n2;
      }, kn.prototype.writeInt8 = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 1, 127, -128), kn.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t2] = 255 & e2, t2 + 1;
      }, kn.prototype.writeInt16LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 2, 32767, -32768), kn.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : nr(this, e2, t2, true), t2 + 2;
      }, kn.prototype.writeInt16BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 2, 32767, -32768), kn.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : nr(this, e2, t2, false), t2 + 2;
      }, kn.prototype.writeInt32LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 4, 2147483647, -2147483648), kn.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8, this[t2 + 2] = e2 >>> 16, this[t2 + 3] = e2 >>> 24) : rr(this, e2, t2, true), t2 + 4;
      }, kn.prototype.writeInt32BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || tr(this, e2, t2, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), kn.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : rr(this, e2, t2, false), t2 + 4;
      }, kn.prototype.writeFloatLE = function(e2, t2, n2) {
        return or(this, e2, t2, true, n2);
      }, kn.prototype.writeFloatBE = function(e2, t2, n2) {
        return or(this, e2, t2, false, n2);
      }, kn.prototype.writeDoubleLE = function(e2, t2, n2) {
        return ar(this, e2, t2, true, n2);
      }, kn.prototype.writeDoubleBE = function(e2, t2, n2) {
        return ar(this, e2, t2, false, n2);
      }, kn.prototype.copy = function(e2, t2, n2, r2) {
        if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t2 >= e2.length && (t2 = e2.length), t2 || (t2 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
          return 0;
        if (e2.length === 0 || this.length === 0)
          return 0;
        if (t2 < 0)
          throw new RangeError("targetStart out of bounds");
        if (n2 < 0 || n2 >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (r2 < 0)
          throw new RangeError("sourceEnd out of bounds");
        r2 > this.length && (r2 = this.length), e2.length - t2 < r2 - n2 && (r2 = e2.length - t2 + n2);
        var u2, o2 = r2 - n2;
        if (this === e2 && n2 < t2 && t2 < r2)
          for (u2 = o2 - 1; u2 >= 0; --u2)
            e2[u2 + t2] = this[u2 + n2];
        else if (o2 < 1e3 || !kn.TYPED_ARRAY_SUPPORT)
          for (u2 = 0; u2 < o2; ++u2)
            e2[u2 + t2] = this[u2 + n2];
        else
          Uint8Array.prototype.set.call(e2, this.subarray(n2, n2 + o2), t2);
        return o2;
      }, kn.prototype.fill = function(e2, t2, n2, r2) {
        if (typeof e2 == "string") {
          if (typeof t2 == "string" ? (r2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e2.length === 1) {
            var u2 = e2.charCodeAt(0);
            u2 < 256 && (e2 = u2);
          }
          if (r2 !== void 0 && typeof r2 != "string")
            throw new TypeError("encoding must be a string");
          if (typeof r2 == "string" && !kn.isEncoding(r2))
            throw new TypeError("Unknown encoding: " + r2);
        } else
          typeof e2 == "number" && (e2 &= 255);
        if (t2 < 0 || this.length < t2 || this.length < n2)
          throw new RangeError("Out of range index");
        if (n2 <= t2)
          return this;
        var o2;
        if (t2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e2 || (e2 = 0), typeof e2 == "number")
          for (o2 = t2; o2 < n2; ++o2)
            this[o2] = e2;
        else {
          var a2 = jn(e2) ? e2 : lr(new kn(e2, r2).toString()), i2 = a2.length;
          for (o2 = 0; o2 < n2 - t2; ++o2)
            this[o2 + t2] = a2[o2 % i2];
        }
        return this;
      };
      var ir = /[^+\/0-9A-Za-z-_]/g;
      function sr(e2) {
        return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
      }
      function lr(e2, t2) {
        var n2;
        t2 = t2 || 1 / 0;
        for (var r2 = e2.length, u2 = null, o2 = [], a2 = 0; a2 < r2; ++a2) {
          if ((n2 = e2.charCodeAt(a2)) > 55295 && n2 < 57344) {
            if (!u2) {
              if (n2 > 56319) {
                (t2 -= 3) > -1 && o2.push(239, 191, 189);
                continue;
              }
              if (a2 + 1 === r2) {
                (t2 -= 3) > -1 && o2.push(239, 191, 189);
                continue;
              }
              u2 = n2;
              continue;
            }
            if (n2 < 56320) {
              (t2 -= 3) > -1 && o2.push(239, 191, 189), u2 = n2;
              continue;
            }
            n2 = 65536 + (u2 - 55296 << 10 | n2 - 56320);
          } else
            u2 && (t2 -= 3) > -1 && o2.push(239, 191, 189);
          if (u2 = null, n2 < 128) {
            if ((t2 -= 1) < 0)
              break;
            o2.push(n2);
          } else if (n2 < 2048) {
            if ((t2 -= 2) < 0)
              break;
            o2.push(n2 >> 6 | 192, 63 & n2 | 128);
          } else if (n2 < 65536) {
            if ((t2 -= 3) < 0)
              break;
            o2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
          } else {
            if (!(n2 < 1114112))
              throw new Error("Invalid code point");
            if ((t2 -= 4) < 0)
              break;
            o2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
          }
        }
        return o2;
      }
      function cr(e2) {
        return function(e3) {
          var t2, n2, r2, u2, o2, a2;
          Cn || bn();
          var i2 = e3.length;
          if (i2 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          o2 = e3[i2 - 2] === "=" ? 2 : e3[i2 - 1] === "=" ? 1 : 0, a2 = new En(3 * i2 / 4 - o2), r2 = o2 > 0 ? i2 - 4 : i2;
          var s2 = 0;
          for (t2 = 0, n2 = 0; t2 < r2; t2 += 4, n2 += 3)
            u2 = yn[e3.charCodeAt(t2)] << 18 | yn[e3.charCodeAt(t2 + 1)] << 12 | yn[e3.charCodeAt(t2 + 2)] << 6 | yn[e3.charCodeAt(t2 + 3)], a2[s2++] = u2 >> 16 & 255, a2[s2++] = u2 >> 8 & 255, a2[s2++] = 255 & u2;
          return o2 === 2 ? (u2 = yn[e3.charCodeAt(t2)] << 2 | yn[e3.charCodeAt(t2 + 1)] >> 4, a2[s2++] = 255 & u2) : o2 === 1 && (u2 = yn[e3.charCodeAt(t2)] << 10 | yn[e3.charCodeAt(t2 + 1)] << 4 | yn[e3.charCodeAt(t2 + 2)] >> 2, a2[s2++] = u2 >> 8 & 255, a2[s2++] = 255 & u2), a2;
        }(function(e3) {
          if ((e3 = function(e4) {
            return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
          }(e3).replace(ir, "")).length < 2)
            return "";
          for (; e3.length % 4 != 0; )
            e3 += "=";
          return e3;
        }(e2));
      }
      function pr(e2, t2, n2, r2) {
        for (var u2 = 0; u2 < r2 && !(u2 + n2 >= t2.length || u2 >= e2.length); ++u2)
          t2[u2 + n2] = e2[u2];
        return u2;
      }
      function dr(e2) {
        return !!e2.constructor && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
      }
      var fr = Ue(fn);
      var hr = class {
        constructor(e2, t2) {
          (t2 = t2 || {}).readChunk || (t2.readChunk = 1024), t2.newLineCharacter ? t2.newLineCharacter = t2.newLineCharacter.charCodeAt(0) : t2.newLineCharacter = 10, this.fd = typeof e2 == "number" ? e2 : fr.openSync(e2, "r"), this.options = t2, this.newLineCharacter = t2.newLineCharacter, this.reset();
        }
        _searchInBuffer(e2, t2) {
          let n2 = -1;
          for (let r2 = 0; r2 <= e2.length; r2++) {
            if (e2[r2] === t2) {
              n2 = r2;
              break;
            }
          }
          return n2;
        }
        reset() {
          this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
        }
        close() {
          fr.closeSync(this.fd), this.fd = null;
        }
        _extractLines(e2) {
          let t2;
          const n2 = [];
          let r2 = 0, u2 = 0;
          for (; ; ) {
            let o3 = e2[r2++];
            if (o3 === this.newLineCharacter)
              t2 = e2.slice(u2, r2), n2.push(t2), u2 = r2;
            else if (!o3)
              break;
          }
          let o2 = e2.slice(u2, r2);
          return o2.length && n2.push(o2), n2;
        }
        _readChunk(e2) {
          let t2, n2 = 0;
          const r2 = [];
          do {
            const e3 = new kn(this.options.readChunk);
            t2 = fr.readSync(this.fd, e3, 0, this.options.readChunk, this.fdPosition), n2 += t2, this.fdPosition = this.fdPosition + t2, r2.push(e3);
          } while (t2 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
          let u2 = kn.concat(r2);
          return t2 < this.options.readChunk && (this.eofReached = true, u2 = u2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(u2), e2 && (this.linesCache[0] = kn.concat([e2, this.linesCache[0]]))), n2;
        }
        next() {
          if (!this.fd)
            return false;
          let e2, t2 = false;
          if (this.eofReached && this.linesCache.length === 0)
            return t2;
          if (this.linesCache.length || (e2 = this._readChunk()), this.linesCache.length) {
            t2 = this.linesCache.shift();
            t2[t2.length - 1] !== 10 && (e2 = this._readChunk(t2), e2 && (t2 = this.linesCache.shift()));
          }
          return this.eofReached && this.linesCache.length === 0 && this.close(), t2 && t2[t2.length - 1] === this.newLineCharacter && (t2 = t2.slice(0, t2.length - 1)), t2;
        }
      };
      var mr = function(e2) {
        for (var t2 = -1, n2 = e2 == null ? 0 : e2.length, r2 = {}; ++t2 < n2; ) {
          var u2 = e2[t2];
          r2[u2[0]] = u2[1];
        }
        return r2;
      };
      class gr extends Error {
      }
      class Dr extends Error {
      }
      class yr extends Error {
      }
      var Er = {ConfigError: gr, DebugError: Dr, UndefinedParserError: yr}, Cr = function(e2, t2) {
        return (Cr = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n2 in t3)
            t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
        })(e2, t2);
      };
      /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
      
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
      
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
      var br = function() {
        return (br = Object.assign || function(e2) {
          for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
            for (var u2 in t2 = arguments[n2])
              Object.prototype.hasOwnProperty.call(t2, u2) && (e2[u2] = t2[u2]);
          return e2;
        }).apply(this, arguments);
      };
      function Ar(e2) {
        var t2 = typeof Symbol == "function" && Symbol.iterator, n2 = t2 && e2[t2], r2 = 0;
        if (n2)
          return n2.call(e2);
        if (e2 && typeof e2.length == "number")
          return {next: function() {
            return e2 && r2 >= e2.length && (e2 = void 0), {value: e2 && e2[r2++], done: !e2};
          }};
        throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function vr(e2, t2) {
        var n2 = typeof Symbol == "function" && e2[Symbol.iterator];
        if (!n2)
          return e2;
        var r2, u2, o2 = n2.call(e2), a2 = [];
        try {
          for (; (t2 === void 0 || t2-- > 0) && !(r2 = o2.next()).done; )
            a2.push(r2.value);
        } catch (e3) {
          u2 = {error: e3};
        } finally {
          try {
            r2 && !r2.done && (n2 = o2.return) && n2.call(o2);
          } finally {
            if (u2)
              throw u2.error;
          }
        }
        return a2;
      }
      function Fr(e2) {
        return this instanceof Fr ? (this.v = e2, this) : new Fr(e2);
      }
      var xr = Object.freeze({__proto__: null, __extends: function(e2, t2) {
        function n2() {
          this.constructor = e2;
        }
        Cr(e2, t2), e2.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
      }, get __assign() {
        return br;
      }, __rest: function(e2, t2) {
        var n2 = {};
        for (var r2 in e2)
          Object.prototype.hasOwnProperty.call(e2, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
        if (e2 != null && typeof Object.getOwnPropertySymbols == "function") {
          var u2 = 0;
          for (r2 = Object.getOwnPropertySymbols(e2); u2 < r2.length; u2++)
            t2.indexOf(r2[u2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[u2]) && (n2[r2[u2]] = e2[r2[u2]]);
        }
        return n2;
      }, __decorate: function(e2, t2, n2, r2) {
        var u2, o2 = arguments.length, a2 = o2 < 3 ? t2 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          a2 = Reflect.decorate(e2, t2, n2, r2);
        else
          for (var i2 = e2.length - 1; i2 >= 0; i2--)
            (u2 = e2[i2]) && (a2 = (o2 < 3 ? u2(a2) : o2 > 3 ? u2(t2, n2, a2) : u2(t2, n2)) || a2);
        return o2 > 3 && a2 && Object.defineProperty(t2, n2, a2), a2;
      }, __param: function(e2, t2) {
        return function(n2, r2) {
          t2(n2, r2, e2);
        };
      }, __metadata: function(e2, t2) {
        if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
          return Reflect.metadata(e2, t2);
      }, __awaiter: function(e2, t2, n2, r2) {
        return new (n2 || (n2 = Promise))(function(u2, o2) {
          function a2(e3) {
            try {
              s2(r2.next(e3));
            } catch (e4) {
              o2(e4);
            }
          }
          function i2(e3) {
            try {
              s2(r2.throw(e3));
            } catch (e4) {
              o2(e4);
            }
          }
          function s2(e3) {
            var t3;
            e3.done ? u2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
              e4(t3);
            })).then(a2, i2);
          }
          s2((r2 = r2.apply(e2, t2 || [])).next());
        });
      }, __generator: function(e2, t2) {
        var n2, r2, u2, o2, a2 = {label: 0, sent: function() {
          if (1 & u2[0])
            throw u2[1];
          return u2[1];
        }, trys: [], ops: []};
        return o2 = {next: i2(0), throw: i2(1), return: i2(2)}, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function i2(o3) {
          return function(i3) {
            return function(o4) {
              if (n2)
                throw new TypeError("Generator is already executing.");
              for (; a2; )
                try {
                  if (n2 = 1, r2 && (u2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((u2 = r2.return) && u2.call(r2), 0) : r2.next) && !(u2 = u2.call(r2, o4[1])).done)
                    return u2;
                  switch (r2 = 0, u2 && (o4 = [2 & o4[0], u2.value]), o4[0]) {
                    case 0:
                    case 1:
                      u2 = o4;
                      break;
                    case 4:
                      return a2.label++, {value: o4[1], done: false};
                    case 5:
                      a2.label++, r2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (!(u2 = a2.trys, (u2 = u2.length > 0 && u2[u2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
                        a2 = 0;
                        continue;
                      }
                      if (o4[0] === 3 && (!u2 || o4[1] > u2[0] && o4[1] < u2[3])) {
                        a2.label = o4[1];
                        break;
                      }
                      if (o4[0] === 6 && a2.label < u2[1]) {
                        a2.label = u2[1], u2 = o4;
                        break;
                      }
                      if (u2 && a2.label < u2[2]) {
                        a2.label = u2[2], a2.ops.push(o4);
                        break;
                      }
                      u2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  o4 = t2.call(e2, a2);
                } catch (e3) {
                  o4 = [6, e3], r2 = 0;
                } finally {
                  n2 = u2 = 0;
                }
              if (5 & o4[0])
                throw o4[1];
              return {value: o4[0] ? o4[1] : void 0, done: true};
            }([o3, i3]);
          };
        }
      }, __createBinding: function(e2, t2, n2, r2) {
        r2 === void 0 && (r2 = n2), e2[r2] = t2[n2];
      }, __exportStar: function(e2, t2) {
        for (var n2 in e2)
          n2 === "default" || t2.hasOwnProperty(n2) || (t2[n2] = e2[n2]);
      }, __values: Ar, __read: vr, __spread: function() {
        for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
          e2 = e2.concat(vr(arguments[t2]));
        return e2;
      }, __spreadArrays: function() {
        for (var e2 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
          e2 += arguments[t2].length;
        var r2 = Array(e2), u2 = 0;
        for (t2 = 0; t2 < n2; t2++)
          for (var o2 = arguments[t2], a2 = 0, i2 = o2.length; a2 < i2; a2++, u2++)
            r2[u2] = o2[a2];
        return r2;
      }, __await: Fr, __asyncGenerator: function(e2, t2, n2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var r2, u2 = n2.apply(e2, t2 || []), o2 = [];
        return r2 = {}, a2("next"), a2("throw"), a2("return"), r2[Symbol.asyncIterator] = function() {
          return this;
        }, r2;
        function a2(e3) {
          u2[e3] && (r2[e3] = function(t3) {
            return new Promise(function(n3, r3) {
              o2.push([e3, t3, n3, r3]) > 1 || i2(e3, t3);
            });
          });
        }
        function i2(e3, t3) {
          try {
            (n3 = u2[e3](t3)).value instanceof Fr ? Promise.resolve(n3.value.v).then(s2, l2) : c2(o2[0][2], n3);
          } catch (e4) {
            c2(o2[0][3], e4);
          }
          var n3;
        }
        function s2(e3) {
          i2("next", e3);
        }
        function l2(e3) {
          i2("throw", e3);
        }
        function c2(e3, t3) {
          e3(t3), o2.shift(), o2.length && i2(o2[0][0], o2[0][1]);
        }
      }, __asyncDelegator: function(e2) {
        var t2, n2;
        return t2 = {}, r2("next"), r2("throw", function(e3) {
          throw e3;
        }), r2("return"), t2[Symbol.iterator] = function() {
          return this;
        }, t2;
        function r2(r3, u2) {
          t2[r3] = e2[r3] ? function(t3) {
            return (n2 = !n2) ? {value: Fr(e2[r3](t3)), done: r3 === "return"} : u2 ? u2(t3) : t3;
          } : u2;
        }
      }, __asyncValues: function(e2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t2, n2 = e2[Symbol.asyncIterator];
        return n2 ? n2.call(e2) : (e2 = Ar(e2), t2 = {}, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
          return this;
        }, t2);
        function r2(n3) {
          t2[n3] = e2[n3] && function(t3) {
            return new Promise(function(r3, u2) {
              (function(e3, t4, n4, r4) {
                Promise.resolve(r4).then(function(t5) {
                  e3({value: t5, done: n4});
                }, t4);
              })(r3, u2, (t3 = e2[n3](t3)).done, t3.value);
            });
          };
        }
      }, __makeTemplateObject: function(e2, t2) {
        return Object.defineProperty ? Object.defineProperty(e2, "raw", {value: t2}) : e2.raw = t2, e2;
      }, __importStar: function(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = {};
        if (e2 != null)
          for (var n2 in e2)
            Object.hasOwnProperty.call(e2, n2) && (t2[n2] = e2[n2]);
        return t2.default = e2, t2;
      }, __importDefault: function(e2) {
        return e2 && e2.__esModule ? e2 : {default: e2};
      }, __classPrivateFieldGet: function(e2, t2) {
        if (!t2.has(e2))
          throw new TypeError("attempted to get private field on non-instance");
        return t2.get(e2);
      }, __classPrivateFieldSet: function(e2, t2, n2) {
        if (!t2.has(e2))
          throw new TypeError("attempted to set private field on non-instance");
        return t2.set(e2, n2), n2;
      }}), Sr = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.apiDescriptor = {key: (e3) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e3) ? e3 : JSON.stringify(e3), value(e3) {
          if (e3 === null || typeof e3 != "object")
            return JSON.stringify(e3);
          if (Array.isArray(e3))
            return "[".concat(e3.map((e4) => t2.apiDescriptor.value(e4)).join(", "), "]");
          const n2 = Object.keys(e3);
          return n2.length === 0 ? "{}" : "{ ".concat(n2.map((n3) => "".concat(t2.apiDescriptor.key(n3), ": ").concat(t2.apiDescriptor.value(e3[n3]))).join(", "), " }");
        }, pair: ({key: e3, value: n2}) => t2.apiDescriptor.value({[e3]: n2})};
      }), wr = Ue(xr), Br = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), wr.__exportStar(Sr, t2);
      }), Tr = /[|\\{}()[\]^$+*?.]/g, kr = function(e2) {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(Tr, "\\$&");
      }, Nr = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50]}, Or = $e(function(e2) {
        var t2 = {};
        for (var n2 in Nr)
          Nr.hasOwnProperty(n2) && (t2[Nr[n2]] = n2);
        var r2 = e2.exports = {rgb: {channels: 3, labels: "rgb"}, hsl: {channels: 3, labels: "hsl"}, hsv: {channels: 3, labels: "hsv"}, hwb: {channels: 3, labels: "hwb"}, cmyk: {channels: 4, labels: "cmyk"}, xyz: {channels: 3, labels: "xyz"}, lab: {channels: 3, labels: "lab"}, lch: {channels: 3, labels: "lch"}, hex: {channels: 1, labels: ["hex"]}, keyword: {channels: 1, labels: ["keyword"]}, ansi16: {channels: 1, labels: ["ansi16"]}, ansi256: {channels: 1, labels: ["ansi256"]}, hcg: {channels: 3, labels: ["h", "c", "g"]}, apple: {channels: 3, labels: ["r16", "g16", "b16"]}, gray: {channels: 1, labels: ["gray"]}};
        for (var u2 in r2)
          if (r2.hasOwnProperty(u2)) {
            if (!("channels" in r2[u2]))
              throw new Error("missing channels property: " + u2);
            if (!("labels" in r2[u2]))
              throw new Error("missing channel labels property: " + u2);
            if (r2[u2].labels.length !== r2[u2].channels)
              throw new Error("channel and label counts mismatch: " + u2);
            var o2 = r2[u2].channels, a2 = r2[u2].labels;
            delete r2[u2].channels, delete r2[u2].labels, Object.defineProperty(r2[u2], "channels", {value: o2}), Object.defineProperty(r2[u2], "labels", {value: a2});
          }
        r2.rgb.hsl = function(e3) {
          var t3, n3, r3 = e3[0] / 255, u3 = e3[1] / 255, o3 = e3[2] / 255, a3 = Math.min(r3, u3, o3), i2 = Math.max(r3, u3, o3), s2 = i2 - a3;
          return i2 === a3 ? t3 = 0 : r3 === i2 ? t3 = (u3 - o3) / s2 : u3 === i2 ? t3 = 2 + (o3 - r3) / s2 : o3 === i2 && (t3 = 4 + (r3 - u3) / s2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (a3 + i2) / 2, [t3, 100 * (i2 === a3 ? 0 : n3 <= 0.5 ? s2 / (i2 + a3) : s2 / (2 - i2 - a3)), 100 * n3];
        }, r2.rgb.hsv = function(e3) {
          var t3, n3, r3, u3, o3, a3 = e3[0] / 255, i2 = e3[1] / 255, s2 = e3[2] / 255, l2 = Math.max(a3, i2, s2), c2 = l2 - Math.min(a3, i2, s2), p2 = function(e4) {
            return (l2 - e4) / 6 / c2 + 0.5;
          };
          return c2 === 0 ? u3 = o3 = 0 : (o3 = c2 / l2, t3 = p2(a3), n3 = p2(i2), r3 = p2(s2), a3 === l2 ? u3 = r3 - n3 : i2 === l2 ? u3 = 1 / 3 + t3 - r3 : s2 === l2 && (u3 = 2 / 3 + n3 - t3), u3 < 0 ? u3 += 1 : u3 > 1 && (u3 -= 1)), [360 * u3, 100 * o3, 100 * l2];
        }, r2.rgb.hwb = function(e3) {
          var t3 = e3[0], n3 = e3[1], u3 = e3[2];
          return [r2.rgb.hsl(e3)[0], 100 * (1 / 255 * Math.min(t3, Math.min(n3, u3))), 100 * (u3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, u3)))];
        }, r2.rgb.cmyk = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, u3 = e3[2] / 255;
          return [100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - u3))) / (1 - t3) || 0), 100 * ((1 - r3 - t3) / (1 - t3) || 0), 100 * ((1 - u3 - t3) / (1 - t3) || 0), 100 * t3];
        }, r2.rgb.keyword = function(e3) {
          var n3 = t2[e3];
          if (n3)
            return n3;
          var r3, u3, o3, a3 = 1 / 0;
          for (var i2 in Nr)
            if (Nr.hasOwnProperty(i2)) {
              var s2 = Nr[i2], l2 = (u3 = e3, o3 = s2, Math.pow(u3[0] - o3[0], 2) + Math.pow(u3[1] - o3[1], 2) + Math.pow(u3[2] - o3[2], 2));
              l2 < a3 && (a3 = l2, r3 = i2);
            }
          return r3;
        }, r2.keyword.rgb = function(e3) {
          return Nr[e3];
        }, r2.rgb.xyz = function(e3) {
          var t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255;
          return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
        }, r2.rgb.lab = function(e3) {
          var t3 = r2.rgb.xyz(e3), n3 = t3[0], u3 = t3[1], o3 = t3[2];
          return u3 /= 100, o3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (u3 = u3 > 8856e-6 ? Math.pow(u3, 1 / 3) : 7.787 * u3 + 16 / 116) - 16, 500 * (n3 - u3), 200 * (u3 - (o3 = o3 > 8856e-6 ? Math.pow(o3, 1 / 3) : 7.787 * o3 + 16 / 116))];
        }, r2.hsl.rgb = function(e3) {
          var t3, n3, r3, u3, o3, a3 = e3[0] / 360, i2 = e3[1] / 100, s2 = e3[2] / 100;
          if (i2 === 0)
            return [o3 = 255 * s2, o3, o3];
          t3 = 2 * s2 - (n3 = s2 < 0.5 ? s2 * (1 + i2) : s2 + i2 - s2 * i2), u3 = [0, 0, 0];
          for (var l2 = 0; l2 < 3; l2++)
            (r3 = a3 + 1 / 3 * -(l2 - 1)) < 0 && r3++, r3 > 1 && r3--, o3 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, u3[l2] = 255 * o3;
          return u3;
        }, r2.hsl.hsv = function(e3) {
          var t3 = e3[0], n3 = e3[1] / 100, r3 = e3[2] / 100, u3 = n3, o3 = Math.max(r3, 0.01);
          return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, u3 *= o3 <= 1 ? o3 : 2 - o3, [t3, 100 * (r3 === 0 ? 2 * u3 / (o3 + u3) : 2 * n3 / (r3 + n3)), 100 * ((r3 + n3) / 2)];
        }, r2.hsv.rgb = function(e3) {
          var t3 = e3[0] / 60, n3 = e3[1] / 100, r3 = e3[2] / 100, u3 = Math.floor(t3) % 6, o3 = t3 - Math.floor(t3), a3 = 255 * r3 * (1 - n3), i2 = 255 * r3 * (1 - n3 * o3), s2 = 255 * r3 * (1 - n3 * (1 - o3));
          switch (r3 *= 255, u3) {
            case 0:
              return [r3, s2, a3];
            case 1:
              return [i2, r3, a3];
            case 2:
              return [a3, r3, s2];
            case 3:
              return [a3, i2, r3];
            case 4:
              return [s2, a3, r3];
            case 5:
              return [r3, a3, i2];
          }
        }, r2.hsv.hsl = function(e3) {
          var t3, n3, r3, u3 = e3[0], o3 = e3[1] / 100, a3 = e3[2] / 100, i2 = Math.max(a3, 0.01);
          return r3 = (2 - o3) * a3, n3 = o3 * i2, [u3, 100 * (n3 = (n3 /= (t3 = (2 - o3) * i2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r3 /= 2)];
        }, r2.hwb.rgb = function(e3) {
          var t3, n3, r3, u3, o3, a3, i2, s2 = e3[0] / 360, l2 = e3[1] / 100, c2 = e3[2] / 100, p2 = l2 + c2;
          switch (p2 > 1 && (l2 /= p2, c2 /= p2), r3 = 6 * s2 - (t3 = Math.floor(6 * s2)), (1 & t3) != 0 && (r3 = 1 - r3), u3 = l2 + r3 * ((n3 = 1 - c2) - l2), t3) {
            default:
            case 6:
            case 0:
              o3 = n3, a3 = u3, i2 = l2;
              break;
            case 1:
              o3 = u3, a3 = n3, i2 = l2;
              break;
            case 2:
              o3 = l2, a3 = n3, i2 = u3;
              break;
            case 3:
              o3 = l2, a3 = u3, i2 = n3;
              break;
            case 4:
              o3 = u3, a3 = l2, i2 = n3;
              break;
            case 5:
              o3 = n3, a3 = l2, i2 = u3;
          }
          return [255 * o3, 255 * a3, 255 * i2];
        }, r2.cmyk.rgb = function(e3) {
          var t3 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100, u3 = e3[3] / 100;
          return [255 * (1 - Math.min(1, t3 * (1 - u3) + u3)), 255 * (1 - Math.min(1, n3 * (1 - u3) + u3)), 255 * (1 - Math.min(1, r3 * (1 - u3) + u3))];
        }, r2.xyz.rgb = function(e3) {
          var t3, n3, r3, u3 = e3[0] / 100, o3 = e3[1] / 100, a3 = e3[2] / 100;
          return n3 = -0.9689 * u3 + 1.8758 * o3 + 0.0415 * a3, r3 = 0.0557 * u3 + -0.204 * o3 + 1.057 * a3, t3 = (t3 = 3.2406 * u3 + -1.5372 * o3 + -0.4986 * a3) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (r3 = Math.min(Math.max(0, r3), 1))];
        }, r2.xyz.lab = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (t3 - n3), 200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
        }, r2.lab.xyz = function(e3) {
          var t3, n3, r3, u3 = e3[0];
          t3 = e3[1] / 500 + (n3 = (u3 + 16) / 116), r3 = n3 - e3[2] / 200;
          var o3 = Math.pow(n3, 3), a3 = Math.pow(t3, 3), i2 = Math.pow(r3, 3);
          return n3 = o3 > 8856e-6 ? o3 : (n3 - 16 / 116) / 7.787, t3 = a3 > 8856e-6 ? a3 : (t3 - 16 / 116) / 7.787, r3 = i2 > 8856e-6 ? i2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
        }, r2.lab.lch = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1], u3 = e3[2];
          return (t3 = 360 * Math.atan2(u3, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + u3 * u3), t3];
        }, r2.lch.lab = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1];
          return t3 = e3[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
        }, r2.rgb.ansi16 = function(e3) {
          var t3 = e3[0], n3 = e3[1], u3 = e3[2], o3 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e3)[2];
          if ((o3 = Math.round(o3 / 50)) === 0)
            return 30;
          var a3 = 30 + (Math.round(u3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
          return o3 === 2 && (a3 += 60), a3;
        }, r2.hsv.ansi16 = function(e3) {
          return r2.rgb.ansi16(r2.hsv.rgb(e3), e3[2]);
        }, r2.rgb.ansi256 = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
        }, r2.ansi16.rgb = function(e3) {
          var t3 = e3 % 10;
          if (t3 === 0 || t3 === 7)
            return e3 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
          var n3 = 0.5 * (1 + ~~(e3 > 50));
          return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
        }, r2.ansi256.rgb = function(e3) {
          if (e3 >= 232) {
            var t3 = 10 * (e3 - 232) + 8;
            return [t3, t3, t3];
          }
          var n3;
          return e3 -= 16, [Math.floor(e3 / 36) / 5 * 255, Math.floor((n3 = e3 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
        }, r2.rgb.hex = function(e3) {
          var t3 = (((255 & Math.round(e3[0])) << 16) + ((255 & Math.round(e3[1])) << 8) + (255 & Math.round(e3[2]))).toString(16).toUpperCase();
          return "000000".substring(t3.length) + t3;
        }, r2.hex.rgb = function(e3) {
          var t3 = e3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!t3)
            return [0, 0, 0];
          var n3 = t3[0];
          t3[0].length === 3 && (n3 = n3.split("").map(function(e4) {
            return e4 + e4;
          }).join(""));
          var r3 = parseInt(n3, 16);
          return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
        }, r2.rgb.hcg = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, u3 = e3[2] / 255, o3 = Math.max(Math.max(n3, r3), u3), a3 = Math.min(Math.min(n3, r3), u3), i2 = o3 - a3;
          return t3 = i2 <= 0 ? 0 : o3 === n3 ? (r3 - u3) / i2 % 6 : o3 === r3 ? 2 + (u3 - n3) / i2 : 4 + (n3 - r3) / i2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * i2, 100 * (i2 < 1 ? a3 / (1 - i2) : 0)];
        }, r2.hsl.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = 1, u3 = 0;
          return (r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3)) < 1 && (u3 = (n3 - 0.5 * r3) / (1 - r3)), [e3[0], 100 * r3, 100 * u3];
        }, r2.hsv.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = t3 * n3, u3 = 0;
          return r3 < 1 && (u3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * u3];
        }, r2.hcg.rgb = function(e3) {
          var t3 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
          if (n3 === 0)
            return [255 * r3, 255 * r3, 255 * r3];
          var u3, o3 = [0, 0, 0], a3 = t3 % 1 * 6, i2 = a3 % 1, s2 = 1 - i2;
          switch (Math.floor(a3)) {
            case 0:
              o3[0] = 1, o3[1] = i2, o3[2] = 0;
              break;
            case 1:
              o3[0] = s2, o3[1] = 1, o3[2] = 0;
              break;
            case 2:
              o3[0] = 0, o3[1] = 1, o3[2] = i2;
              break;
            case 3:
              o3[0] = 0, o3[1] = s2, o3[2] = 1;
              break;
            case 4:
              o3[0] = i2, o3[1] = 0, o3[2] = 1;
              break;
            default:
              o3[0] = 1, o3[1] = 0, o3[2] = s2;
          }
          return u3 = (1 - n3) * r3, [255 * (n3 * o3[0] + u3), 255 * (n3 * o3[1] + u3), 255 * (n3 * o3[2] + u3)];
        }, r2.hcg.hsv = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3), r3 = 0;
          return n3 > 0 && (r3 = t3 / n3), [e3[0], 100 * r3, 100 * n3];
        }, r2.hcg.hsl = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
          return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e3[0], 100 * r3, 100 * n3];
        }, r2.hcg.hwb = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3);
          return [e3[0], 100 * (n3 - t3), 100 * (1 - n3)];
        }, r2.hwb.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = 1 - e3[2] / 100, r3 = n3 - t3, u3 = 0;
          return r3 < 1 && (u3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * u3];
        }, r2.apple.rgb = function(e3) {
          return [e3[0] / 65535 * 255, e3[1] / 65535 * 255, e3[2] / 65535 * 255];
        }, r2.rgb.apple = function(e3) {
          return [e3[0] / 255 * 65535, e3[1] / 255 * 65535, e3[2] / 255 * 65535];
        }, r2.gray.rgb = function(e3) {
          return [e3[0] / 100 * 255, e3[0] / 100 * 255, e3[0] / 100 * 255];
        }, r2.gray.hsl = r2.gray.hsv = function(e3) {
          return [0, 0, e3[0]];
        }, r2.gray.hwb = function(e3) {
          return [0, 100, e3[0]];
        }, r2.gray.cmyk = function(e3) {
          return [0, 0, 0, e3[0]];
        }, r2.gray.lab = function(e3) {
          return [e3[0], 0, 0];
        }, r2.gray.hex = function(e3) {
          var t3 = 255 & Math.round(e3[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
          return "000000".substring(n3.length) + n3;
        }, r2.rgb.gray = function(e3) {
          return [(e3[0] + e3[1] + e3[2]) / 3 / 255 * 100];
        };
      });
      function Pr(e2) {
        var t2 = function() {
          for (var e3 = {}, t3 = Object.keys(Or), n3 = t3.length, r3 = 0; r3 < n3; r3++)
            e3[t3[r3]] = {distance: -1, parent: null};
          return e3;
        }(), n2 = [e2];
        for (t2[e2].distance = 0; n2.length; )
          for (var r2 = n2.pop(), u2 = Object.keys(Or[r2]), o2 = u2.length, a2 = 0; a2 < o2; a2++) {
            var i2 = u2[a2], s2 = t2[i2];
            s2.distance === -1 && (s2.distance = t2[r2].distance + 1, s2.parent = r2, n2.unshift(i2));
          }
        return t2;
      }
      function _r(e2, t2) {
        return function(n2) {
          return t2(e2(n2));
        };
      }
      function Ir(e2, t2) {
        for (var n2 = [t2[e2].parent, e2], r2 = Or[t2[e2].parent][e2], u2 = t2[e2].parent; t2[u2].parent; )
          n2.unshift(t2[u2].parent), r2 = _r(Or[t2[u2].parent][u2], r2), u2 = t2[u2].parent;
        return r2.conversion = n2, r2;
      }
      var jr = {};
      Object.keys(Or).forEach(function(e2) {
        jr[e2] = {}, Object.defineProperty(jr[e2], "channels", {value: Or[e2].channels}), Object.defineProperty(jr[e2], "labels", {value: Or[e2].labels});
        var t2 = function(e3) {
          for (var t3 = Pr(e3), n2 = {}, r2 = Object.keys(t3), u2 = r2.length, o2 = 0; o2 < u2; o2++) {
            var a2 = r2[o2];
            t3[a2].parent !== null && (n2[a2] = Ir(a2, t3));
          }
          return n2;
        }(e2);
        Object.keys(t2).forEach(function(n2) {
          var r2 = t2[n2];
          jr[e2][n2] = function(e3) {
            var t3 = function(t4) {
              if (t4 == null)
                return t4;
              arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
              var n3 = e3(t4);
              if (typeof n3 == "object")
                for (var r3 = n3.length, u2 = 0; u2 < r3; u2++)
                  n3[u2] = Math.round(n3[u2]);
              return n3;
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2), jr[e2][n2].raw = function(e3) {
            var t3 = function(t4) {
              return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e3(t4));
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2);
        });
      });
      var Mr = jr, Lr = $e(function(e2) {
        const t2 = (e3, t3) => function() {
          const n3 = e3.apply(Mr, arguments);
          return "[".concat(n3 + t3, "m");
        }, n2 = (e3, t3) => function() {
          const n3 = e3.apply(Mr, arguments);
          return "[".concat(38 + t3, ";5;").concat(n3, "m");
        }, r2 = (e3, t3) => function() {
          const n3 = e3.apply(Mr, arguments);
          return "[".concat(38 + t3, ";2;").concat(n3[0], ";").concat(n3[1], ";").concat(n3[2], "m");
        };
        Object.defineProperty(e2, "exports", {enumerable: true, get: function() {
          const e3 = new Map(), u2 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
          u2.color.grey = u2.color.gray;
          for (const t3 of Object.keys(u2)) {
            const n3 = u2[t3];
            for (const t4 of Object.keys(n3)) {
              const r3 = n3[t4];
              u2[t4] = {open: "[".concat(r3[0], "m"), close: "[".concat(r3[1], "m")}, n3[t4] = u2[t4], e3.set(r3[0], r3[1]);
            }
            Object.defineProperty(u2, t3, {value: n3, enumerable: false}), Object.defineProperty(u2, "codes", {value: e3, enumerable: false});
          }
          const o2 = (e4) => e4, a2 = (e4, t3, n3) => [e4, t3, n3];
          u2.color.close = "[39m", u2.bgColor.close = "[49m", u2.color.ansi = {ansi: t2(o2, 0)}, u2.color.ansi256 = {ansi256: n2(o2, 0)}, u2.color.ansi16m = {rgb: r2(a2, 0)}, u2.bgColor.ansi = {ansi: t2(o2, 10)}, u2.bgColor.ansi256 = {ansi256: n2(o2, 10)}, u2.bgColor.ansi16m = {rgb: r2(a2, 10)};
          for (let e4 of Object.keys(Mr)) {
            if (typeof Mr[e4] != "object")
              continue;
            const o3 = Mr[e4];
            e4 === "ansi16" && (e4 = "ansi"), "ansi16" in o3 && (u2.color.ansi[e4] = t2(o3.ansi16, 0), u2.bgColor.ansi[e4] = t2(o3.ansi16, 10)), "ansi256" in o3 && (u2.color.ansi256[e4] = n2(o3.ansi256, 0), u2.bgColor.ansi256[e4] = n2(o3.ansi256, 10)), "rgb" in o3 && (u2.color.ansi16m[e4] = r2(o3.rgb, 0), u2.bgColor.ansi16m[e4] = r2(o3.rgb, 10));
          }
          return u2;
        }});
      }), Rr = {EOL: "\n"}, qr = (e2, t2) => {
        t2 = t2 || Re.argv;
        const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), u2 = t2.indexOf("--");
        return r2 !== -1 && (u2 === -1 || r2 < u2);
      };
      const Vr = Re.env;
      let Wr;
      function $r(e2) {
        return function(e3) {
          return e3 !== 0 && {level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3};
        }(function(e3) {
          if (Wr === false)
            return 0;
          if (qr("color=16m") || qr("color=full") || qr("color=truecolor"))
            return 3;
          if (qr("color=256"))
            return 2;
          if (e3 && !e3.isTTY && Wr !== true)
            return 0;
          const t2 = Wr ? 1 : 0;
          if (Re.platform === "win32") {
            const e4 = Rr.release().split(".");
            return Number(Re.versions.node.split(".")[0]) >= 8 && Number(e4[0]) >= 10 && Number(e4[2]) >= 10586 ? Number(e4[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in Vr)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Vr) || Vr.CI_NAME === "codeship" ? 1 : t2;
          if ("TEAMCITY_VERSION" in Vr)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Vr.TEAMCITY_VERSION) ? 1 : 0;
          if (Vr.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in Vr) {
            const e4 = parseInt((Vr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (Vr.TERM_PROGRAM) {
              case "iTerm.app":
                return e4 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(Vr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Vr.TERM) || "COLORTERM" in Vr ? 1 : (Vr.TERM, t2);
        }(e2));
      }
      qr("no-color") || qr("no-colors") || qr("color=false") ? Wr = false : (qr("color") || qr("colors") || qr("color=true") || qr("color=always")) && (Wr = true), "FORCE_COLOR" in Vr && (Wr = Vr.FORCE_COLOR.length === 0 || parseInt(Vr.FORCE_COLOR, 10) !== 0);
      var Ur = {supportsColor: $r, stdout: $r(Re.stdout), stderr: $r(Re.stderr)};
      const zr = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Jr = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Gr = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Hr = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Xr = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function Yr(e2) {
        return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : Xr.get(e2) || e2;
      }
      function Kr(e2, t2) {
        const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
        let u2;
        for (const t3 of r2)
          if (isNaN(t3)) {
            if (!(u2 = t3.match(Gr)))
              throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e2, "')"));
            n2.push(u2[2].replace(Hr, (e3, t4, n3) => t4 ? Yr(t4) : n3));
          } else
            n2.push(Number(t3));
        return n2;
      }
      function Qr(e2) {
        Jr.lastIndex = 0;
        const t2 = [];
        let n2;
        for (; (n2 = Jr.exec(e2)) !== null; ) {
          const e3 = n2[1];
          if (n2[2]) {
            const r2 = Kr(e3, n2[2]);
            t2.push([e3].concat(r2));
          } else
            t2.push([e3]);
        }
        return t2;
      }
      function Zr(e2, t2) {
        const n2 = {};
        for (const e3 of t2)
          for (const t3 of e3.styles)
            n2[t3[0]] = e3.inverse ? null : t3.slice(1);
        let r2 = e2;
        for (const e3 of Object.keys(n2))
          if (Array.isArray(n2[e3])) {
            if (!(e3 in r2))
              throw new Error("Unknown Chalk style: ".concat(e3));
            r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
          }
        return r2;
      }
      var eu = (e2, t2) => {
        const n2 = [], r2 = [];
        let u2 = [];
        if (t2.replace(zr, (t3, o2, a2, i2, s2, l2) => {
          if (o2)
            u2.push(Yr(o2));
          else if (i2) {
            const t4 = u2.join("");
            u2 = [], r2.push(n2.length === 0 ? t4 : Zr(e2, n2)(t4)), n2.push({inverse: a2, styles: Qr(i2)});
          } else if (s2) {
            if (n2.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r2.push(Zr(e2, n2)(u2.join(""))), u2 = [], n2.pop();
          } else
            u2.push(l2);
        }), r2.push(u2.join("")), n2.length > 0) {
          const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
          throw new Error(e3);
        }
        return r2.join("");
      }, tu = $e(function(e2) {
        const t2 = Ur.stdout, n2 = Re.platform === "win32" && !(Re.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], u2 = new Set(["gray"]), o2 = Object.create(null);
        function a2(e3, n3) {
          n3 = n3 || {};
          const r3 = t2 ? t2.level : 0;
          e3.level = n3.level === void 0 ? r3 : n3.level, e3.enabled = "enabled" in n3 ? n3.enabled : e3.level > 0;
        }
        function i2(e3) {
          if (!this || !(this instanceof i2) || this.template) {
            const t3 = {};
            return a2(t3, e3), t3.template = function() {
              const e4 = [].slice.call(arguments);
              return p2.apply(null, [t3.template].concat(e4));
            }, Object.setPrototypeOf(t3, i2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = i2, t3.template;
          }
          a2(this, e3);
        }
        n2 && (Lr.blue.open = "[94m");
        for (const e3 of Object.keys(Lr))
          Lr[e3].closeRe = new RegExp(kr(Lr[e3].close), "g"), o2[e3] = {get() {
            const t3 = Lr[e3];
            return l2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
          }};
        o2.visible = {get() {
          return l2.call(this, this._styles || [], true, "visible");
        }}, Lr.color.closeRe = new RegExp(kr(Lr.color.close), "g");
        for (const e3 of Object.keys(Lr.color.ansi))
          u2.has(e3) || (o2[e3] = {get() {
            const t3 = this.level;
            return function() {
              const n3 = Lr.color[r2[t3]][e3].apply(null, arguments), u3 = {open: n3, close: Lr.color.close, closeRe: Lr.color.closeRe};
              return l2.call(this, this._styles ? this._styles.concat(u3) : [u3], this._empty, e3);
            };
          }});
        Lr.bgColor.closeRe = new RegExp(kr(Lr.bgColor.close), "g");
        for (const e3 of Object.keys(Lr.bgColor.ansi)) {
          if (u2.has(e3))
            continue;
          o2["bg" + e3[0].toUpperCase() + e3.slice(1)] = {get() {
            const t3 = this.level;
            return function() {
              const n3 = Lr.bgColor[r2[t3]][e3].apply(null, arguments), u3 = {open: n3, close: Lr.bgColor.close, closeRe: Lr.bgColor.closeRe};
              return l2.call(this, this._styles ? this._styles.concat(u3) : [u3], this._empty, e3);
            };
          }};
        }
        const s2 = Object.defineProperties(() => {
        }, o2);
        function l2(e3, t3, n3) {
          const r3 = function e4() {
            return c2.apply(e4, arguments);
          };
          r3._styles = e3, r3._empty = t3;
          const u3 = this;
          return Object.defineProperty(r3, "level", {enumerable: true, get: () => u3.level, set(e4) {
            u3.level = e4;
          }}), Object.defineProperty(r3, "enabled", {enumerable: true, get: () => u3.enabled, set(e4) {
            u3.enabled = e4;
          }}), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = s2, r3;
        }
        function c2() {
          const e3 = arguments, t3 = e3.length;
          let r3 = String(arguments[0]);
          if (t3 === 0)
            return "";
          if (t3 > 1)
            for (let n3 = 1; n3 < t3; n3++)
              r3 += " " + e3[n3];
          if (!this.enabled || this.level <= 0 || !r3)
            return this._empty ? "" : r3;
          const u3 = Lr.dim.open;
          n2 && this.hasGrey && (Lr.dim.open = "");
          for (const e4 of this._styles.slice().reverse())
            r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, "".concat(e4.close, "$&").concat(e4.open));
          return Lr.dim.open = u3, r3;
        }
        function p2(e3, t3) {
          if (!Array.isArray(t3))
            return [].slice.call(arguments, 1).join(" ");
          const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
          for (let e4 = 1; e4 < t3.length; e4++)
            r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
          return eu(e3, r3.join(""));
        }
        Object.defineProperties(i2.prototype, o2), e2.exports = i2(), e2.exports.supportsColor = t2, e2.exports.default = e2.exports;
      }), nu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.commonDeprecatedHandler = (e3, t3, {descriptor: n2}) => {
          const r2 = ["".concat(tu.default.yellow(typeof e3 == "string" ? n2.key(e3) : n2.pair(e3)), " is deprecated")];
          return t3 && r2.push("we now treat it as ".concat(tu.default.blue(typeof t3 == "string" ? n2.key(t3) : n2.pair(t3)))), r2.join("; ") + ".";
        };
      }), ru = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), wr.__exportStar(nu, t2);
      }), uu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.commonInvalidHandler = (e3, t3, n2) => ["Invalid ".concat(tu.default.red(n2.descriptor.key(e3)), " value."), "Expected ".concat(tu.default.blue(n2.schemas[e3].expected(n2)), ","), "but received ".concat(tu.default.red(n2.descriptor.value(t3)), ".")].join(" ");
      }), ou = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), wr.__exportStar(uu, t2);
      }), au = [], iu = [], su = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.levenUnknownHandler = (e3, t3, {descriptor: n2, logger: r2, schemas: u2}) => {
          const o2 = ["Ignored unknown option ".concat(tu.default.yellow(n2.pair({key: e3, value: t3})), ".")], a2 = Object.keys(u2).sort().find((t4) => function(e4, t5) {
            if (e4 === t5)
              return 0;
            var n3 = e4;
            e4.length > t5.length && (e4 = t5, t5 = n3);
            var r3 = e4.length, u3 = t5.length;
            if (r3 === 0)
              return u3;
            if (u3 === 0)
              return r3;
            for (; r3 > 0 && e4.charCodeAt(~-r3) === t5.charCodeAt(~-u3); )
              r3--, u3--;
            if (r3 === 0)
              return u3;
            for (var o3, a3, i2, s2, l2 = 0; l2 < r3 && e4.charCodeAt(l2) === t5.charCodeAt(l2); )
              l2++;
            if (u3 -= l2, (r3 -= l2) == 0)
              return u3;
            for (var c2 = 0, p2 = 0; c2 < r3; )
              iu[l2 + c2] = e4.charCodeAt(l2 + c2), au[c2] = ++c2;
            for (; p2 < u3; )
              for (o3 = t5.charCodeAt(l2 + p2), i2 = p2++, a3 = p2, c2 = 0; c2 < r3; c2++)
                s2 = o3 === iu[l2 + c2] ? i2 : i2 + 1, i2 = au[c2], a3 = au[c2] = i2 > a3 ? s2 > a3 ? a3 + 1 : s2 : s2 > i2 ? i2 + 1 : s2;
            return a3;
          }(e3, t4) < 3);
          a2 && o2.push("Did you mean ".concat(tu.default.blue(n2.key(a2)), "?")), r2.warn(o2.join(" "));
        };
      }), lu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), wr.__exportStar(su, t2);
      }), cu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), wr.__exportStar(ru, t2), wr.__exportStar(ou, t2), wr.__exportStar(lu, t2);
      }), pu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        const n2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
        function r2(e3, t3) {
          const r3 = new e3(t3), a2 = Object.create(r3);
          for (const e4 of n2)
            e4 in t3 && (a2[e4] = o2(t3[e4], r3, u2.prototype[e4].length));
          return a2;
        }
        t2.createSchema = r2;
        class u2 {
          constructor(e3) {
            this.name = e3.name;
          }
          static create(e3) {
            return r2(this, e3);
          }
          default(e3) {
          }
          expected(e3) {
            return "nothing";
          }
          validate(e3, t3) {
            return false;
          }
          deprecated(e3, t3) {
            return false;
          }
          forward(e3, t3) {
          }
          redirect(e3, t3) {
          }
          overlap(e3, t3, n3) {
            return e3;
          }
          preprocess(e3, t3) {
            return e3;
          }
          postprocess(e3, t3) {
            return e3;
          }
        }
        function o2(e3, t3, n3) {
          return typeof e3 == "function" ? (...r3) => e3(...r3.slice(0, n3 - 1), t3, ...r3.slice(n3 - 1)) : () => e3;
        }
        t2.Schema = u2;
      }), du = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends pu.Schema {
          constructor(e3) {
            super(e3), this._sourceName = e3.sourceName;
          }
          expected(e3) {
            return e3.schemas[this._sourceName].expected(e3);
          }
          validate(e3, t3) {
            return t3.schemas[this._sourceName].validate(e3, t3);
          }
          redirect(e3, t3) {
            return this._sourceName;
          }
        }
        t2.AliasSchema = n2;
      }), fu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends pu.Schema {
          expected() {
            return "anything";
          }
          validate() {
            return true;
          }
        }
        t2.AnySchema = n2;
      }), hu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends pu.Schema {
          constructor(e3) {
            var {valueSchema: t3, name: n3 = t3.name} = e3, r3 = wr.__rest(e3, ["valueSchema", "name"]);
            super(Object.assign({}, r3, {name: n3})), this._valueSchema = t3;
          }
          expected(e3) {
            return "an array of ".concat(this._valueSchema.expected(e3));
          }
          validate(e3, t3) {
            if (!Array.isArray(e3))
              return false;
            const n3 = [];
            for (const r3 of e3) {
              const e4 = t3.normalizeValidateResult(this._valueSchema.validate(r3, t3), r3);
              e4 !== true && n3.push(e4.value);
            }
            return n3.length === 0 || {value: n3};
          }
          deprecated(e3, t3) {
            const n3 = [];
            for (const r3 of e3) {
              const e4 = t3.normalizeDeprecatedResult(this._valueSchema.deprecated(r3, t3), r3);
              e4 !== false && n3.push(...e4.map(({value: e5}) => ({value: [e5]})));
            }
            return n3;
          }
          forward(e3, t3) {
            const n3 = [];
            for (const u2 of e3) {
              const e4 = t3.normalizeForwardResult(this._valueSchema.forward(u2, t3), u2);
              n3.push(...e4.map(r2));
            }
            return n3;
          }
          redirect(e3, t3) {
            const n3 = [], u2 = [];
            for (const o2 of e3) {
              const e4 = t3.normalizeRedirectResult(this._valueSchema.redirect(o2, t3), o2);
              "remain" in e4 && n3.push(e4.remain), u2.push(...e4.redirect.map(r2));
            }
            return n3.length === 0 ? {redirect: u2} : {redirect: u2, remain: n3};
          }
          overlap(e3, t3) {
            return e3.concat(t3);
          }
        }
        function r2({from: e3, to: t3}) {
          return {from: [e3], to: t3};
        }
        t2.ArraySchema = n2;
      }), mu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends pu.Schema {
          expected() {
            return "true or false";
          }
          validate(e3) {
            return typeof e3 == "boolean";
          }
        }
        t2.BooleanSchema = n2;
      }), gu = $e(function(e2, t2) {
        function n2(e3, t3) {
          return typeof e3 == "string" || "key" in e3 ? {from: t3, to: e3} : "from" in e3 ? {from: e3.from, to: e3.to} : {from: t3, to: e3.to};
        }
        function r2(e3, t3) {
          return e3 === void 0 ? [] : Array.isArray(e3) ? e3.map((e4) => n2(e4, t3)) : [n2(e3, t3)];
        }
        Object.defineProperty(t2, "__esModule", {value: true}), t2.recordFromArray = function(e3, t3) {
          const n3 = Object.create(null);
          for (const r3 of e3) {
            const e4 = r3[t3];
            if (n3[e4])
              throw new Error("Duplicate ".concat(t3, " ").concat(JSON.stringify(e4)));
            n3[e4] = r3;
          }
          return n3;
        }, t2.mapFromArray = function(e3, t3) {
          const n3 = new Map();
          for (const r3 of e3) {
            const e4 = r3[t3];
            if (n3.has(e4))
              throw new Error("Duplicate ".concat(t3, " ").concat(JSON.stringify(e4)));
            n3.set(e4, r3);
          }
          return n3;
        }, t2.createAutoChecklist = function() {
          const e3 = Object.create(null);
          return (t3) => {
            const n3 = JSON.stringify(t3);
            return !!e3[n3] || (e3[n3] = true, false);
          };
        }, t2.partition = function(e3, t3) {
          const n3 = [], r3 = [];
          for (const u2 of e3)
            t3(u2) ? n3.push(u2) : r3.push(u2);
          return [n3, r3];
        }, t2.isInt = function(e3) {
          return e3 === Math.floor(e3);
        }, t2.comparePrimitive = function(e3, t3) {
          if (e3 === t3)
            return 0;
          const n3 = typeof e3, r3 = typeof t3, u2 = ["undefined", "object", "boolean", "number", "string"];
          return n3 !== r3 ? u2.indexOf(n3) - u2.indexOf(r3) : n3 !== "string" ? Number(e3) - Number(t3) : e3.localeCompare(t3);
        }, t2.normalizeDefaultResult = function(e3) {
          return e3 === void 0 ? {} : e3;
        }, t2.normalizeValidateResult = function(e3, t3) {
          return e3 === true || (e3 === false ? {value: t3} : e3);
        }, t2.normalizeDeprecatedResult = function(e3, t3, n3 = false) {
          return e3 !== false && (e3 === true ? !!n3 || [{value: t3}] : "value" in e3 ? [e3] : e3.length !== 0 && e3);
        }, t2.normalizeTransferResult = n2, t2.normalizeForwardResult = r2, t2.normalizeRedirectResult = function(e3, t3) {
          const n3 = r2(typeof e3 == "object" && "redirect" in e3 ? e3.redirect : e3, t3);
          return n3.length === 0 ? {remain: t3, redirect: n3} : typeof e3 == "object" && "remain" in e3 ? {remain: e3.remain, redirect: n3} : {redirect: n3};
        };
      }), Du = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends pu.Schema {
          constructor(e3) {
            super(e3), this._choices = gu.mapFromArray(e3.choices.map((e4) => e4 && typeof e4 == "object" ? e4 : {value: e4}), "value");
          }
          expected({descriptor: e3}) {
            const t3 = Array.from(this._choices.keys()).map((e4) => this._choices.get(e4)).filter((e4) => !e4.deprecated).map((e4) => e4.value).sort(gu.comparePrimitive).map(e3.value), n3 = t3.slice(0, -2), r2 = t3.slice(-2);
            return n3.concat(r2.join(" or ")).join(", ");
          }
          validate(e3) {
            return this._choices.has(e3);
          }
          deprecated(e3) {
            const t3 = this._choices.get(e3);
            return !(!t3 || !t3.deprecated) && {value: e3};
          }
          forward(e3) {
            const t3 = this._choices.get(e3);
            return t3 ? t3.forward : void 0;
          }
          redirect(e3) {
            const t3 = this._choices.get(e3);
            return t3 ? t3.redirect : void 0;
          }
        }
        t2.ChoiceSchema = n2;
      }), yu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends pu.Schema {
          expected() {
            return "a number";
          }
          validate(e3, t3) {
            return typeof e3 == "number";
          }
        }
        t2.NumberSchema = n2;
      }), Eu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends yu.NumberSchema {
          expected() {
            return "an integer";
          }
          validate(e3, t3) {
            return t3.normalizeValidateResult(super.validate(e3, t3), e3) === true && gu.isInt(e3);
          }
        }
        t2.IntegerSchema = n2;
      }), Cu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true});
        class n2 extends pu.Schema {
          expected() {
            return "a string";
          }
          validate(e3) {
            return typeof e3 == "string";
          }
        }
        t2.StringSchema = n2;
      }), bu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), wr.__exportStar(du, t2), wr.__exportStar(fu, t2), wr.__exportStar(hu, t2), wr.__exportStar(mu, t2), wr.__exportStar(Du, t2), wr.__exportStar(Eu, t2), wr.__exportStar(yu, t2), wr.__exportStar(Cu, t2);
      }), Au = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.defaultDescriptor = Sr.apiDescriptor, t2.defaultUnknownHandler = su.levenUnknownHandler, t2.defaultInvalidHandler = ou.commonInvalidHandler, t2.defaultDeprecatedHandler = nu.commonDeprecatedHandler;
      }), vu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.normalize = (e3, t3, r2) => new n2(t3, r2).normalize(e3);
        class n2 {
          constructor(e3, t3) {
            const {logger: n3 = console, descriptor: r2 = Au.defaultDescriptor, unknown: u2 = Au.defaultUnknownHandler, invalid: o2 = Au.defaultInvalidHandler, deprecated: a2 = Au.defaultDeprecatedHandler} = t3 || {};
            this._utils = {descriptor: r2, logger: n3 || {warn: () => {
            }}, schemas: gu.recordFromArray(e3, "name"), normalizeDefaultResult: gu.normalizeDefaultResult, normalizeDeprecatedResult: gu.normalizeDeprecatedResult, normalizeForwardResult: gu.normalizeForwardResult, normalizeRedirectResult: gu.normalizeRedirectResult, normalizeValidateResult: gu.normalizeValidateResult}, this._unknownHandler = u2, this._invalidHandler = o2, this._deprecatedHandler = a2, this.cleanHistory();
          }
          cleanHistory() {
            this._hasDeprecationWarned = gu.createAutoChecklist();
          }
          normalize(e3) {
            const t3 = {}, n3 = [e3], r2 = () => {
              for (; n3.length !== 0; ) {
                const e4 = n3.shift(), r3 = this._applyNormalization(e4, t3);
                n3.push(...r3);
              }
            };
            r2();
            for (const e4 of Object.keys(this._utils.schemas)) {
              const r3 = this._utils.schemas[e4];
              if (!(e4 in t3)) {
                const t4 = gu.normalizeDefaultResult(r3.default(this._utils));
                "value" in t4 && n3.push({[e4]: t4.value});
              }
            }
            r2();
            for (const e4 of Object.keys(this._utils.schemas)) {
              const n4 = this._utils.schemas[e4];
              e4 in t3 && (t3[e4] = n4.postprocess(t3[e4], this._utils));
            }
            return t3;
          }
          _applyNormalization(e3, t3) {
            const n3 = [], [r2, u2] = gu.partition(Object.keys(e3), (e4) => e4 in this._utils.schemas);
            for (const u3 of r2) {
              const r3 = this._utils.schemas[u3], o2 = r3.preprocess(e3[u3], this._utils), a2 = gu.normalizeValidateResult(r3.validate(o2, this._utils), o2);
              if (a2 !== true) {
                const {value: e4} = a2, t4 = this._invalidHandler(u3, e4, this._utils);
                throw typeof t4 == "string" ? new Error(t4) : t4;
              }
              const i2 = ({from: e4, to: t4}) => {
                n3.push(typeof t4 == "string" ? {[t4]: e4} : {[t4.key]: t4.value});
              }, s2 = ({value: e4, redirectTo: t4}) => {
                const n4 = gu.normalizeDeprecatedResult(r3.deprecated(e4, this._utils), o2, true);
                if (n4 !== false)
                  if (n4 === true)
                    this._hasDeprecationWarned(u3) || this._utils.logger.warn(this._deprecatedHandler(u3, t4, this._utils));
                  else
                    for (const {value: e5} of n4) {
                      const n5 = {key: u3, value: e5};
                      if (!this._hasDeprecationWarned(n5)) {
                        const r4 = typeof t4 == "string" ? {key: t4, value: e5} : t4;
                        this._utils.logger.warn(this._deprecatedHandler(n5, r4, this._utils));
                      }
                    }
              };
              gu.normalizeForwardResult(r3.forward(o2, this._utils), o2).forEach(i2);
              const l2 = gu.normalizeRedirectResult(r3.redirect(o2, this._utils), o2);
              if (l2.redirect.forEach(i2), "remain" in l2) {
                const e4 = l2.remain;
                t3[u3] = u3 in t3 ? r3.overlap(t3[u3], e4, this._utils) : e4, s2({value: e4});
              }
              for (const {from: e4, to: t4} of l2.redirect)
                s2({value: e4, redirectTo: t4});
            }
            for (const r3 of u2) {
              const u3 = e3[r3], o2 = this._unknownHandler(r3, u3, this._utils);
              if (o2)
                for (const e4 of Object.keys(o2)) {
                  const r4 = {[e4]: o2[e4]};
                  e4 in this._utils.schemas ? n3.push(r4) : Object.assign(t3, r4);
                }
            }
            return n3;
          }
        }
        t2.Normalizer = n2;
      }), Fu = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), wr.__exportStar(Br, t2), wr.__exportStar(cu, t2), wr.__exportStar(bu, t2), wr.__exportStar(vu, t2), wr.__exportStar(pu, t2);
      });
      const xu = [], Su = [], wu = (e2, t2) => {
        if (e2 === t2)
          return 0;
        const n2 = e2;
        e2.length > t2.length && (e2 = t2, t2 = n2);
        let r2 = e2.length, u2 = t2.length;
        for (; r2 > 0 && e2.charCodeAt(~-r2) === t2.charCodeAt(~-u2); )
          r2--, u2--;
        let o2, a2, i2, s2, l2 = 0;
        for (; l2 < r2 && e2.charCodeAt(l2) === t2.charCodeAt(l2); )
          l2++;
        if (r2 -= l2, u2 -= l2, r2 === 0)
          return u2;
        let c2 = 0, p2 = 0;
        for (; c2 < r2; )
          Su[c2] = e2.charCodeAt(l2 + c2), xu[c2] = ++c2;
        for (; p2 < u2; )
          for (o2 = t2.charCodeAt(l2 + p2), i2 = p2++, a2 = p2, c2 = 0; c2 < r2; c2++)
            s2 = o2 === Su[c2] ? i2 : i2 + 1, i2 = xu[c2], a2 = xu[c2] = i2 > a2 ? s2 > a2 ? a2 + 1 : s2 : s2 > i2 ? i2 + 1 : s2;
        return a2;
      };
      var Bu = wu, Tu = wu;
      Bu.default = Tu;
      var ku = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50]};
      const Nu = {};
      for (const e2 of Object.keys(ku))
        Nu[ku[e2]] = e2;
      const Ou = {rgb: {channels: 3, labels: "rgb"}, hsl: {channels: 3, labels: "hsl"}, hsv: {channels: 3, labels: "hsv"}, hwb: {channels: 3, labels: "hwb"}, cmyk: {channels: 4, labels: "cmyk"}, xyz: {channels: 3, labels: "xyz"}, lab: {channels: 3, labels: "lab"}, lch: {channels: 3, labels: "lch"}, hex: {channels: 1, labels: ["hex"]}, keyword: {channels: 1, labels: ["keyword"]}, ansi16: {channels: 1, labels: ["ansi16"]}, ansi256: {channels: 1, labels: ["ansi256"]}, hcg: {channels: 3, labels: ["h", "c", "g"]}, apple: {channels: 3, labels: ["r16", "g16", "b16"]}, gray: {channels: 1, labels: ["gray"]}};
      var Pu = Ou;
      for (const e2 of Object.keys(Ou)) {
        if (!("channels" in Ou[e2]))
          throw new Error("missing channels property: " + e2);
        if (!("labels" in Ou[e2]))
          throw new Error("missing channel labels property: " + e2);
        if (Ou[e2].labels.length !== Ou[e2].channels)
          throw new Error("channel and label counts mismatch: " + e2);
        const {channels: t2, labels: n2} = Ou[e2];
        delete Ou[e2].channels, delete Ou[e2].labels, Object.defineProperty(Ou[e2], "channels", {value: t2}), Object.defineProperty(Ou[e2], "labels", {value: n2});
      }
      function _u(e2) {
        const t2 = function() {
          const e3 = {}, t3 = Object.keys(Pu);
          for (let n3 = t3.length, r2 = 0; r2 < n3; r2++)
            e3[t3[r2]] = {distance: -1, parent: null};
          return e3;
        }(), n2 = [e2];
        for (t2[e2].distance = 0; n2.length; ) {
          const e3 = n2.pop(), r2 = Object.keys(Pu[e3]);
          for (let u2 = r2.length, o2 = 0; o2 < u2; o2++) {
            const u3 = r2[o2], a2 = t2[u3];
            a2.distance === -1 && (a2.distance = t2[e3].distance + 1, a2.parent = e3, n2.unshift(u3));
          }
        }
        return t2;
      }
      function Iu(e2, t2) {
        return function(n2) {
          return t2(e2(n2));
        };
      }
      function ju(e2, t2) {
        const n2 = [t2[e2].parent, e2];
        let r2 = Pu[t2[e2].parent][e2], u2 = t2[e2].parent;
        for (; t2[u2].parent; )
          n2.unshift(t2[u2].parent), r2 = Iu(Pu[t2[u2].parent][u2], r2), u2 = t2[u2].parent;
        return r2.conversion = n2, r2;
      }
      Ou.rgb.hsl = function(e2) {
        const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, u2 = Math.min(t2, n2, r2), o2 = Math.max(t2, n2, r2), a2 = o2 - u2;
        let i2, s2;
        o2 === u2 ? i2 = 0 : t2 === o2 ? i2 = (n2 - r2) / a2 : n2 === o2 ? i2 = 2 + (r2 - t2) / a2 : r2 === o2 && (i2 = 4 + (t2 - n2) / a2), i2 = Math.min(60 * i2, 360), i2 < 0 && (i2 += 360);
        const l2 = (u2 + o2) / 2;
        return s2 = o2 === u2 ? 0 : l2 <= 0.5 ? a2 / (o2 + u2) : a2 / (2 - o2 - u2), [i2, 100 * s2, 100 * l2];
      }, Ou.rgb.hsv = function(e2) {
        let t2, n2, r2, u2, o2;
        const a2 = e2[0] / 255, i2 = e2[1] / 255, s2 = e2[2] / 255, l2 = Math.max(a2, i2, s2), c2 = l2 - Math.min(a2, i2, s2), p2 = function(e3) {
          return (l2 - e3) / 6 / c2 + 0.5;
        };
        return c2 === 0 ? (u2 = 0, o2 = 0) : (o2 = c2 / l2, t2 = p2(a2), n2 = p2(i2), r2 = p2(s2), a2 === l2 ? u2 = r2 - n2 : i2 === l2 ? u2 = 1 / 3 + t2 - r2 : s2 === l2 && (u2 = 2 / 3 + n2 - t2), u2 < 0 ? u2 += 1 : u2 > 1 && (u2 -= 1)), [360 * u2, 100 * o2, 100 * l2];
      }, Ou.rgb.hwb = function(e2) {
        const t2 = e2[0], n2 = e2[1];
        let r2 = e2[2];
        const u2 = Ou.rgb.hsl(e2)[0], o2 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
        return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [u2, 100 * o2, 100 * r2];
      }, Ou.rgb.cmyk = function(e2) {
        const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, u2 = Math.min(1 - t2, 1 - n2, 1 - r2);
        return [100 * ((1 - t2 - u2) / (1 - u2) || 0), 100 * ((1 - n2 - u2) / (1 - u2) || 0), 100 * ((1 - r2 - u2) / (1 - u2) || 0), 100 * u2];
      }, Ou.rgb.keyword = function(e2) {
        const t2 = Nu[e2];
        if (t2)
          return t2;
        let n2, r2 = 1 / 0;
        for (const t3 of Object.keys(ku)) {
          const a2 = (o2 = ku[t3], ((u2 = e2)[0] - o2[0]) ** 2 + (u2[1] - o2[1]) ** 2 + (u2[2] - o2[2]) ** 2);
          a2 < r2 && (r2 = a2, n2 = t3);
        }
        var u2, o2;
        return n2;
      }, Ou.keyword.rgb = function(e2) {
        return ku[e2];
      }, Ou.rgb.xyz = function(e2) {
        let t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255;
        t2 = t2 > 0.04045 ? ((t2 + 0.055) / 1.055) ** 2.4 : t2 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
        return [100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2), 100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)];
      }, Ou.rgb.lab = function(e2) {
        const t2 = Ou.rgb.xyz(e2);
        let n2 = t2[0], r2 = t2[1], u2 = t2[2];
        n2 /= 95.047, r2 /= 100, u2 /= 108.883, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, u2 = u2 > 8856e-6 ? u2 ** (1 / 3) : 7.787 * u2 + 16 / 116;
        return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - u2)];
      }, Ou.hsl.rgb = function(e2) {
        const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
        let u2, o2, a2;
        if (n2 === 0)
          return a2 = 255 * r2, [a2, a2, a2];
        u2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
        const i2 = 2 * r2 - u2, s2 = [0, 0, 0];
        for (let e3 = 0; e3 < 3; e3++)
          o2 = t2 + 1 / 3 * -(e3 - 1), o2 < 0 && o2++, o2 > 1 && o2--, a2 = 6 * o2 < 1 ? i2 + 6 * (u2 - i2) * o2 : 2 * o2 < 1 ? u2 : 3 * o2 < 2 ? i2 + (u2 - i2) * (2 / 3 - o2) * 6 : i2, s2[e3] = 255 * a2;
        return s2;
      }, Ou.hsl.hsv = function(e2) {
        const t2 = e2[0];
        let n2 = e2[1] / 100, r2 = e2[2] / 100, u2 = n2;
        const o2 = Math.max(r2, 0.01);
        r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, u2 *= o2 <= 1 ? o2 : 2 - o2;
        return [t2, 100 * (r2 === 0 ? 2 * u2 / (o2 + u2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
      }, Ou.hsv.rgb = function(e2) {
        const t2 = e2[0] / 60, n2 = e2[1] / 100;
        let r2 = e2[2] / 100;
        const u2 = Math.floor(t2) % 6, o2 = t2 - Math.floor(t2), a2 = 255 * r2 * (1 - n2), i2 = 255 * r2 * (1 - n2 * o2), s2 = 255 * r2 * (1 - n2 * (1 - o2));
        switch (r2 *= 255, u2) {
          case 0:
            return [r2, s2, a2];
          case 1:
            return [i2, r2, a2];
          case 2:
            return [a2, r2, s2];
          case 3:
            return [a2, i2, r2];
          case 4:
            return [s2, a2, r2];
          case 5:
            return [r2, a2, i2];
        }
      }, Ou.hsv.hsl = function(e2) {
        const t2 = e2[0], n2 = e2[1] / 100, r2 = e2[2] / 100, u2 = Math.max(r2, 0.01);
        let o2, a2;
        a2 = (2 - n2) * r2;
        const i2 = (2 - n2) * u2;
        return o2 = n2 * u2, o2 /= i2 <= 1 ? i2 : 2 - i2, o2 = o2 || 0, a2 /= 2, [t2, 100 * o2, 100 * a2];
      }, Ou.hwb.rgb = function(e2) {
        const t2 = e2[0] / 360;
        let n2 = e2[1] / 100, r2 = e2[2] / 100;
        const u2 = n2 + r2;
        let o2;
        u2 > 1 && (n2 /= u2, r2 /= u2);
        const a2 = Math.floor(6 * t2), i2 = 1 - r2;
        o2 = 6 * t2 - a2, (1 & a2) != 0 && (o2 = 1 - o2);
        const s2 = n2 + o2 * (i2 - n2);
        let l2, c2, p2;
        switch (a2) {
          default:
          case 6:
          case 0:
            l2 = i2, c2 = s2, p2 = n2;
            break;
          case 1:
            l2 = s2, c2 = i2, p2 = n2;
            break;
          case 2:
            l2 = n2, c2 = i2, p2 = s2;
            break;
          case 3:
            l2 = n2, c2 = s2, p2 = i2;
            break;
          case 4:
            l2 = s2, c2 = n2, p2 = i2;
            break;
          case 5:
            l2 = i2, c2 = n2, p2 = s2;
        }
        return [255 * l2, 255 * c2, 255 * p2];
      }, Ou.cmyk.rgb = function(e2) {
        const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100, u2 = e2[3] / 100;
        return [255 * (1 - Math.min(1, t2 * (1 - u2) + u2)), 255 * (1 - Math.min(1, n2 * (1 - u2) + u2)), 255 * (1 - Math.min(1, r2 * (1 - u2) + u2))];
      }, Ou.xyz.rgb = function(e2) {
        const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100;
        let u2, o2, a2;
        return u2 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, o2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, a2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, u2 = u2 > 31308e-7 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, o2 = o2 > 31308e-7 ? 1.055 * o2 ** (1 / 2.4) - 0.055 : 12.92 * o2, a2 = a2 > 31308e-7 ? 1.055 * a2 ** (1 / 2.4) - 0.055 : 12.92 * a2, u2 = Math.min(Math.max(0, u2), 1), o2 = Math.min(Math.max(0, o2), 1), a2 = Math.min(Math.max(0, a2), 1), [255 * u2, 255 * o2, 255 * a2];
      }, Ou.xyz.lab = function(e2) {
        let t2 = e2[0], n2 = e2[1], r2 = e2[2];
        t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 8856e-6 ? t2 ** (1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
        return [116 * n2 - 16, 500 * (t2 - n2), 200 * (n2 - r2)];
      }, Ou.lab.xyz = function(e2) {
        let t2, n2, r2;
        n2 = (e2[0] + 16) / 116, t2 = e2[1] / 500 + n2, r2 = n2 - e2[2] / 200;
        const u2 = n2 ** 3, o2 = t2 ** 3, a2 = r2 ** 3;
        return n2 = u2 > 8856e-6 ? u2 : (n2 - 16 / 116) / 7.787, t2 = o2 > 8856e-6 ? o2 : (t2 - 16 / 116) / 7.787, r2 = a2 > 8856e-6 ? a2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [t2, n2, r2];
      }, Ou.lab.lch = function(e2) {
        const t2 = e2[0], n2 = e2[1], r2 = e2[2];
        let u2;
        u2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, u2 < 0 && (u2 += 360);
        return [t2, Math.sqrt(n2 * n2 + r2 * r2), u2];
      }, Ou.lch.lab = function(e2) {
        const t2 = e2[0], n2 = e2[1], r2 = e2[2] / 360 * 2 * Math.PI;
        return [t2, n2 * Math.cos(r2), n2 * Math.sin(r2)];
      }, Ou.rgb.ansi16 = function(e2, t2 = null) {
        const [n2, r2, u2] = e2;
        let o2 = t2 === null ? Ou.rgb.hsv(e2)[2] : t2;
        if (o2 = Math.round(o2 / 50), o2 === 0)
          return 30;
        let a2 = 30 + (Math.round(u2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
        return o2 === 2 && (a2 += 60), a2;
      }, Ou.hsv.ansi16 = function(e2) {
        return Ou.rgb.ansi16(Ou.hsv.rgb(e2), e2[2]);
      }, Ou.rgb.ansi256 = function(e2) {
        const t2 = e2[0], n2 = e2[1], r2 = e2[2];
        if (t2 === n2 && n2 === r2)
          return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
      }, Ou.ansi16.rgb = function(e2) {
        let t2 = e2 % 10;
        if (t2 === 0 || t2 === 7)
          return e2 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
        const n2 = 0.5 * (1 + ~~(e2 > 50));
        return [(1 & t2) * n2 * 255, (t2 >> 1 & 1) * n2 * 255, (t2 >> 2 & 1) * n2 * 255];
      }, Ou.ansi256.rgb = function(e2) {
        if (e2 >= 232) {
          const t3 = 10 * (e2 - 232) + 8;
          return [t3, t3, t3];
        }
        let t2;
        e2 -= 16;
        return [Math.floor(e2 / 36) / 5 * 255, Math.floor((t2 = e2 % 36) / 6) / 5 * 255, t2 % 6 / 5 * 255];
      }, Ou.rgb.hex = function(e2) {
        const t2 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
        return "000000".substring(t2.length) + t2;
      }, Ou.hex.rgb = function(e2) {
        const t2 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t2)
          return [0, 0, 0];
        let n2 = t2[0];
        t2[0].length === 3 && (n2 = n2.split("").map((e3) => e3 + e3).join(""));
        const r2 = parseInt(n2, 16);
        return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
      }, Ou.rgb.hcg = function(e2) {
        const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, u2 = Math.max(Math.max(t2, n2), r2), o2 = Math.min(Math.min(t2, n2), r2), a2 = u2 - o2;
        let i2, s2;
        return i2 = a2 < 1 ? o2 / (1 - a2) : 0, s2 = a2 <= 0 ? 0 : u2 === t2 ? (n2 - r2) / a2 % 6 : u2 === n2 ? 2 + (r2 - t2) / a2 : 4 + (t2 - n2) / a2, s2 /= 6, s2 %= 1, [360 * s2, 100 * a2, 100 * i2];
      }, Ou.hsl.hcg = function(e2) {
        const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
        let u2 = 0;
        return r2 < 1 && (u2 = (n2 - 0.5 * r2) / (1 - r2)), [e2[0], 100 * r2, 100 * u2];
      }, Ou.hsv.hcg = function(e2) {
        const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = t2 * n2;
        let u2 = 0;
        return r2 < 1 && (u2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * u2];
      }, Ou.hcg.rgb = function(e2) {
        const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
        if (n2 === 0)
          return [255 * r2, 255 * r2, 255 * r2];
        const u2 = [0, 0, 0], o2 = t2 % 1 * 6, a2 = o2 % 1, i2 = 1 - a2;
        let s2 = 0;
        switch (Math.floor(o2)) {
          case 0:
            u2[0] = 1, u2[1] = a2, u2[2] = 0;
            break;
          case 1:
            u2[0] = i2, u2[1] = 1, u2[2] = 0;
            break;
          case 2:
            u2[0] = 0, u2[1] = 1, u2[2] = a2;
            break;
          case 3:
            u2[0] = 0, u2[1] = i2, u2[2] = 1;
            break;
          case 4:
            u2[0] = a2, u2[1] = 0, u2[2] = 1;
            break;
          default:
            u2[0] = 1, u2[1] = 0, u2[2] = i2;
        }
        return s2 = (1 - n2) * r2, [255 * (n2 * u2[0] + s2), 255 * (n2 * u2[1] + s2), 255 * (n2 * u2[2] + s2)];
      }, Ou.hcg.hsv = function(e2) {
        const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
        let r2 = 0;
        return n2 > 0 && (r2 = t2 / n2), [e2[0], 100 * r2, 100 * n2];
      }, Ou.hcg.hsl = function(e2) {
        const t2 = e2[1] / 100, n2 = e2[2] / 100 * (1 - t2) + 0.5 * t2;
        let r2 = 0;
        return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e2[0], 100 * r2, 100 * n2];
      }, Ou.hcg.hwb = function(e2) {
        const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
        return [e2[0], 100 * (n2 - t2), 100 * (1 - n2)];
      }, Ou.hwb.hcg = function(e2) {
        const t2 = e2[1] / 100, n2 = 1 - e2[2] / 100, r2 = n2 - t2;
        let u2 = 0;
        return r2 < 1 && (u2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * u2];
      }, Ou.apple.rgb = function(e2) {
        return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
      }, Ou.rgb.apple = function(e2) {
        return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
      }, Ou.gray.rgb = function(e2) {
        return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
      }, Ou.gray.hsl = function(e2) {
        return [0, 0, e2[0]];
      }, Ou.gray.hsv = Ou.gray.hsl, Ou.gray.hwb = function(e2) {
        return [0, 100, e2[0]];
      }, Ou.gray.cmyk = function(e2) {
        return [0, 0, 0, e2[0]];
      }, Ou.gray.lab = function(e2) {
        return [e2[0], 0, 0];
      }, Ou.gray.hex = function(e2) {
        const t2 = 255 & Math.round(e2[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
        return "000000".substring(n2.length) + n2;
      }, Ou.rgb.gray = function(e2) {
        return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
      };
      const Mu = {};
      Object.keys(Pu).forEach((e2) => {
        Mu[e2] = {}, Object.defineProperty(Mu[e2], "channels", {value: Pu[e2].channels}), Object.defineProperty(Mu[e2], "labels", {value: Pu[e2].labels});
        const t2 = function(e3) {
          const t3 = _u(e3), n2 = {}, r2 = Object.keys(t3);
          for (let e4 = r2.length, u2 = 0; u2 < e4; u2++) {
            const e5 = r2[u2];
            t3[e5].parent !== null && (n2[e5] = ju(e5, t3));
          }
          return n2;
        }(e2);
        Object.keys(t2).forEach((n2) => {
          const r2 = t2[n2];
          Mu[e2][n2] = function(e3) {
            const t3 = function(...t4) {
              const n3 = t4[0];
              if (n3 == null)
                return n3;
              n3.length > 1 && (t4 = n3);
              const r3 = e3(t4);
              if (typeof r3 == "object")
                for (let e4 = r3.length, t5 = 0; t5 < e4; t5++)
                  r3[t5] = Math.round(r3[t5]);
              return r3;
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2), Mu[e2][n2].raw = function(e3) {
            const t3 = function(...t4) {
              const n3 = t4[0];
              return n3 == null ? n3 : (n3.length > 1 && (t4 = n3), e3(t4));
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2);
        });
      });
      var Lu = Mu, Ru = $e(function(e2) {
        const t2 = (e3, t3) => (...n3) => {
          const r3 = e3(...n3);
          return "[".concat(r3 + t3, "m");
        }, n2 = (e3, t3) => (...n3) => {
          const r3 = e3(...n3);
          return "[".concat(38 + t3, ";5;").concat(r3, "m");
        }, r2 = (e3, t3) => (...n3) => {
          const r3 = e3(...n3);
          return "[".concat(38 + t3, ";2;").concat(r3[0], ";").concat(r3[1], ";").concat(r3[2], "m");
        }, u2 = (e3) => e3, o2 = (e3, t3, n3) => [e3, t3, n3], a2 = (e3, t3, n3) => {
          Object.defineProperty(e3, t3, {get: () => {
            const r3 = n3();
            return Object.defineProperty(e3, t3, {value: r3, enumerable: true, configurable: true}), r3;
          }, enumerable: true, configurable: true});
        };
        let i2;
        const s2 = (e3, t3, n3, r3) => {
          i2 === void 0 && (i2 = Lu);
          const u3 = r3 ? 10 : 0, o3 = {};
          for (const [r4, a3] of Object.entries(i2)) {
            const i3 = r4 === "ansi16" ? "ansi" : r4;
            r4 === t3 ? o3[i3] = e3(n3, u3) : typeof a3 == "object" && (o3[i3] = e3(a3[t3], u3));
          }
          return o3;
        };
        Object.defineProperty(e2, "exports", {enumerable: true, get: function() {
          const e3 = new Map(), i3 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
          i3.color.gray = i3.color.blackBright, i3.bgColor.bgGray = i3.bgColor.bgBlackBright, i3.color.grey = i3.color.blackBright, i3.bgColor.bgGrey = i3.bgColor.bgBlackBright;
          for (const [t3, n3] of Object.entries(i3)) {
            for (const [t4, r3] of Object.entries(n3))
              i3[t4] = {open: "[".concat(r3[0], "m"), close: "[".concat(r3[1], "m")}, n3[t4] = i3[t4], e3.set(r3[0], r3[1]);
            Object.defineProperty(i3, t3, {value: n3, enumerable: false});
          }
          return Object.defineProperty(i3, "codes", {value: e3, enumerable: false}), i3.color.close = "[39m", i3.bgColor.close = "[49m", a2(i3.color, "ansi", () => s2(t2, "ansi16", u2, false)), a2(i3.color, "ansi256", () => s2(n2, "ansi256", u2, false)), a2(i3.color, "ansi16m", () => s2(r2, "rgb", o2, false)), a2(i3.bgColor, "ansi", () => s2(t2, "ansi16", u2, true)), a2(i3.bgColor, "ansi256", () => s2(n2, "ansi256", u2, true)), a2(i3.bgColor, "ansi16m", () => s2(r2, "rgb", o2, true)), i3;
        }});
      }), qu = {isatty: () => false}, Vu = (e2, t2 = Re.argv) => {
        const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), u2 = t2.indexOf("--");
        return r2 !== -1 && (u2 === -1 || r2 < u2);
      };
      const {env: Wu} = Re;
      let $u;
      function Uu(e2) {
        return e2 !== 0 && {level: e2, hasBasic: true, has256: e2 >= 2, has16m: e2 >= 3};
      }
      function zu(e2, t2) {
        if ($u === 0)
          return 0;
        if (Vu("color=16m") || Vu("color=full") || Vu("color=truecolor"))
          return 3;
        if (Vu("color=256"))
          return 2;
        if (e2 && !t2 && $u === void 0)
          return 0;
        const n2 = $u || 0;
        if (Wu.TERM === "dumb")
          return n2;
        if (Re.platform === "win32") {
          const e3 = Rr.release().split(".");
          return Number(e3[0]) >= 10 && Number(e3[2]) >= 10586 ? Number(e3[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in Wu)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e3) => e3 in Wu) || Wu.CI_NAME === "codeship" ? 1 : n2;
        if ("TEAMCITY_VERSION" in Wu)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Wu.TEAMCITY_VERSION) ? 1 : 0;
        if ("GITHUB_ACTIONS" in Wu)
          return 1;
        if (Wu.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in Wu) {
          const e3 = parseInt((Wu.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (Wu.TERM_PROGRAM) {
            case "iTerm.app":
              return e3 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(Wu.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Wu.TERM) || "COLORTERM" in Wu ? 1 : n2;
      }
      Vu("no-color") || Vu("no-colors") || Vu("color=false") || Vu("color=never") ? $u = 0 : (Vu("color") || Vu("colors") || Vu("color=true") || Vu("color=always")) && ($u = 1), "FORCE_COLOR" in Wu && ($u = Wu.FORCE_COLOR === "true" ? 1 : Wu.FORCE_COLOR === "false" ? 0 : Wu.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(Wu.FORCE_COLOR, 10), 3));
      var Ju = {supportsColor: function(e2) {
        return Uu(zu(e2, e2 && e2.isTTY));
      }, stdout: Uu(zu(true, qu.isatty(1))), stderr: Uu(zu(true, qu.isatty(2)))};
      var Gu = {stringReplaceAll: (e2, t2, n2) => {
        let r2 = e2.indexOf(t2);
        if (r2 === -1)
          return e2;
        const u2 = t2.length;
        let o2 = 0, a2 = "";
        do {
          a2 += e2.substr(o2, r2 - o2) + t2 + n2, o2 = r2 + u2, r2 = e2.indexOf(t2, o2);
        } while (r2 !== -1);
        return a2 += e2.substr(o2), a2;
      }, stringEncaseCRLFWithFirstIndex: (e2, t2, n2, r2) => {
        let u2 = 0, o2 = "";
        do {
          const a2 = e2[r2 - 1] === "\r";
          o2 += e2.substr(u2, (a2 ? r2 - 1 : r2) - u2) + t2 + (a2 ? "\r\n" : "\n") + n2, u2 = r2 + 1, r2 = e2.indexOf("\n", u2);
        } while (r2 !== -1);
        return o2 += e2.substr(u2), o2;
      }};
      const Hu = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Xu = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Yu = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Ku = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, Qu = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function Zu(e2) {
        const t2 = e2[0] === "u", n2 = e2[1] === "{";
        return t2 && !n2 && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e2.slice(2, -1), 16)) : Qu.get(e2) || e2;
      }
      function eo(e2, t2) {
        const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
        let u2;
        for (const t3 of r2) {
          const r3 = Number(t3);
          if (Number.isNaN(r3)) {
            if (!(u2 = t3.match(Yu)))
              throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e2, "')"));
            n2.push(u2[2].replace(Ku, (e3, t4, n3) => t4 ? Zu(t4) : n3));
          } else
            n2.push(r3);
        }
        return n2;
      }
      function to(e2) {
        Xu.lastIndex = 0;
        const t2 = [];
        let n2;
        for (; (n2 = Xu.exec(e2)) !== null; ) {
          const e3 = n2[1];
          if (n2[2]) {
            const r2 = eo(e3, n2[2]);
            t2.push([e3].concat(r2));
          } else
            t2.push([e3]);
        }
        return t2;
      }
      function no(e2, t2) {
        const n2 = {};
        for (const e3 of t2)
          for (const t3 of e3.styles)
            n2[t3[0]] = e3.inverse ? null : t3.slice(1);
        let r2 = e2;
        for (const [e3, t3] of Object.entries(n2))
          if (Array.isArray(t3)) {
            if (!(e3 in r2))
              throw new Error("Unknown Chalk style: ".concat(e3));
            r2 = t3.length > 0 ? r2[e3](...t3) : r2[e3];
          }
        return r2;
      }
      var ro = (e2, t2) => {
        const n2 = [], r2 = [];
        let u2 = [];
        if (t2.replace(Hu, (t3, o2, a2, i2, s2, l2) => {
          if (o2)
            u2.push(Zu(o2));
          else if (i2) {
            const t4 = u2.join("");
            u2 = [], r2.push(n2.length === 0 ? t4 : no(e2, n2)(t4)), n2.push({inverse: a2, styles: to(i2)});
          } else if (s2) {
            if (n2.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r2.push(no(e2, n2)(u2.join(""))), u2 = [], n2.pop();
          } else
            u2.push(l2);
        }), r2.push(u2.join("")), n2.length > 0) {
          const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
          throw new Error(e3);
        }
        return r2.join("");
      };
      const {stdout: uo, stderr: oo} = Ju, {stringReplaceAll: ao, stringEncaseCRLFWithFirstIndex: io} = Gu, {isArray: so} = Array, lo = ["ansi", "ansi", "ansi256", "ansi16m"], co = Object.create(null);
      class po {
        constructor(e2) {
          return fo(e2);
        }
      }
      const fo = (e2) => {
        const t2 = {};
        return ((e3, t3 = {}) => {
          if (t3.level && !(Number.isInteger(t3.level) && t3.level >= 0 && t3.level <= 3))
            throw new Error("The `level` option should be an integer from 0 to 3");
          const n2 = uo ? uo.level : 0;
          e3.level = t3.level === void 0 ? n2 : t3.level;
        })(t2, e2), t2.template = (...e3) => bo(t2.template, ...e3), Object.setPrototypeOf(t2, ho.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        }, t2.template.Instance = po, t2.template;
      };
      function ho(e2) {
        return fo(e2);
      }
      for (const [e2, t2] of Object.entries(Ru))
        co[e2] = {get() {
          const n2 = yo(this, Do(t2.open, t2.close, this._styler), this._isEmpty);
          return Object.defineProperty(this, e2, {value: n2}), n2;
        }};
      co.visible = {get() {
        const e2 = yo(this, this._styler, true);
        return Object.defineProperty(this, "visible", {value: e2}), e2;
      }};
      const mo = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const e2 of mo)
        co[e2] = {get() {
          const {level: t2} = this;
          return function(...n2) {
            const r2 = Do(Ru.color[lo[t2]][e2](...n2), Ru.color.close, this._styler);
            return yo(this, r2, this._isEmpty);
          };
        }};
      for (const e2 of mo) {
        co["bg" + e2[0].toUpperCase() + e2.slice(1)] = {get() {
          const {level: t2} = this;
          return function(...n2) {
            const r2 = Do(Ru.bgColor[lo[t2]][e2](...n2), Ru.bgColor.close, this._styler);
            return yo(this, r2, this._isEmpty);
          };
        }};
      }
      const go = Object.defineProperties(() => {
      }, Object.assign({}, co, {level: {enumerable: true, get() {
        return this._generator.level;
      }, set(e2) {
        this._generator.level = e2;
      }}})), Do = (e2, t2, n2) => {
        let r2, u2;
        return n2 === void 0 ? (r2 = e2, u2 = t2) : (r2 = n2.openAll + e2, u2 = t2 + n2.closeAll), {open: e2, close: t2, openAll: r2, closeAll: u2, parent: n2};
      }, yo = (e2, t2, n2) => {
        const r2 = (...e3) => so(e3[0]) && so(e3[0].raw) ? Eo(r2, bo(r2, ...e3)) : Eo(r2, e3.length === 1 ? "" + e3[0] : e3.join(" "));
        return Object.setPrototypeOf(r2, go), r2._generator = e2, r2._styler = t2, r2._isEmpty = n2, r2;
      }, Eo = (e2, t2) => {
        if (e2.level <= 0 || !t2)
          return e2._isEmpty ? "" : t2;
        let n2 = e2._styler;
        if (n2 === void 0)
          return t2;
        const {openAll: r2, closeAll: u2} = n2;
        if (t2.indexOf("") !== -1)
          for (; n2 !== void 0; )
            t2 = ao(t2, n2.close, n2.open), n2 = n2.parent;
        const o2 = t2.indexOf("\n");
        return o2 !== -1 && (t2 = io(t2, u2, r2, o2)), r2 + t2 + u2;
      };
      let Co;
      const bo = (e2, ...t2) => {
        const [n2] = t2;
        if (!so(n2) || !so(n2.raw))
          return t2.join(" ");
        const r2 = t2.slice(1), u2 = [n2.raw[0]];
        for (let e3 = 1; e3 < n2.length; e3++)
          u2.push(String(r2[e3 - 1]).replace(/[{}\\]/g, "\\$&"), String(n2.raw[e3]));
        return Co === void 0 && (Co = ro), Co(e2, u2.join(""));
      };
      Object.defineProperties(ho.prototype, co);
      const Ao = ho();
      Ao.supportsColor = uo, Ao.stderr = ho({level: oo ? oo.level : 0}), Ao.stderr.supportsColor = oo;
      var vo = Ao;
      var Fo = function(e2, t2) {
        for (var n2 = -1, r2 = t2.length, u2 = e2.length; ++n2 < r2; )
          e2[u2 + n2] = t2[n2];
        return e2;
      }, xo = typeof We == "object" && We && We.Object === Object && We, So = typeof self == "object" && self && self.Object === Object && self, wo = (xo || So || Function("return this")()).Symbol, Bo = Object.prototype, To = Bo.hasOwnProperty, ko = Bo.toString, No = wo ? wo.toStringTag : void 0;
      var Oo = function(e2) {
        var t2 = To.call(e2, No), n2 = e2[No];
        try {
          e2[No] = void 0;
          var r2 = true;
        } catch (e3) {
        }
        var u2 = ko.call(e2);
        return r2 && (t2 ? e2[No] = n2 : delete e2[No]), u2;
      }, Po = Object.prototype.toString;
      var _o = function(e2) {
        return Po.call(e2);
      }, Io = wo ? wo.toStringTag : void 0;
      var jo = function(e2) {
        return e2 == null ? e2 === void 0 ? "[object Undefined]" : "[object Null]" : Io && Io in Object(e2) ? Oo(e2) : _o(e2);
      };
      var Mo = function(e2) {
        return e2 != null && typeof e2 == "object";
      };
      var Lo = function(e2) {
        return Mo(e2) && jo(e2) == "[object Arguments]";
      }, Ro = Object.prototype, qo = Ro.hasOwnProperty, Vo = Ro.propertyIsEnumerable, Wo = Lo(function() {
        return arguments;
      }()) ? Lo : function(e2) {
        return Mo(e2) && qo.call(e2, "callee") && !Vo.call(e2, "callee");
      }, $o = Array.isArray, Uo = wo ? wo.isConcatSpreadable : void 0;
      var zo = function(e2) {
        return $o(e2) || Wo(e2) || !!(Uo && e2 && e2[Uo]);
      };
      var Jo = function e2(t2, n2, r2, u2, o2) {
        var a2 = -1, i2 = t2.length;
        for (r2 || (r2 = zo), o2 || (o2 = []); ++a2 < i2; ) {
          var s2 = t2[a2];
          n2 > 0 && r2(s2) ? n2 > 1 ? e2(s2, n2 - 1, r2, u2, o2) : Fo(o2, s2) : u2 || (o2[o2.length] = s2);
        }
        return o2;
      };
      var Go = function(e2) {
        return (e2 == null ? 0 : e2.length) ? Jo(e2, 1) : [];
      };
      const Ho = {key: (e2) => e2.length === 1 ? "-".concat(e2) : "--".concat(e2), value: (e2) => Fu.apiDescriptor.value(e2), pair: ({key: e2, value: t2}) => t2 === false ? "--no-".concat(e2) : t2 === true ? Ho.key(e2) : t2 === "" ? "".concat(Ho.key(e2), " without an argument") : "".concat(Ho.key(e2), "=").concat(t2)};
      class Xo extends Fu.ChoiceSchema {
        constructor({name: e2, flags: t2}) {
          super({name: e2, choices: t2}), this._flags = t2.slice().sort();
        }
        preprocess(e2, t2) {
          if (typeof e2 == "string" && e2.length !== 0 && !this._flags.includes(e2)) {
            const n2 = this._flags.find((t3) => Bu(t3, e2) < 3);
            if (n2)
              return t2.logger.warn(["Unknown flag ".concat(vo.yellow(t2.descriptor.value(e2)), ","), "did you mean ".concat(vo.blue(t2.descriptor.value(n2)), "?")].join(" ")), n2;
          }
          return e2;
        }
        expected() {
          return "a flag";
        }
      }
      let Yo;
      function Ko(t2, n2, {logger: r2, isCLI: u2 = false, passThrough: o2 = false} = {}) {
        const a2 = o2 ? Array.isArray(o2) ? (e2, t3) => o2.includes(e2) ? {[e2]: t3} : void 0 : (e2, t3) => ({[e2]: t3}) : (t3, n3, r3) => {
          const u3 = e(r3.schemas, ["_"]);
          return Fu.levenUnknownHandler(t3, n3, Object.assign({}, r3, {schemas: u3}));
        }, i2 = u2 ? Ho : Fu.apiDescriptor, s2 = function(e2, {isCLI: t3}) {
          const n3 = [];
          t3 && n3.push(Fu.AnySchema.create({name: "_"}));
          for (const r3 of e2)
            n3.push(Qo(r3, {isCLI: t3, optionInfos: e2})), r3.alias && t3 && n3.push(Fu.AliasSchema.create({name: r3.alias, sourceName: r3.name}));
          return n3;
        }(n2, {isCLI: u2}), l2 = new Fu.Normalizer(s2, {logger: r2, unknown: a2, descriptor: i2}), c2 = r2 !== false;
        c2 && Yo && (l2._hasDeprecationWarned = Yo);
        const p2 = l2.normalize(t2);
        return c2 && (Yo = l2._hasDeprecationWarned), p2;
      }
      function Qo(e2, {isCLI: t2, optionInfos: n2}) {
        let r2;
        const u2 = {name: e2.name}, o2 = {};
        switch (e2.type) {
          case "int":
            r2 = Fu.IntegerSchema, t2 && (u2.preprocess = (e3) => Number(e3));
            break;
          case "string":
            r2 = Fu.StringSchema;
            break;
          case "choice":
            r2 = Fu.ChoiceSchema, u2.choices = e2.choices.map((t3) => typeof t3 == "object" && t3.redirect ? Object.assign({}, t3, {redirect: {to: {key: e2.name, value: t3.redirect}}}) : t3);
            break;
          case "boolean":
            r2 = Fu.BooleanSchema;
            break;
          case "flag":
            r2 = Xo, u2.flags = Go(n2.map((e3) => [e3.alias, e3.description && e3.name, e3.oppositeDescription && "no-".concat(e3.name)].filter(Boolean)));
            break;
          case "path":
            r2 = Fu.StringSchema;
            break;
          default:
            throw new Error("Unexpected type ".concat(e2.type));
        }
        if (e2.exception ? u2.validate = (t3, n3, r3) => e2.exception(t3) || n3.validate(t3, r3) : u2.validate = (e3, t3, n3) => e3 === void 0 || t3.validate(e3, n3), e2.redirect && (o2.redirect = (t3) => t3 ? {to: {key: e2.redirect.option, value: e2.redirect.value}} : void 0), e2.deprecated && (o2.deprecated = true), t2 && !e2.array) {
          const e3 = u2.preprocess || ((e4) => e4);
          u2.preprocess = (t3, n3, r3) => n3.preprocess(e3(Array.isArray(t3) ? t3[t3.length - 1] : t3), r3);
        }
        return e2.array ? Fu.ArraySchema.create(Object.assign({}, t2 ? {preprocess: (e3) => [].concat(e3)} : {}, o2, {valueSchema: r2.create(u2)})) : r2.create(Object.assign({}, u2, o2));
      }
      var Zo = {normalizeApiOptions: function(e2, t2, n2) {
        return Ko(e2, t2, n2);
      }, normalizeCliOptions: function(e2, t2, n2) {
        return Ko(e2, t2, Object.assign({isCLI: true}, n2));
      }};
      function ea(e2, t2) {
        const {ignoreDecorators: n2} = t2 || {};
        if (!n2) {
          const t3 = e2.declaration && e2.declaration.decorators || e2.decorators;
          if (t3 && t3.length > 0)
            return ea(t3[0]);
        }
        return e2.range ? e2.range[0] : e2.start;
      }
      function ta(e2) {
        const t2 = e2.range ? e2.range[1] : e2.end;
        return e2.typeAnnotation ? Math.max(t2, ta(e2.typeAnnotation)) : t2;
      }
      var na = {locStart: ea, locEnd: ta, composeLoc: function(e2, t2 = e2) {
        const n2 = ea(e2);
        return [n2, typeof t2 == "number" ? n2 + t2 : ta(t2)];
      }}, ra = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, t2.matchToToken = function(e3) {
          var t3 = {type: "invalid", value: e3[0], closed: void 0};
          return e3[1] ? (t3.type = "string", t3.closed = !(!e3[3] && !e3[4])) : e3[5] ? t3.type = "comment" : e3[6] ? (t3.type = "comment", t3.closed = !!e3[7]) : e3[8] ? t3.type = "regex" : e3[9] ? t3.type = "number" : e3[10] ? t3.type = "name" : e3[11] ? t3.type = "punctuator" : e3[12] && (t3.type = "whitespace"), t3;
        };
      }), ua = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.isIdentifierStart = l2, t2.isIdentifierChar = c2, t2.isIdentifierName = function(e3) {
          let t3 = true;
          for (let n3 = 0, r3 = Array.from(e3); n3 < r3.length; n3++) {
            const e4 = r3[n3].codePointAt(0);
            if (t3) {
              if (!l2(e4))
                return false;
              t3 = false;
            } else if (!c2(e4))
              return false;
          }
          return !t3;
        };
        let n2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", r2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        const u2 = new RegExp("[" + n2 + "]"), o2 = new RegExp("[" + n2 + r2 + "]");
        n2 = r2 = null;
        const a2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], i2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function s2(e3, t3) {
          let n3 = 65536;
          for (let r3 = 0, u3 = t3.length; r3 < u3; r3 += 2) {
            if (n3 += t3[r3], n3 > e3)
              return false;
            if (n3 += t3[r3 + 1], n3 >= e3)
              return true;
          }
          return false;
        }
        function l2(e3) {
          return e3 < 65 ? e3 === 36 : e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && u2.test(String.fromCharCode(e3)) : s2(e3, a2)));
        }
        function c2(e3) {
          return e3 < 48 ? e3 === 36 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && o2.test(String.fromCharCode(e3)) : s2(e3, a2) || s2(e3, i2))));
        }
      }), oa = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.isReservedWord = i2, t2.isStrictReservedWord = s2, t2.isStrictBindOnlyReservedWord = l2, t2.isStrictBindReservedWord = function(e3, t3) {
          return s2(e3, t3) || l2(e3);
        }, t2.isKeyword = function(e3) {
          return u2.has(e3);
        };
        const n2 = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], r2 = ["eval", "arguments"], u2 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), o2 = new Set(n2), a2 = new Set(r2);
        function i2(e3, t3) {
          return t3 && e3 === "await" || e3 === "enum";
        }
        function s2(e3, t3) {
          return i2(e3, t3) || o2.has(e3);
        }
        function l2(e3) {
          return a2.has(e3);
        }
      }), aa = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), Object.defineProperty(t2, "isIdentifierName", {enumerable: true, get: function() {
          return ua.isIdentifierName;
        }}), Object.defineProperty(t2, "isIdentifierChar", {enumerable: true, get: function() {
          return ua.isIdentifierChar;
        }}), Object.defineProperty(t2, "isIdentifierStart", {enumerable: true, get: function() {
          return ua.isIdentifierStart;
        }}), Object.defineProperty(t2, "isReservedWord", {enumerable: true, get: function() {
          return oa.isReservedWord;
        }}), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", {enumerable: true, get: function() {
          return oa.isStrictBindOnlyReservedWord;
        }}), Object.defineProperty(t2, "isStrictBindReservedWord", {enumerable: true, get: function() {
          return oa.isStrictBindReservedWord;
        }}), Object.defineProperty(t2, "isStrictReservedWord", {enumerable: true, get: function() {
          return oa.isStrictReservedWord;
        }}), Object.defineProperty(t2, "isKeyword", {enumerable: true, get: function() {
          return oa.isKeyword;
        }});
      }), ia = /[|\\{}()[\]^$+*?.]/g, sa = function(e2) {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(ia, "\\$&");
      }, la = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50]}, ca = $e(function(e2) {
        var t2 = {};
        for (var n2 in la)
          la.hasOwnProperty(n2) && (t2[la[n2]] = n2);
        var r2 = e2.exports = {rgb: {channels: 3, labels: "rgb"}, hsl: {channels: 3, labels: "hsl"}, hsv: {channels: 3, labels: "hsv"}, hwb: {channels: 3, labels: "hwb"}, cmyk: {channels: 4, labels: "cmyk"}, xyz: {channels: 3, labels: "xyz"}, lab: {channels: 3, labels: "lab"}, lch: {channels: 3, labels: "lch"}, hex: {channels: 1, labels: ["hex"]}, keyword: {channels: 1, labels: ["keyword"]}, ansi16: {channels: 1, labels: ["ansi16"]}, ansi256: {channels: 1, labels: ["ansi256"]}, hcg: {channels: 3, labels: ["h", "c", "g"]}, apple: {channels: 3, labels: ["r16", "g16", "b16"]}, gray: {channels: 1, labels: ["gray"]}};
        for (var u2 in r2)
          if (r2.hasOwnProperty(u2)) {
            if (!("channels" in r2[u2]))
              throw new Error("missing channels property: " + u2);
            if (!("labels" in r2[u2]))
              throw new Error("missing channel labels property: " + u2);
            if (r2[u2].labels.length !== r2[u2].channels)
              throw new Error("channel and label counts mismatch: " + u2);
            var o2 = r2[u2].channels, a2 = r2[u2].labels;
            delete r2[u2].channels, delete r2[u2].labels, Object.defineProperty(r2[u2], "channels", {value: o2}), Object.defineProperty(r2[u2], "labels", {value: a2});
          }
        r2.rgb.hsl = function(e3) {
          var t3, n3, r3 = e3[0] / 255, u3 = e3[1] / 255, o3 = e3[2] / 255, a3 = Math.min(r3, u3, o3), i2 = Math.max(r3, u3, o3), s2 = i2 - a3;
          return i2 === a3 ? t3 = 0 : r3 === i2 ? t3 = (u3 - o3) / s2 : u3 === i2 ? t3 = 2 + (o3 - r3) / s2 : o3 === i2 && (t3 = 4 + (r3 - u3) / s2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (a3 + i2) / 2, [t3, 100 * (i2 === a3 ? 0 : n3 <= 0.5 ? s2 / (i2 + a3) : s2 / (2 - i2 - a3)), 100 * n3];
        }, r2.rgb.hsv = function(e3) {
          var t3, n3, r3, u3, o3, a3 = e3[0] / 255, i2 = e3[1] / 255, s2 = e3[2] / 255, l2 = Math.max(a3, i2, s2), c2 = l2 - Math.min(a3, i2, s2), p2 = function(e4) {
            return (l2 - e4) / 6 / c2 + 0.5;
          };
          return c2 === 0 ? u3 = o3 = 0 : (o3 = c2 / l2, t3 = p2(a3), n3 = p2(i2), r3 = p2(s2), a3 === l2 ? u3 = r3 - n3 : i2 === l2 ? u3 = 1 / 3 + t3 - r3 : s2 === l2 && (u3 = 2 / 3 + n3 - t3), u3 < 0 ? u3 += 1 : u3 > 1 && (u3 -= 1)), [360 * u3, 100 * o3, 100 * l2];
        }, r2.rgb.hwb = function(e3) {
          var t3 = e3[0], n3 = e3[1], u3 = e3[2];
          return [r2.rgb.hsl(e3)[0], 100 * (1 / 255 * Math.min(t3, Math.min(n3, u3))), 100 * (u3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, u3)))];
        }, r2.rgb.cmyk = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, u3 = e3[2] / 255;
          return [100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - u3))) / (1 - t3) || 0), 100 * ((1 - r3 - t3) / (1 - t3) || 0), 100 * ((1 - u3 - t3) / (1 - t3) || 0), 100 * t3];
        }, r2.rgb.keyword = function(e3) {
          var n3 = t2[e3];
          if (n3)
            return n3;
          var r3, u3, o3, a3 = 1 / 0;
          for (var i2 in la)
            if (la.hasOwnProperty(i2)) {
              var s2 = la[i2], l2 = (u3 = e3, o3 = s2, Math.pow(u3[0] - o3[0], 2) + Math.pow(u3[1] - o3[1], 2) + Math.pow(u3[2] - o3[2], 2));
              l2 < a3 && (a3 = l2, r3 = i2);
            }
          return r3;
        }, r2.keyword.rgb = function(e3) {
          return la[e3];
        }, r2.rgb.xyz = function(e3) {
          var t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255;
          return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
        }, r2.rgb.lab = function(e3) {
          var t3 = r2.rgb.xyz(e3), n3 = t3[0], u3 = t3[1], o3 = t3[2];
          return u3 /= 100, o3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (u3 = u3 > 8856e-6 ? Math.pow(u3, 1 / 3) : 7.787 * u3 + 16 / 116) - 16, 500 * (n3 - u3), 200 * (u3 - (o3 = o3 > 8856e-6 ? Math.pow(o3, 1 / 3) : 7.787 * o3 + 16 / 116))];
        }, r2.hsl.rgb = function(e3) {
          var t3, n3, r3, u3, o3, a3 = e3[0] / 360, i2 = e3[1] / 100, s2 = e3[2] / 100;
          if (i2 === 0)
            return [o3 = 255 * s2, o3, o3];
          t3 = 2 * s2 - (n3 = s2 < 0.5 ? s2 * (1 + i2) : s2 + i2 - s2 * i2), u3 = [0, 0, 0];
          for (var l2 = 0; l2 < 3; l2++)
            (r3 = a3 + 1 / 3 * -(l2 - 1)) < 0 && r3++, r3 > 1 && r3--, o3 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, u3[l2] = 255 * o3;
          return u3;
        }, r2.hsl.hsv = function(e3) {
          var t3 = e3[0], n3 = e3[1] / 100, r3 = e3[2] / 100, u3 = n3, o3 = Math.max(r3, 0.01);
          return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, u3 *= o3 <= 1 ? o3 : 2 - o3, [t3, 100 * (r3 === 0 ? 2 * u3 / (o3 + u3) : 2 * n3 / (r3 + n3)), 100 * ((r3 + n3) / 2)];
        }, r2.hsv.rgb = function(e3) {
          var t3 = e3[0] / 60, n3 = e3[1] / 100, r3 = e3[2] / 100, u3 = Math.floor(t3) % 6, o3 = t3 - Math.floor(t3), a3 = 255 * r3 * (1 - n3), i2 = 255 * r3 * (1 - n3 * o3), s2 = 255 * r3 * (1 - n3 * (1 - o3));
          switch (r3 *= 255, u3) {
            case 0:
              return [r3, s2, a3];
            case 1:
              return [i2, r3, a3];
            case 2:
              return [a3, r3, s2];
            case 3:
              return [a3, i2, r3];
            case 4:
              return [s2, a3, r3];
            case 5:
              return [r3, a3, i2];
          }
        }, r2.hsv.hsl = function(e3) {
          var t3, n3, r3, u3 = e3[0], o3 = e3[1] / 100, a3 = e3[2] / 100, i2 = Math.max(a3, 0.01);
          return r3 = (2 - o3) * a3, n3 = o3 * i2, [u3, 100 * (n3 = (n3 /= (t3 = (2 - o3) * i2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r3 /= 2)];
        }, r2.hwb.rgb = function(e3) {
          var t3, n3, r3, u3, o3, a3, i2, s2 = e3[0] / 360, l2 = e3[1] / 100, c2 = e3[2] / 100, p2 = l2 + c2;
          switch (p2 > 1 && (l2 /= p2, c2 /= p2), r3 = 6 * s2 - (t3 = Math.floor(6 * s2)), (1 & t3) != 0 && (r3 = 1 - r3), u3 = l2 + r3 * ((n3 = 1 - c2) - l2), t3) {
            default:
            case 6:
            case 0:
              o3 = n3, a3 = u3, i2 = l2;
              break;
            case 1:
              o3 = u3, a3 = n3, i2 = l2;
              break;
            case 2:
              o3 = l2, a3 = n3, i2 = u3;
              break;
            case 3:
              o3 = l2, a3 = u3, i2 = n3;
              break;
            case 4:
              o3 = u3, a3 = l2, i2 = n3;
              break;
            case 5:
              o3 = n3, a3 = l2, i2 = u3;
          }
          return [255 * o3, 255 * a3, 255 * i2];
        }, r2.cmyk.rgb = function(e3) {
          var t3 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100, u3 = e3[3] / 100;
          return [255 * (1 - Math.min(1, t3 * (1 - u3) + u3)), 255 * (1 - Math.min(1, n3 * (1 - u3) + u3)), 255 * (1 - Math.min(1, r3 * (1 - u3) + u3))];
        }, r2.xyz.rgb = function(e3) {
          var t3, n3, r3, u3 = e3[0] / 100, o3 = e3[1] / 100, a3 = e3[2] / 100;
          return n3 = -0.9689 * u3 + 1.8758 * o3 + 0.0415 * a3, r3 = 0.0557 * u3 + -0.204 * o3 + 1.057 * a3, t3 = (t3 = 3.2406 * u3 + -1.5372 * o3 + -0.4986 * a3) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (r3 = Math.min(Math.max(0, r3), 1))];
        }, r2.xyz.lab = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (t3 - n3), 200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
        }, r2.lab.xyz = function(e3) {
          var t3, n3, r3, u3 = e3[0];
          t3 = e3[1] / 500 + (n3 = (u3 + 16) / 116), r3 = n3 - e3[2] / 200;
          var o3 = Math.pow(n3, 3), a3 = Math.pow(t3, 3), i2 = Math.pow(r3, 3);
          return n3 = o3 > 8856e-6 ? o3 : (n3 - 16 / 116) / 7.787, t3 = a3 > 8856e-6 ? a3 : (t3 - 16 / 116) / 7.787, r3 = i2 > 8856e-6 ? i2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
        }, r2.lab.lch = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1], u3 = e3[2];
          return (t3 = 360 * Math.atan2(u3, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + u3 * u3), t3];
        }, r2.lch.lab = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1];
          return t3 = e3[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
        }, r2.rgb.ansi16 = function(e3) {
          var t3 = e3[0], n3 = e3[1], u3 = e3[2], o3 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e3)[2];
          if ((o3 = Math.round(o3 / 50)) === 0)
            return 30;
          var a3 = 30 + (Math.round(u3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
          return o3 === 2 && (a3 += 60), a3;
        }, r2.hsv.ansi16 = function(e3) {
          return r2.rgb.ansi16(r2.hsv.rgb(e3), e3[2]);
        }, r2.rgb.ansi256 = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
        }, r2.ansi16.rgb = function(e3) {
          var t3 = e3 % 10;
          if (t3 === 0 || t3 === 7)
            return e3 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
          var n3 = 0.5 * (1 + ~~(e3 > 50));
          return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
        }, r2.ansi256.rgb = function(e3) {
          if (e3 >= 232) {
            var t3 = 10 * (e3 - 232) + 8;
            return [t3, t3, t3];
          }
          var n3;
          return e3 -= 16, [Math.floor(e3 / 36) / 5 * 255, Math.floor((n3 = e3 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
        }, r2.rgb.hex = function(e3) {
          var t3 = (((255 & Math.round(e3[0])) << 16) + ((255 & Math.round(e3[1])) << 8) + (255 & Math.round(e3[2]))).toString(16).toUpperCase();
          return "000000".substring(t3.length) + t3;
        }, r2.hex.rgb = function(e3) {
          var t3 = e3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!t3)
            return [0, 0, 0];
          var n3 = t3[0];
          t3[0].length === 3 && (n3 = n3.split("").map(function(e4) {
            return e4 + e4;
          }).join(""));
          var r3 = parseInt(n3, 16);
          return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
        }, r2.rgb.hcg = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, u3 = e3[2] / 255, o3 = Math.max(Math.max(n3, r3), u3), a3 = Math.min(Math.min(n3, r3), u3), i2 = o3 - a3;
          return t3 = i2 <= 0 ? 0 : o3 === n3 ? (r3 - u3) / i2 % 6 : o3 === r3 ? 2 + (u3 - n3) / i2 : 4 + (n3 - r3) / i2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * i2, 100 * (i2 < 1 ? a3 / (1 - i2) : 0)];
        }, r2.hsl.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = 1, u3 = 0;
          return (r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3)) < 1 && (u3 = (n3 - 0.5 * r3) / (1 - r3)), [e3[0], 100 * r3, 100 * u3];
        }, r2.hsv.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = t3 * n3, u3 = 0;
          return r3 < 1 && (u3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * u3];
        }, r2.hcg.rgb = function(e3) {
          var t3 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
          if (n3 === 0)
            return [255 * r3, 255 * r3, 255 * r3];
          var u3, o3 = [0, 0, 0], a3 = t3 % 1 * 6, i2 = a3 % 1, s2 = 1 - i2;
          switch (Math.floor(a3)) {
            case 0:
              o3[0] = 1, o3[1] = i2, o3[2] = 0;
              break;
            case 1:
              o3[0] = s2, o3[1] = 1, o3[2] = 0;
              break;
            case 2:
              o3[0] = 0, o3[1] = 1, o3[2] = i2;
              break;
            case 3:
              o3[0] = 0, o3[1] = s2, o3[2] = 1;
              break;
            case 4:
              o3[0] = i2, o3[1] = 0, o3[2] = 1;
              break;
            default:
              o3[0] = 1, o3[1] = 0, o3[2] = s2;
          }
          return u3 = (1 - n3) * r3, [255 * (n3 * o3[0] + u3), 255 * (n3 * o3[1] + u3), 255 * (n3 * o3[2] + u3)];
        }, r2.hcg.hsv = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3), r3 = 0;
          return n3 > 0 && (r3 = t3 / n3), [e3[0], 100 * r3, 100 * n3];
        }, r2.hcg.hsl = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
          return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e3[0], 100 * r3, 100 * n3];
        }, r2.hcg.hwb = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3);
          return [e3[0], 100 * (n3 - t3), 100 * (1 - n3)];
        }, r2.hwb.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = 1 - e3[2] / 100, r3 = n3 - t3, u3 = 0;
          return r3 < 1 && (u3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * u3];
        }, r2.apple.rgb = function(e3) {
          return [e3[0] / 65535 * 255, e3[1] / 65535 * 255, e3[2] / 65535 * 255];
        }, r2.rgb.apple = function(e3) {
          return [e3[0] / 255 * 65535, e3[1] / 255 * 65535, e3[2] / 255 * 65535];
        }, r2.gray.rgb = function(e3) {
          return [e3[0] / 100 * 255, e3[0] / 100 * 255, e3[0] / 100 * 255];
        }, r2.gray.hsl = r2.gray.hsv = function(e3) {
          return [0, 0, e3[0]];
        }, r2.gray.hwb = function(e3) {
          return [0, 100, e3[0]];
        }, r2.gray.cmyk = function(e3) {
          return [0, 0, 0, e3[0]];
        }, r2.gray.lab = function(e3) {
          return [e3[0], 0, 0];
        }, r2.gray.hex = function(e3) {
          var t3 = 255 & Math.round(e3[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
          return "000000".substring(n3.length) + n3;
        }, r2.rgb.gray = function(e3) {
          return [(e3[0] + e3[1] + e3[2]) / 3 / 255 * 100];
        };
      });
      function pa(e2) {
        var t2 = function() {
          for (var e3 = {}, t3 = Object.keys(ca), n3 = t3.length, r3 = 0; r3 < n3; r3++)
            e3[t3[r3]] = {distance: -1, parent: null};
          return e3;
        }(), n2 = [e2];
        for (t2[e2].distance = 0; n2.length; )
          for (var r2 = n2.pop(), u2 = Object.keys(ca[r2]), o2 = u2.length, a2 = 0; a2 < o2; a2++) {
            var i2 = u2[a2], s2 = t2[i2];
            s2.distance === -1 && (s2.distance = t2[r2].distance + 1, s2.parent = r2, n2.unshift(i2));
          }
        return t2;
      }
      function da(e2, t2) {
        return function(n2) {
          return t2(e2(n2));
        };
      }
      function fa(e2, t2) {
        for (var n2 = [t2[e2].parent, e2], r2 = ca[t2[e2].parent][e2], u2 = t2[e2].parent; t2[u2].parent; )
          n2.unshift(t2[u2].parent), r2 = da(ca[t2[u2].parent][u2], r2), u2 = t2[u2].parent;
        return r2.conversion = n2, r2;
      }
      var ha = {};
      Object.keys(ca).forEach(function(e2) {
        ha[e2] = {}, Object.defineProperty(ha[e2], "channels", {value: ca[e2].channels}), Object.defineProperty(ha[e2], "labels", {value: ca[e2].labels});
        var t2 = function(e3) {
          for (var t3 = pa(e3), n2 = {}, r2 = Object.keys(t3), u2 = r2.length, o2 = 0; o2 < u2; o2++) {
            var a2 = r2[o2];
            t3[a2].parent !== null && (n2[a2] = fa(a2, t3));
          }
          return n2;
        }(e2);
        Object.keys(t2).forEach(function(n2) {
          var r2 = t2[n2];
          ha[e2][n2] = function(e3) {
            var t3 = function(t4) {
              if (t4 == null)
                return t4;
              arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
              var n3 = e3(t4);
              if (typeof n3 == "object")
                for (var r3 = n3.length, u2 = 0; u2 < r3; u2++)
                  n3[u2] = Math.round(n3[u2]);
              return n3;
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2), ha[e2][n2].raw = function(e3) {
            var t3 = function(t4) {
              return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e3(t4));
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2);
        });
      });
      var ma = ha, ga = $e(function(e2) {
        const t2 = (e3, t3) => function() {
          const n3 = e3.apply(ma, arguments);
          return "[".concat(n3 + t3, "m");
        }, n2 = (e3, t3) => function() {
          const n3 = e3.apply(ma, arguments);
          return "[".concat(38 + t3, ";5;").concat(n3, "m");
        }, r2 = (e3, t3) => function() {
          const n3 = e3.apply(ma, arguments);
          return "[".concat(38 + t3, ";2;").concat(n3[0], ";").concat(n3[1], ";").concat(n3[2], "m");
        };
        Object.defineProperty(e2, "exports", {enumerable: true, get: function() {
          const e3 = new Map(), u2 = {modifier: {reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29]}, color: {black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39]}, bgColor: {bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49]}};
          u2.color.grey = u2.color.gray;
          for (const t3 of Object.keys(u2)) {
            const n3 = u2[t3];
            for (const t4 of Object.keys(n3)) {
              const r3 = n3[t4];
              u2[t4] = {open: "[".concat(r3[0], "m"), close: "[".concat(r3[1], "m")}, n3[t4] = u2[t4], e3.set(r3[0], r3[1]);
            }
            Object.defineProperty(u2, t3, {value: n3, enumerable: false}), Object.defineProperty(u2, "codes", {value: e3, enumerable: false});
          }
          const o2 = (e4) => e4, a2 = (e4, t3, n3) => [e4, t3, n3];
          u2.color.close = "[39m", u2.bgColor.close = "[49m", u2.color.ansi = {ansi: t2(o2, 0)}, u2.color.ansi256 = {ansi256: n2(o2, 0)}, u2.color.ansi16m = {rgb: r2(a2, 0)}, u2.bgColor.ansi = {ansi: t2(o2, 10)}, u2.bgColor.ansi256 = {ansi256: n2(o2, 10)}, u2.bgColor.ansi16m = {rgb: r2(a2, 10)};
          for (let e4 of Object.keys(ma)) {
            if (typeof ma[e4] != "object")
              continue;
            const o3 = ma[e4];
            e4 === "ansi16" && (e4 = "ansi"), "ansi16" in o3 && (u2.color.ansi[e4] = t2(o3.ansi16, 0), u2.bgColor.ansi[e4] = t2(o3.ansi16, 10)), "ansi256" in o3 && (u2.color.ansi256[e4] = n2(o3.ansi256, 0), u2.bgColor.ansi256[e4] = n2(o3.ansi256, 10)), "rgb" in o3 && (u2.color.ansi16m[e4] = r2(o3.rgb, 0), u2.bgColor.ansi16m[e4] = r2(o3.rgb, 10));
          }
          return u2;
        }});
      });
      const Da = Re.env;
      let ya;
      function Ea(e2) {
        return function(e3) {
          return e3 !== 0 && {level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3};
        }(function(e3) {
          if (ya === false)
            return 0;
          if (qr("color=16m") || qr("color=full") || qr("color=truecolor"))
            return 3;
          if (qr("color=256"))
            return 2;
          if (e3 && !e3.isTTY && ya !== true)
            return 0;
          const t2 = ya ? 1 : 0;
          if (Re.platform === "win32") {
            const e4 = Rr.release().split(".");
            return Number(Re.versions.node.split(".")[0]) >= 8 && Number(e4[0]) >= 10 && Number(e4[2]) >= 10586 ? Number(e4[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in Da)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Da) || Da.CI_NAME === "codeship" ? 1 : t2;
          if ("TEAMCITY_VERSION" in Da)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Da.TEAMCITY_VERSION) ? 1 : 0;
          if (Da.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in Da) {
            const e4 = parseInt((Da.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (Da.TERM_PROGRAM) {
              case "iTerm.app":
                return e4 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(Da.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Da.TERM) || "COLORTERM" in Da ? 1 : (Da.TERM, t2);
        }(e2));
      }
      qr("no-color") || qr("no-colors") || qr("color=false") ? ya = false : (qr("color") || qr("colors") || qr("color=true") || qr("color=always")) && (ya = true), "FORCE_COLOR" in Da && (ya = Da.FORCE_COLOR.length === 0 || parseInt(Da.FORCE_COLOR, 10) !== 0);
      var Ca = {supportsColor: Ea, stdout: Ea(Re.stdout), stderr: Ea(Re.stderr)};
      const ba = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Aa = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, va = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Fa = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, xa = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function Sa(e2) {
        return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : xa.get(e2) || e2;
      }
      function wa(e2, t2) {
        const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
        let u2;
        for (const t3 of r2)
          if (isNaN(t3)) {
            if (!(u2 = t3.match(va)))
              throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e2, "')"));
            n2.push(u2[2].replace(Fa, (e3, t4, n3) => t4 ? Sa(t4) : n3));
          } else
            n2.push(Number(t3));
        return n2;
      }
      function Ba(e2) {
        Aa.lastIndex = 0;
        const t2 = [];
        let n2;
        for (; (n2 = Aa.exec(e2)) !== null; ) {
          const e3 = n2[1];
          if (n2[2]) {
            const r2 = wa(e3, n2[2]);
            t2.push([e3].concat(r2));
          } else
            t2.push([e3]);
        }
        return t2;
      }
      function Ta(e2, t2) {
        const n2 = {};
        for (const e3 of t2)
          for (const t3 of e3.styles)
            n2[t3[0]] = e3.inverse ? null : t3.slice(1);
        let r2 = e2;
        for (const e3 of Object.keys(n2))
          if (Array.isArray(n2[e3])) {
            if (!(e3 in r2))
              throw new Error("Unknown Chalk style: ".concat(e3));
            r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
          }
        return r2;
      }
      var ka = (e2, t2) => {
        const n2 = [], r2 = [];
        let u2 = [];
        if (t2.replace(ba, (t3, o2, a2, i2, s2, l2) => {
          if (o2)
            u2.push(Sa(o2));
          else if (i2) {
            const t4 = u2.join("");
            u2 = [], r2.push(n2.length === 0 ? t4 : Ta(e2, n2)(t4)), n2.push({inverse: a2, styles: Ba(i2)});
          } else if (s2) {
            if (n2.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r2.push(Ta(e2, n2)(u2.join(""))), u2 = [], n2.pop();
          } else
            u2.push(l2);
        }), r2.push(u2.join("")), n2.length > 0) {
          const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
          throw new Error(e3);
        }
        return r2.join("");
      }, Na = $e(function(e2) {
        const t2 = Ca.stdout, n2 = Re.platform === "win32" && !(Re.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], u2 = new Set(["gray"]), o2 = Object.create(null);
        function a2(e3, n3) {
          n3 = n3 || {};
          const r3 = t2 ? t2.level : 0;
          e3.level = n3.level === void 0 ? r3 : n3.level, e3.enabled = "enabled" in n3 ? n3.enabled : e3.level > 0;
        }
        function i2(e3) {
          if (!this || !(this instanceof i2) || this.template) {
            const t3 = {};
            return a2(t3, e3), t3.template = function() {
              const e4 = [].slice.call(arguments);
              return p2.apply(null, [t3.template].concat(e4));
            }, Object.setPrototypeOf(t3, i2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = i2, t3.template;
          }
          a2(this, e3);
        }
        n2 && (ga.blue.open = "[94m");
        for (const e3 of Object.keys(ga))
          ga[e3].closeRe = new RegExp(sa(ga[e3].close), "g"), o2[e3] = {get() {
            const t3 = ga[e3];
            return l2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
          }};
        o2.visible = {get() {
          return l2.call(this, this._styles || [], true, "visible");
        }}, ga.color.closeRe = new RegExp(sa(ga.color.close), "g");
        for (const e3 of Object.keys(ga.color.ansi))
          u2.has(e3) || (o2[e3] = {get() {
            const t3 = this.level;
            return function() {
              const n3 = ga.color[r2[t3]][e3].apply(null, arguments), u3 = {open: n3, close: ga.color.close, closeRe: ga.color.closeRe};
              return l2.call(this, this._styles ? this._styles.concat(u3) : [u3], this._empty, e3);
            };
          }});
        ga.bgColor.closeRe = new RegExp(sa(ga.bgColor.close), "g");
        for (const e3 of Object.keys(ga.bgColor.ansi)) {
          if (u2.has(e3))
            continue;
          o2["bg" + e3[0].toUpperCase() + e3.slice(1)] = {get() {
            const t3 = this.level;
            return function() {
              const n3 = ga.bgColor[r2[t3]][e3].apply(null, arguments), u3 = {open: n3, close: ga.bgColor.close, closeRe: ga.bgColor.closeRe};
              return l2.call(this, this._styles ? this._styles.concat(u3) : [u3], this._empty, e3);
            };
          }};
        }
        const s2 = Object.defineProperties(() => {
        }, o2);
        function l2(e3, t3, n3) {
          const r3 = function e4() {
            return c2.apply(e4, arguments);
          };
          r3._styles = e3, r3._empty = t3;
          const u3 = this;
          return Object.defineProperty(r3, "level", {enumerable: true, get: () => u3.level, set(e4) {
            u3.level = e4;
          }}), Object.defineProperty(r3, "enabled", {enumerable: true, get: () => u3.enabled, set(e4) {
            u3.enabled = e4;
          }}), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = s2, r3;
        }
        function c2() {
          const e3 = arguments, t3 = e3.length;
          let r3 = String(arguments[0]);
          if (t3 === 0)
            return "";
          if (t3 > 1)
            for (let n3 = 1; n3 < t3; n3++)
              r3 += " " + e3[n3];
          if (!this.enabled || this.level <= 0 || !r3)
            return this._empty ? "" : r3;
          const u3 = ga.dim.open;
          n2 && this.hasGrey && (ga.dim.open = "");
          for (const e4 of this._styles.slice().reverse())
            r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, "".concat(e4.close, "$&").concat(e4.open));
          return ga.dim.open = u3, r3;
        }
        function p2(e3, t3) {
          if (!Array.isArray(t3))
            return [].slice.call(arguments, 1).join(" ");
          const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
          for (let e4 = 1; e4 < t3.length; e4++)
            r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
          return ka(e3, r3.join(""));
        }
        Object.defineProperties(i2.prototype, o2), e2.exports = i2(), e2.exports.supportsColor = t2, e2.exports.default = e2.exports;
      }), Oa = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.shouldHighlight = l2, t2.getChalk = c2, t2.default = function(e3, t3 = {}) {
          if (l2(t3)) {
            const n3 = c2(t3);
            return function(e4, t4) {
              return t4.replace(r2.default, function(...t5) {
                const n4 = function(e5) {
                  const [t6, n5] = e5.slice(-2), u4 = (0, r2.matchToToken)(e5);
                  if (u4.type === "name") {
                    if ((0, aa.isKeyword)(u4.value) || (0, aa.isReservedWord)(u4.value))
                      return "keyword";
                    if (i2.test(u4.value) && (n5[t6 - 1] === "<" || n5.substr(t6 - 2, 2) == "</"))
                      return "jsx_tag";
                    if (u4.value[0] !== u4.value[0].toLowerCase())
                      return "capitalized";
                  }
                  if (u4.type === "punctuator" && s2.test(u4.value))
                    return "bracket";
                  if (u4.type === "invalid" && (u4.value === "@" || u4.value === "#"))
                    return "punctuator";
                  return u4.type;
                }(t5), u3 = e4[n4];
                return u3 ? t5[0].split(a2).map((e5) => u3(e5)).join("\n") : t5[0];
              });
            }(function(e4) {
              return {keyword: e4.cyan, capitalized: e4.yellow, jsx_tag: e4.yellow, punctuator: e4.yellow, number: e4.magenta, string: e4.green, regex: e4.magenta, comment: e4.grey, invalid: e4.white.bgRed.bold};
            }(n3), e3);
          }
          return e3;
        };
        var n2, r2 = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          if (e3 === null || typeof e3 != "object" && typeof e3 != "function")
            return {default: e3};
          var t3 = o2();
          if (t3 && t3.has(e3))
            return t3.get(e3);
          var n3 = {}, r3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var u3 in e3)
            if (Object.prototype.hasOwnProperty.call(e3, u3)) {
              var a3 = r3 ? Object.getOwnPropertyDescriptor(e3, u3) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, u3, a3) : n3[u3] = e3[u3];
            }
          n3.default = e3, t3 && t3.set(e3, n3);
          return n3;
        }(ra), u2 = (n2 = Na) && n2.__esModule ? n2 : {default: n2};
        function o2() {
          if (typeof WeakMap != "function")
            return null;
          var e3 = new WeakMap();
          return o2 = function() {
            return e3;
          }, e3;
        }
        const a2 = /\r\n|[\n\r\u2028\u2029]/, i2 = /^[a-z][\w-]*$/i, s2 = /^[()[\]{}]$/;
        function l2(e3) {
          return u2.default.supportsColor || e3.forceColor;
        }
        function c2(e3) {
          let t3 = u2.default;
          return e3.forceColor && (t3 = new u2.default.constructor({enabled: true, level: 1})), t3;
        }
      }), Pa = $e(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", {value: true}), t2.codeFrameColumns = a2, t2.default = function(e3, t3, n3, r3 = {}) {
          if (!u2) {
            u2 = true;
            const e4 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            if (Re.emitWarning)
              Re.emitWarning(e4, "DeprecationWarning");
            else {
              new Error(e4).name = "DeprecationWarning", console.warn(new Error(e4));
            }
          }
          n3 = Math.max(n3, 0);
          return a2(e3, {start: {column: n3, line: t3}}, r3);
        };
        var n2 = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          if (e3 === null || typeof e3 != "object" && typeof e3 != "function")
            return {default: e3};
          var t3 = r2();
          if (t3 && t3.has(e3))
            return t3.get(e3);
          var n3 = {}, u3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o3 in e3)
            if (Object.prototype.hasOwnProperty.call(e3, o3)) {
              var a3 = u3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
              a3 && (a3.get || a3.set) ? Object.defineProperty(n3, o3, a3) : n3[o3] = e3[o3];
            }
          n3.default = e3, t3 && t3.set(e3, n3);
          return n3;
        }(Oa);
        function r2() {
          if (typeof WeakMap != "function")
            return null;
          var e3 = new WeakMap();
          return r2 = function() {
            return e3;
          }, e3;
        }
        let u2 = false;
        const o2 = /\r\n|[\n\r\u2028\u2029]/;
        function a2(e3, t3, r3 = {}) {
          const u3 = (r3.highlightCode || r3.forceColor) && (0, n2.shouldHighlight)(r3), a3 = (0, n2.getChalk)(r3), i2 = function(e4) {
            return {gutter: e4.grey, marker: e4.red.bold, message: e4.red.bold};
          }(a3), s2 = (e4, t4) => u3 ? e4(t4) : t4, l2 = e3.split(o2), {start: c2, end: p2, markerLines: d2} = function(e4, t4, n3) {
            const r4 = Object.assign({column: 0, line: -1}, e4.start), u4 = Object.assign({}, r4, e4.end), {linesAbove: o3 = 2, linesBelow: a4 = 3} = n3 || {}, i3 = r4.line, s3 = r4.column, l3 = u4.line, c3 = u4.column;
            let p3 = Math.max(i3 - (o3 + 1), 0), d3 = Math.min(t4.length, l3 + a4);
            i3 === -1 && (p3 = 0), l3 === -1 && (d3 = t4.length);
            const f3 = l3 - i3, h3 = {};
            if (f3)
              for (let e5 = 0; e5 <= f3; e5++) {
                const n4 = e5 + i3;
                if (s3)
                  if (e5 === 0) {
                    const e6 = t4[n4 - 1].length;
                    h3[n4] = [s3, e6 - s3 + 1];
                  } else if (e5 === f3)
                    h3[n4] = [0, c3];
                  else {
                    const r5 = t4[n4 - e5].length;
                    h3[n4] = [0, r5];
                  }
                else
                  h3[n4] = true;
              }
            else
              h3[i3] = s3 === c3 ? !s3 || [s3, 0] : [s3, c3 - s3];
            return {start: p3, end: d3, markerLines: h3};
          }(t3, l2, r3), f2 = t3.start && typeof t3.start.column == "number", h2 = String(p2).length;
          let m2 = (u3 ? (0, n2.default)(e3, r3) : e3).split(o2).slice(c2, p2).map((e4, t4) => {
            const n3 = c2 + 1 + t4, u4 = " ".concat(n3).slice(-h2), o3 = " ".concat(u4, " | "), a4 = d2[n3], l3 = !d2[n3 + 1];
            if (a4) {
              let t5 = "";
              if (Array.isArray(a4)) {
                const n4 = e4.slice(0, Math.max(a4[0] - 1, 0)).replace(/[^\t]/g, " "), u5 = a4[1] || 1;
                t5 = ["\n ", s2(i2.gutter, o3.replace(/\d/g, " ")), n4, s2(i2.marker, "^").repeat(u5)].join(""), l3 && r3.message && (t5 += " " + s2(i2.message, r3.message));
              }
              return [s2(i2.marker, ">"), s2(i2.gutter, o3), e4, t5].join("");
            }
            return " ".concat(s2(i2.gutter, o3)).concat(e4);
          }).join("\n");
          return r3.message && !f2 && (m2 = "".concat(" ".repeat(h2 + 1)).concat(r3.message, "\n").concat(m2)), u3 ? a3.reset(m2) : m2;
        }
      });
      const {ConfigError: _a} = Er, {locStart: Ia, locEnd: ja} = na, Ma = Object.getOwnPropertyNames, La = Object.getOwnPropertyDescriptor;
      function Ra(e2) {
        const t2 = {};
        for (const n2 of e2.plugins)
          if (n2.parsers)
            for (const e3 of Ma(n2.parsers))
              Object.defineProperty(t2, e3, La(n2.parsers, e3));
        return t2;
      }
      function qa(e2, t2) {
        if (t2 = t2 || Ra(e2), typeof e2.parser == "function")
          return {parse: e2.parser, astFormat: "estree", locStart: Ia, locEnd: ja};
        if (typeof e2.parser == "string") {
          if (Object.prototype.hasOwnProperty.call(t2, e2.parser))
            return t2[e2.parser];
          throw new _a(`Couldn't resolve parser "`.concat(e2.parser, '". Parsers must be explicitly added to the standalone bundle.'));
        }
      }
      var Va = {parse: function(e2, t2) {
        const n2 = Ra(t2), r2 = Object.keys(n2).reduce((e3, t3) => Object.defineProperty(e3, t3, {enumerable: true, get: () => n2[t3].parse}), {}), u2 = qa(t2, n2);
        try {
          return u2.preprocess && (e2 = u2.preprocess(e2, t2)), {text: e2, ast: u2.parse(e2, r2, t2)};
        } catch (t3) {
          const {loc: n3} = t3;
          if (n3) {
            const r3 = Pa;
            throw t3.codeFrame = r3.codeFrameColumns(e2, n3, {highlightCode: true}), t3.message += "\n" + t3.codeFrame, t3;
          }
          throw t3.stack;
        }
      }, resolveParser: qa};
      const {UndefinedParserError: Wa} = Er, {getSupportInfo: $a} = yt, {resolveParser: Ua} = Va, za = {astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null};
      function Ja(e2, t2) {
        const n2 = gn.basename(e2).toLowerCase(), r2 = $a({plugins: t2}).languages.filter((e3) => e3.since !== null);
        let u2 = r2.find((e3) => e3.extensions && e3.extensions.some((e4) => n2.endsWith(e4)) || e3.filenames && e3.filenames.some((e4) => e4.toLowerCase() === n2));
        if (!u2 && !n2.includes(".")) {
          const t3 = function(e3) {
            if (typeof e3 != "string")
              return "";
            let t4;
            try {
              t4 = fr.openSync(e3, "r");
            } catch (e4) {
              return "";
            }
            try {
              const e4 = new hr(t4).next().toString("utf8"), n3 = e4.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
              if (n3)
                return n3[1];
              const r3 = e4.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
              return r3 ? r3[1] : "";
            } catch (e4) {
              return "";
            } finally {
              try {
                fr.closeSync(t4);
              } catch (e4) {
              }
            }
          }(e2);
          u2 = r2.find((e3) => e3.interpreters && e3.interpreters.includes(t3));
        }
        return u2 && u2.parsers[0];
      }
      var Ga = {normalize: function(e2, t2) {
        t2 = t2 || {};
        const n2 = Object.assign({}, e2), r2 = $a({plugins: e2.plugins, showUnreleased: true, showDeprecated: true}).options, u2 = Object.assign({}, za, mr(r2.filter((e3) => e3.default !== void 0).map((e3) => [e3.name, e3.default])));
        if (!n2.parser)
          if (n2.filepath) {
            if (n2.parser = Ja(n2.filepath, n2.plugins), !n2.parser)
              throw new Wa("No parser could be inferred for file: ".concat(n2.filepath));
          } else {
            (t2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
          }
        const o2 = Ua(Zo.normalizeApiOptions(n2, [r2.find((e3) => e3.name === "parser")], {passThrough: true, logger: false}));
        n2.astFormat = o2.astFormat, n2.locEnd = o2.locEnd, n2.locStart = o2.locStart;
        const a2 = function(e3) {
          const {astFormat: t3} = e3;
          if (!t3)
            throw new Error("getPlugin() requires astFormat to be set");
          const n3 = e3.plugins.find((e4) => e4.printers && e4.printers[t3]);
          if (!n3)
            throw new Error(`Couldn't find plugin for AST format "`.concat(t3, '"'));
          return n3;
        }(n2);
        n2.printer = a2.printers[n2.astFormat];
        const i2 = r2.filter((e3) => e3.pluginDefaults && e3.pluginDefaults[a2.name] !== void 0).reduce((e3, t3) => Object.assign(e3, {[t3.name]: t3.pluginDefaults[a2.name]}), {}), s2 = Object.assign({}, u2, i2);
        return Object.keys(s2).forEach((e3) => {
          n2[e3] == null && (n2[e3] = s2[e3]);
        }), n2.parser === "json" && (n2.trailingComma = "none"), Zo.normalizeApiOptions(n2, r2, Object.assign({passThrough: Object.keys(za)}, t2));
      }, hiddenDefaults: za, inferParser: Ja};
      var Ha = function e2(t2, n2, r2) {
        if (Array.isArray(t2))
          return t2.map((t3) => e2(t3, n2, r2)).filter(Boolean);
        if (!t2 || typeof t2 != "object")
          return t2;
        const u2 = {};
        for (const r3 of Object.keys(t2))
          typeof t2[r3] != "function" && (u2[r3] = e2(t2[r3], n2, t2));
        if (n2.printer.massageAstNode) {
          const e3 = n2.printer.massageAstNode(t2, u2, r2);
          if (e3 === null)
            return;
          if (e3)
            return e3;
        }
        return u2;
      };
      function Xa() {
      }
      Xa.ok = function() {
      }, Xa.strictEqual = function() {
      };
      const {concat: Ya, line: Ka, hardline: Qa, breakParent: Za, indent: ei, lineSuffix: ti, join: ni, cursor: ri} = dn.builders, {hasNewline: ui, skipNewline: oi, skipSpaces: ai, isPreviousLineEmpty: ii, addLeadingComment: si, addDanglingComment: li, addTrailingComment: ci} = Lt, pi = Symbol("child-nodes");
      function di(e2, t2, n2) {
        if (!e2)
          return;
        const {printer: r2, locStart: u2, locEnd: o2} = t2;
        if (n2) {
          if (r2.canAttachComment && r2.canAttachComment(e2)) {
            let t3;
            for (t3 = n2.length - 1; t3 >= 0 && !(u2(n2[t3]) <= u2(e2) && o2(n2[t3]) <= o2(e2)); --t3)
              ;
            return void n2.splice(t3 + 1, 0, e2);
          }
        } else if (e2[pi])
          return e2[pi];
        const a2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e2, t2) || typeof e2 == "object" && Object.keys(e2).filter((e3) => e3 !== "enclosingNode" && e3 !== "precedingNode" && e3 !== "followingNode" && e3 !== "tokens" && e3 !== "comments").map((t3) => e2[t3]);
        return a2 ? (n2 || Object.defineProperty(e2, pi, {value: n2 = [], enumerable: false}), a2.forEach((e3) => {
          di(e3, t2, n2);
        }), n2) : void 0;
      }
      function fi(e2, t2, n2) {
        const r2 = e2.length;
        if (r2 === 0)
          return;
        const {precedingNode: u2, followingNode: o2, enclosingNode: a2} = e2[0], i2 = n2.printer.getGapRegex && n2.printer.getGapRegex(a2) || /^[\s(]*$/;
        let s2, l2 = n2.locStart(o2);
        for (s2 = r2; s2 > 0; --s2) {
          const r3 = e2[s2 - 1];
          Xa.strictEqual(r3.precedingNode, u2), Xa.strictEqual(r3.followingNode, o2);
          const a3 = t2.slice(n2.locEnd(r3), l2);
          if (!i2.test(a3))
            break;
          l2 = n2.locStart(r3);
        }
        e2.forEach((e3, t3) => {
          t3 < s2 ? ci(u2, e3) : si(o2, e3);
        });
        for (const e3 of [u2, o2])
          e3.comments && e3.comments.length > 1 && e3.comments.sort((e4, t3) => n2.locStart(e4) - n2.locStart(t3));
        e2.length = 0;
      }
      function hi(e2, t2) {
        return e2.getValue().printed = true, t2.printer.printComment(e2, t2);
      }
      function mi(e2, t2, n2) {
        const r2 = n2.locStart(t2) - 1;
        for (let t3 = 1; t3 < e2.length; ++t3)
          if (r2 < n2.locStart(e2[t3]))
            return t3 - 1;
        return 0;
      }
      function gi(e2, t2, n2) {
        return e2.getNode() === t2.cursorNode && e2.getValue() ? Ya([ri, n2, ri]) : n2;
      }
      var Di = {attach: function(e2, t2, n2, r2) {
        if (!Array.isArray(e2))
          return;
        const u2 = [], {locStart: o2, locEnd: a2} = r2;
        e2.forEach((i2, s2) => {
          if (r2.parser === "json" || r2.parser === "json5" || r2.parser === "__js_expression" || r2.parser === "__vue_expression") {
            if (o2(i2) - o2(t2) <= 0)
              return void si(t2, i2);
            if (a2(i2) - a2(t2) >= 0)
              return void ci(t2, i2);
          }
          !function e3(t3, n3, r3) {
            const {locStart: u3, locEnd: o3} = r3, a3 = di(t3, r3);
            let i3, s3, l3 = 0, c3 = a3.length;
            for (; l3 < c3; ) {
              const t4 = l3 + c3 >> 1, p3 = a3[t4];
              if (u3(p3) - u3(n3) <= 0 && o3(n3) - o3(p3) <= 0)
                return n3.enclosingNode = p3, void e3(p3, n3, r3);
              if (o3(p3) - u3(n3) <= 0)
                i3 = p3, l3 = t4 + 1;
              else {
                if (!(o3(n3) - u3(p3) <= 0))
                  throw new Error("Comment location overlaps with node location");
                s3 = p3, c3 = t4;
              }
            }
            if (n3.enclosingNode && n3.enclosingNode.type === "TemplateLiteral") {
              const {quasis: e4} = n3.enclosingNode, t4 = mi(e4, n3, r3);
              i3 && mi(e4, i3, r3) !== t4 && (i3 = null), s3 && mi(e4, s3, r3) !== t4 && (s3 = null);
            }
            i3 && (n3.precedingNode = i3), s3 && (n3.followingNode = s3);
          }(t2, i2, r2);
          const {precedingNode: l2, enclosingNode: c2, followingNode: p2} = i2, d2 = r2.printer.handleComments && r2.printer.handleComments.ownLine ? r2.printer.handleComments.ownLine : () => false, f2 = r2.printer.handleComments && r2.printer.handleComments.endOfLine ? r2.printer.handleComments.endOfLine : () => false, h2 = r2.printer.handleComments && r2.printer.handleComments.remaining ? r2.printer.handleComments.remaining : () => false, m2 = e2.length - 1 === s2;
          if (ui(n2, o2(i2), {backwards: true}))
            d2(i2, n2, r2, t2, m2) || (p2 ? si(p2, i2) : l2 ? ci(l2, i2) : li(c2 || t2, i2));
          else if (ui(n2, a2(i2)))
            f2(i2, n2, r2, t2, m2) || (l2 ? ci(l2, i2) : p2 ? si(p2, i2) : li(c2 || t2, i2));
          else if (h2(i2, n2, r2, t2, m2))
            ;
          else if (l2 && p2) {
            const e3 = u2.length;
            if (e3 > 0) {
              u2[e3 - 1].followingNode !== i2.followingNode && fi(u2, n2, r2);
            }
            u2.push(i2);
          } else
            l2 ? ci(l2, i2) : p2 ? si(p2, i2) : li(c2 || t2, i2);
        }), fi(u2, n2, r2), e2.forEach((e3) => {
          delete e3.precedingNode, delete e3.enclosingNode, delete e3.followingNode;
        });
      }, printComments: function(e2, t2, n2, r2) {
        const u2 = e2.getValue(), o2 = t2(e2), a2 = u2 && u2.comments;
        if (!a2 || a2.length === 0)
          return gi(e2, n2, o2);
        const i2 = [], s2 = [r2 ? ";" : "", o2];
        return e2.each((e3) => {
          const t3 = e3.getValue(), {leading: r3, trailing: u3} = t3;
          if (r3) {
            const r4 = function(e4, t4) {
              const n3 = e4.getValue(), r5 = hi(e4, t4);
              if (!r5)
                return "";
              if (t4.printer.isBlockComment && t4.printer.isBlockComment(n3)) {
                const e5 = ui(t4.originalText, t4.locEnd(n3)) ? ui(t4.originalText, t4.locStart(n3), {backwards: true}) ? Qa : Ka : " ";
                return Ya([r5, e5]);
              }
              return Ya([r5, Qa]);
            }(e3, n2);
            if (!r4)
              return;
            i2.push(r4);
            const u4 = n2.originalText, o3 = oi(u4, ai(u4, n2.locEnd(t3)));
            o3 !== false && ui(u4, o3) && i2.push(Qa);
          } else
            u3 && s2.push(function(e4, t4) {
              const n3 = e4.getValue(), r4 = hi(e4, t4);
              if (!r4)
                return "";
              const {printer: u4, originalText: o3, locStart: a3} = t4, i3 = u4.isBlockComment && u4.isBlockComment(n3);
              if (ui(o3, a3(n3), {backwards: true})) {
                const e5 = ii(o3, n3, a3);
                return ti(Ya([Qa, e5 ? Qa : "", r4]));
              }
              let s3 = Ya([" ", r4]);
              return i3 || (s3 = Ya([ti(s3), Za])), s3;
            }(e3, n2));
        }, "comments"), gi(e2, n2, Ya(i2.concat(s2)));
      }, printDanglingComments: function(e2, t2, n2, r2) {
        const u2 = [], o2 = e2.getValue();
        return o2 && o2.comments ? (e2.each((e3) => {
          const n3 = e3.getValue();
          !n3 || n3.leading || n3.trailing || r2 && !r2(n3) || u2.push(hi(e3, t2));
        }, "comments"), u2.length === 0 ? "" : n2 ? ni(Qa, u2) : ei(Ya([Qa, ni(Qa, u2)]))) : "";
      }, getSortedChildNodes: di, ensureAllCommentsPrinted: function(e2) {
        e2 && e2.forEach((e3) => {
          if (!e3.printed)
            throw new Error('Comment "' + e3.value.trim() + '" was not printed. Please report this error!');
          delete e3.printed;
        });
      }};
      function yi(e2, t2) {
        const n2 = Ei(e2.stack, t2);
        return n2 === -1 ? null : e2.stack[n2];
      }
      function Ei(e2, t2) {
        for (let n2 = e2.length - 1; n2 >= 0; n2 -= 2) {
          const r2 = e2[n2];
          if (r2 && !Array.isArray(r2) && --t2 < 0)
            return n2;
        }
        return -1;
      }
      var Ci = class {
        constructor(e2) {
          this.stack = [e2];
        }
        getName() {
          const {stack: e2} = this, {length: t2} = e2;
          return t2 > 1 ? e2[t2 - 2] : null;
        }
        getValue() {
          return he(this.stack);
        }
        getNode(e2 = 0) {
          return yi(this, e2);
        }
        getParentNode(e2 = 0) {
          return yi(this, e2 + 1);
        }
        call(e2, ...t2) {
          const {stack: n2} = this, {length: r2} = n2;
          let u2 = he(n2);
          for (const e3 of t2)
            u2 = u2[e3], n2.push(e3, u2);
          const o2 = e2(this);
          return n2.length = r2, o2;
        }
        callParent(e2, t2 = 0) {
          const n2 = Ei(this.stack, t2 + 1), r2 = this.stack.splice(n2 + 1), u2 = e2(this);
          return this.stack.push(...r2), u2;
        }
        each(e2, ...t2) {
          const {stack: n2} = this, {length: r2} = n2;
          let u2 = he(n2);
          for (const e3 of t2)
            u2 = u2[e3], n2.push(e3, u2);
          for (let t3 = 0; t3 < u2.length; ++t3)
            t3 in u2 && (n2.push(t3, u2[t3]), e2(this), n2.length -= 2);
          n2.length = r2;
        }
        map(e2, ...t2) {
          const {stack: n2} = this, {length: r2} = n2;
          let u2 = he(n2);
          for (const e3 of t2)
            u2 = u2[e3], n2.push(e3, u2);
          const o2 = new Array(u2.length);
          for (let t3 = 0; t3 < u2.length; ++t3)
            t3 in u2 && (n2.push(t3, u2[t3]), o2[t3] = e2(this, t3), n2.length -= 2);
          return n2.length = r2, o2;
        }
        match(...e2) {
          let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
          for (const u2 of e2) {
            if (r2 === void 0)
              return false;
            let e3 = null;
            if (typeof n2 == "number" && (e3 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), u2 && !u2(r2, n2, e3))
              return false;
            n2 = this.stack[t2--], r2 = this.stack[t2--];
          }
          return true;
        }
      };
      const {utils: {stripTrailingHardline: bi}} = dn, {normalize: Ai} = Ga;
      var vi = {printSubtree: function(e2, t2, n2, r2) {
        if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
          return n2.printer.embed(e2, t2, (e3, t3, u2) => function(e4, t4, n3, r3, {stripTrailingHardline: u3 = false} = {}) {
            const o2 = Ai(Object.assign({}, n3, t4, {parentParser: n3.parser, embeddedInHtml: !(!n3.embeddedInHtml && n3.parser !== "html" && n3.parser !== "vue" && n3.parser !== "angular" && n3.parser !== "lwc"), originalText: e4}), {passThrough: true}), a2 = Va.parse(e4, o2), {ast: i2} = a2;
            e4 = a2.text;
            const s2 = i2.comments;
            delete i2.comments, Di.attach(s2, i2, e4, o2), o2[Symbol.for("comments")] = s2 || [], o2[Symbol.for("tokens")] = i2.tokens || [];
            const l2 = r3(i2, o2);
            if (Di.ensureAllCommentsPrinted(s2), u3)
              return typeof l2 == "string" ? l2.replace(/(?:\r?\n)*$/, "") : bi(l2, true);
            return l2;
          }(e3, t3, n2, r2, u2), n2);
      }};
      const Fi = dn, xi = Fi.builders, {concat: Si, hardline: wi, addAlignmentToDoc: Bi} = xi, Ti = Fi.utils;
      function ki(e2, t2, n2 = 0) {
        const {printer: r2} = t2;
        r2.preprocess && (e2 = r2.preprocess(e2, t2));
        const u2 = new Map();
        let o2 = function e3(n3, o3) {
          const a2 = n3.getValue(), i2 = a2 && typeof a2 == "object" && o3 === void 0;
          if (i2 && u2.has(a2))
            return u2.get(a2);
          let s2;
          return s2 = r2.willPrintOwnComments && r2.willPrintOwnComments(n3, t2) ? Ni(n3, t2, e3, o3) : Di.printComments(n3, (n4) => Ni(n4, t2, e3, o3), t2, o3 && o3.needsSemi), i2 && u2.set(a2, s2), s2;
        }(new Ci(e2));
        return n2 > 0 && (o2 = Bi(Si([wi, o2]), n2, t2.tabWidth)), Ti.propagateBreaks(o2), o2;
      }
      function Ni(e2, t2, n2, r2) {
        Xa.ok(e2 instanceof Ci);
        const u2 = e2.getValue(), {printer: o2} = t2;
        if (o2.hasPrettierIgnore && o2.hasPrettierIgnore(e2))
          return function(e3, t3) {
            const {originalText: n3, [Symbol.for("comments")]: r3, locStart: u3, locEnd: o3} = t3, a2 = u3(e3), i2 = o3(e3);
            for (const e4 of r3)
              u3(e4) >= a2 && o3(e4) <= i2 && (e4.printed = true);
            return n3.slice(a2, i2);
          }(u2, t2);
        if (u2)
          try {
            const r3 = vi.printSubtree(e2, n2, t2, ki);
            if (r3)
              return r3;
          } catch (e3) {
            if (We.PRETTIER_DEBUG)
              throw e3;
          }
        return o2.print(e2, t2, n2, r2);
      }
      var Oi = ki;
      function Pi(e2, t2, n2, r2, u2 = []) {
        if (!(t2 < n2.locStart(e2) || t2 > n2.locEnd(e2))) {
          for (const o2 of Di.getSortedChildNodes(e2, n2)) {
            const a2 = Pi(o2, t2, n2, r2, [e2, ...u2]);
            if (a2)
              return a2;
          }
          return !r2 || r2(e2) ? {node: e2, parentNodes: u2} : void 0;
        }
      }
      const _i = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral"]), Ii = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
      function ji(e2, t2) {
        if (t2 == null)
          return false;
        switch (e2.parser) {
          case "flow":
          case "babel":
          case "babel-flow":
          case "babel-ts":
          case "typescript":
            return function(e3) {
              return e3 === "Directive" || e3 === "TypeAlias" || e3 === "TSExportAssignment" || e3.startsWith("Declare") || e3.startsWith("TSDeclare") || e3.endsWith("Statement") || e3.endsWith("Declaration");
            }(t2.type);
          case "json":
            return _i.has(t2.type);
          case "graphql":
            return Ii.has(t2.kind);
          case "vue":
            return t2.tag !== "root";
        }
        return false;
      }
      var Mi = {calculateRange: function(e2, t2, n2) {
        const r2 = e2.slice(t2.rangeStart, t2.rangeEnd), u2 = Math.max(t2.rangeStart + r2.search(/\S/), t2.rangeStart);
        let o2;
        for (o2 = t2.rangeEnd; o2 > t2.rangeStart && !/\S/.test(e2[o2 - 1]); --o2)
          ;
        const a2 = Pi(n2, u2, t2, (e3) => ji(t2, e3)), i2 = Pi(n2, o2, t2, (e3) => ji(t2, e3));
        if (!a2 || !i2)
          return {rangeStart: 0, rangeEnd: 0};
        const {startNode: s2, endNode: l2} = function(e3, t3, n3) {
          let r3 = e3.node, u3 = t3.node;
          if (r3 === u3)
            return {startNode: r3, endNode: u3};
          for (const r4 of t3.parentNodes) {
            if (!(r4.type !== "Program" && r4.type !== "File" && n3.locStart(r4) >= n3.locStart(e3.node)))
              break;
            u3 = r4;
          }
          for (const u4 of e3.parentNodes) {
            if (!(u4.type !== "Program" && u4.type !== "File" && n3.locEnd(u4) <= n3.locEnd(t3.node)))
              break;
            r3 = u4;
          }
          return {startNode: r3, endNode: u3};
        }(a2, i2, t2);
        return {rangeStart: Math.min(t2.locStart(s2), t2.locStart(l2)), rangeEnd: Math.max(t2.locEnd(s2), t2.locEnd(l2))};
      }, findNodeAtOffset: Pi}, Li = Ue(K);
      const {printer: {printDocToString: Ri}, debug: {printDocToDebug: qi}} = dn, {getAlignmentSize: Vi} = Lt, {guessEndOfLine: Wi, convertEndOfLineToChars: $i, countEndOfLineChars: Ui, normalizeEndOfLine: zi} = Rt, Ji = Ga.normalize, Gi = Symbol("cursor");
      function Hi(e2, t2, n2) {
        const r2 = t2.comments;
        return r2 && (delete t2.comments, Di.attach(r2, t2, e2, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t2.tokens || [], n2.originalText = e2, r2;
      }
      function Xi(e2, t2, n2) {
        if (!e2 || !e2.trim().length)
          return {formatted: "", cursorOffset: -1};
        n2 = n2 || 0;
        const r2 = Va.parse(e2, t2), {ast: u2} = r2;
        if (e2 = r2.text, t2.cursorOffset >= 0) {
          const e3 = Mi.findNodeAtOffset(u2, t2.cursorOffset, t2);
          e3 && e3.node && (t2.cursorNode = e3.node);
        }
        const o2 = Hi(e2, u2, t2), a2 = Oi(u2, t2, n2), i2 = Ri(a2, t2);
        if (Di.ensureAllCommentsPrinted(o2), n2 > 0) {
          const e3 = i2.formatted.trim();
          i2.cursorNodeStart !== void 0 && (i2.cursorNodeStart -= i2.formatted.indexOf(e3)), i2.formatted = e3 + $i(t2.endOfLine);
        }
        if (t2.cursorOffset >= 0) {
          let n3, r3, u3, o3, a3;
          if (t2.cursorNode && i2.cursorNodeText ? (n3 = t2.locStart(t2.cursorNode), r3 = e2.slice(n3, t2.locEnd(t2.cursorNode)), u3 = t2.cursorOffset - n3, o3 = i2.cursorNodeStart, a3 = i2.cursorNodeText) : (n3 = 0, r3 = e2, u3 = t2.cursorOffset, o3 = 0, a3 = i2.formatted), r3 === a3)
            return {formatted: i2.formatted, cursorOffset: o3 + u3};
          const s2 = r3.split("");
          s2.splice(u3, 0, Gi);
          const l2 = a3.split(""), c2 = Li.diffArrays(s2, l2);
          let p2 = o3;
          for (const e3 of c2)
            if (e3.removed) {
              if (e3.value.includes(Gi))
                break;
            } else
              p2 += e3.count;
          return {formatted: i2.formatted, cursorOffset: p2};
        }
        return {formatted: i2.formatted, cursorOffset: -1};
      }
      function Yi(e2, t2) {
        const n2 = Va.resolveParser(t2), r2 = e2.charAt(0) === "\uFEFF";
        let u2 = r2 ? e2.slice(1) : e2;
        const o2 = t2.cursorOffset >= 0;
        o2 || (t2.cursorOffset = -1);
        const a2 = !n2.hasPragma || n2.hasPragma(u2);
        if (t2.requirePragma && !a2)
          return {formatted: e2, cursorOffset: t2.cursorOffset};
        t2.endOfLine === "auto" && (t2.endOfLine = Wi(u2));
        const i2 = t2.rangeStart > 0, s2 = t2.rangeEnd < u2.length;
        if (r2 && (o2 && t2.cursorOffset--, i2 && t2.rangeStart--, s2 && t2.rangeEnd--), u2.includes("\r")) {
          const e3 = (e4) => Ui(u2.slice(0, e4), "\r\n");
          o2 && (t2.cursorOffset -= e3(t2.cursorOffset)), i2 && (t2.rangeStart -= e3(t2.rangeStart)), s2 && (t2.rangeEnd -= e3(t2.rangeEnd)), u2 = zi(u2);
        }
        let l2;
        return t2.rangeStart < 0 && (t2.rangeStart = 0), t2.rangeEnd > u2.length && (t2.rangeEnd = u2.length), i2 || s2 ? l2 = function(e3, t3) {
          const n3 = Va.parse(e3, t3), {ast: r3} = n3;
          e3 = n3.text;
          const {rangeStart: u3, rangeEnd: o3} = Mi.calculateRange(e3, t3, r3), a3 = e3.slice(u3, o3), i3 = Math.min(u3, e3.lastIndexOf("\n", u3) + 1), s3 = e3.slice(i3, u3).match(/^\s*/)[0], l3 = Vi(s3, t3.tabWidth), c2 = Xi(a3, Object.assign({}, t3, {rangeStart: 0, rangeEnd: 1 / 0, cursorOffset: t3.cursorOffset > u3 && t3.cursorOffset < o3 ? t3.cursorOffset - u3 : -1, endOfLine: "lf"}), l3), p2 = c2.formatted.trimEnd();
          let {cursorOffset: d2} = t3;
          d2 >= o3 ? d2 = t3.cursorOffset + (p2.length - a3.length) : c2.cursorOffset >= 0 && (d2 = c2.cursorOffset + u3);
          let f2 = e3.slice(0, u3) + p2 + e3.slice(o3);
          if (t3.endOfLine !== "lf") {
            const e4 = $i(t3.endOfLine);
            d2 >= 0 && e4 === "\r\n" && (d2 += Ui(f2.slice(0, d2), "\n")), f2 = f2.replace(/\n/g, e4);
          }
          return {formatted: f2, cursorOffset: d2};
        }(u2, t2) : (!a2 && t2.insertPragma && t2.printer.insertPragma && (u2 = t2.printer.insertPragma(u2)), l2 = Xi(u2, t2)), r2 && (l2.formatted = "\uFEFF" + l2.formatted, o2 && l2.cursorOffset >= 0 && l2.cursorOffset++), l2;
      }
      var Ki = {formatWithCursor: (e2, t2) => Yi(e2, t2 = Ji(t2)), parse(e2, t2, n2) {
        t2 = Ji(t2), e2 = zi(e2.charAt(0) === "\uFEFF" ? e2.slice(1) : e2);
        const r2 = Va.parse(e2, t2);
        return n2 && (r2.ast = Ha(r2.ast, t2)), r2;
      }, formatAST(e2, t2) {
        t2 = Ji(t2);
        const n2 = Oi(e2, t2);
        return Ri(n2, t2);
      }, formatDoc(e2, t2) {
        t2 = Ji(Object.assign({}, t2, {parser: "babel"}));
        return Yi(qi(e2), t2).formatted;
      }, printToDoc(e2, t2) {
        t2 = Ji(t2);
        const n2 = Va.parse(e2, t2), {ast: r2, text: u2} = n2;
        return Hi(u2, r2, t2), Oi(r2, t2);
      }, printDocToString: (e2, t2) => Ri(e2, Ji(t2))};
      const {getMaxContinuousCount: Qi, getStringWidth: Zi, getAlignmentSize: es, getIndentSize: ts, skip: ns, skipWhitespace: rs, skipSpaces: us, skipNewline: os, skipToLineEnd: as, skipEverythingButNewLine: is, skipInlineComment: ss, skipTrailingComment: ls, hasNewline: cs, hasNewlineInRange: ps, hasSpaces: ds, isNextLineEmpty: fs, isNextLineEmptyAfterIndex: hs, isPreviousLineEmpty: ms, getNextNonSpaceNonCommentCharacterIndex: gs, makeString: Ds, addLeadingComment: ys, addDanglingComment: Es, addTrailingComment: Cs} = Lt;
      var bs = {getMaxContinuousCount: Qi, getStringWidth: Zi, getAlignmentSize: es, getIndentSize: ts, skip: ns, skipWhitespace: rs, skipSpaces: us, skipNewline: os, skipToLineEnd: as, skipEverythingButNewLine: is, skipInlineComment: ss, skipTrailingComment: ls, hasNewline: cs, hasNewlineInRange: ps, hasSpaces: ds, isNextLineEmpty: fs, isNextLineEmptyAfterIndex: hs, isPreviousLineEmpty: ms, getNextNonSpaceNonCommentCharacterIndex: gs, makeString: Ds, addLeadingComment: ys, addDanglingComment: Es, addTrailingComment: Cs}, As = function(t2, n2) {
        const {languageId: r2} = t2, u2 = e(t2, ["languageId"]);
        return Object.assign({linguistLanguageId: r2}, u2, n2(t2));
      };
      const {getLast: vs, hasNewline: Fs, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: xs, getNextNonSpaceNonCommentCharacter: Ss, hasNewlineInRange: ws, isNodeIgnoreComment: Bs, addLeadingComment: Ts, addTrailingComment: ks, addDanglingComment: Ns, getNextNonSpaceNonCommentCharacterIndex: Os} = Lt;
      function Ps(e2, t2) {
        const n2 = (e2.body || e2.properties).filter((e3) => e3.type !== "EmptyStatement");
        n2.length === 0 ? Ns(e2, t2) : Ts(n2[0], t2);
      }
      function _s(e2, t2) {
        e2.type === "BlockStatement" ? Ps(e2, t2) : Ts(e2, t2);
      }
      function Is(e2, t2, n2, r2, u2, o2) {
        if (!n2 || n2.type !== "IfStatement" || !r2)
          return false;
        return Ss(e2, u2, o2.locEnd) === ")" ? (ks(t2, u2), true) : t2 === n2.consequent && r2 === n2.alternate ? (t2.type === "BlockStatement" ? ks(t2, u2) : Ns(n2, u2), true) : r2.type === "BlockStatement" ? (Ps(r2, u2), true) : r2.type === "IfStatement" ? (_s(r2.consequent, u2), true) : n2.consequent === r2 && (Ts(r2, u2), true);
      }
      function js(e2, t2, n2, r2, u2, o2) {
        if (!n2 || n2.type !== "WhileStatement" || !r2)
          return false;
        return Ss(e2, u2, o2.locEnd) === ")" ? (ks(t2, u2), true) : r2.type === "BlockStatement" && (Ps(r2, u2), true);
      }
      function Ms(e2, t2, n2, r2) {
        return !(!e2 || e2.type !== "TryStatement" && e2.type !== "CatchClause" || !n2) && (e2.type === "CatchClause" && t2 ? (ks(t2, r2), true) : n2.type === "BlockStatement" ? (Ps(n2, r2), true) : n2.type === "TryStatement" ? (_s(n2.finalizer, r2), true) : n2.type === "CatchClause" && (_s(n2.body, r2), true));
      }
      function Ls(e2, t2, n2, r2) {
        if (e2 && (e2.type === "ClassDeclaration" || e2.type === "ClassExpression" || e2.type === "DeclareClass" || e2.type === "DeclareInterface" || e2.type === "InterfaceDeclaration" || e2.type === "TSInterfaceDeclaration")) {
          if (e2.decorators && e2.decorators.length > 0 && (!n2 || n2.type !== "Decorator"))
            return ks(e2.decorators[e2.decorators.length - 1], r2), true;
          if (e2.body && n2 === e2.body)
            return Ps(e2.body, r2), true;
          if (n2) {
            for (const u2 of ["implements", "extends", "mixins"])
              if (e2[u2] && n2 === e2[u2][0])
                return !t2 || t2 !== e2.id && t2 !== e2.typeParameters && t2 !== e2.superClass ? Ns(e2, r2, u2) : ks(t2, r2), true;
          }
        }
        return false;
      }
      function Rs(e2, t2, n2, r2, u2) {
        return (t2 && n2 && (t2.type === "Property" || t2.type === "TSDeclareMethod" || t2.type === "TSAbstractMethodDefinition") && n2.type === "Identifier" && t2.key === n2 && Ss(e2, n2, u2.locEnd) !== ":" || !(!n2 || !t2 || n2.type !== "Decorator" || t2.type !== "ClassMethod" && t2.type !== "ClassProperty" && t2.type !== "TSAbstractClassProperty" && t2.type !== "TSAbstractMethodDefinition" && t2.type !== "TSDeclareMethod" && t2.type !== "MethodDefinition")) && (ks(n2, r2), true);
      }
      function qs(e2, t2, n2, r2, u2, o2) {
        if (t2 && t2.type === "FunctionTypeParam" && n2 && n2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
          return ks(t2, u2), true;
        if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && n2 && zs(n2) && Ss(e2, u2, o2.locEnd) === ")")
          return ks(t2, u2), true;
        if (n2 && n2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
          const t3 = (() => {
            if ((n2.params || n2.parameters).length !== 0)
              return xs(e2, o2.locEnd(vs(n2.params || n2.parameters)));
            const t4 = xs(e2, o2.locEnd(n2.id));
            return t4 !== false && xs(e2, t4 + 1);
          })();
          if (o2.locStart(u2) > t3)
            return Ps(r2, u2), true;
        }
        return false;
      }
      function Vs(e2, t2) {
        return !(!e2 || e2.type !== "ImportSpecifier") && (Ts(e2, t2), true);
      }
      function Ws(e2, t2) {
        return !(!e2 || e2.type !== "LabeledStatement") && (Ts(e2, t2), true);
      }
      function $s(e2, t2, n2, r2) {
        return t2 && t2.body && t2.body.length === 0 ? (r2 ? Ns(t2, n2) : Ts(t2, n2), true) : !(!e2 || e2.type !== "Program" || e2.body.length !== 0 || !e2.directives || e2.directives.length !== 0) && (r2 ? Ns(e2, n2) : Ts(e2, n2), true);
      }
      function Us(e2) {
        return e2.type === "Block" || e2.type === "CommentBlock";
      }
      function zs(e2) {
        return e2.type === "ArrowFunctionExpression" || e2.type === "FunctionExpression" || e2.type === "FunctionDeclaration" || e2.type === "ObjectMethod" || e2.type === "ClassMethod" || e2.type === "TSDeclareFunction" || e2.type === "TSCallSignatureDeclaration" || e2.type === "TSConstructSignatureDeclaration" || e2.type === "TSConstructSignatureDeclaration" || e2.type === "TSMethodSignature" || e2.type === "TSConstructorType" || e2.type === "TSFunctionType" || e2.type === "TSDeclareMethod";
      }
      function Js(e2) {
        return Us(e2) && e2.value[0] === "*" && /@type\b/.test(e2.value);
      }
      var Gs = {handleOwnLineComment: function(e2, t2, n2, r2, u2) {
        const {precedingNode: o2, enclosingNode: a2, followingNode: i2} = e2;
        return qs(t2, o2, a2, i2, e2, n2) || function(e3, t3, n3) {
          if (e3 && (e3.type === "MemberExpression" || e3.type === "OptionalMemberExpression") && t3 && t3.type === "Identifier")
            return Ts(e3, n3), true;
          return false;
        }(a2, i2, e2) || Is(t2, o2, a2, i2, e2, n2) || js(t2, o2, a2, i2, e2, n2) || Ms(a2, o2, i2, e2) || Ls(a2, o2, i2, e2) || Vs(a2, e2) || function(e3, t3, n3) {
          if (e3 && (e3.type === "ForInStatement" || e3.type === "ForOfStatement"))
            return Ts(e3, n3), true;
          return false;
        }(a2, 0, e2) || function(e3, t3, n3, r3) {
          if (t3 && (t3.type === "UnionTypeAnnotation" || t3.type === "TSUnionType"))
            return Bs(r3) && (n3.prettierIgnore = true, r3.unignore = true), !!e3 && (ks(e3, r3), true);
          n3 && (n3.type === "UnionTypeAnnotation" || n3.type === "TSUnionType") && Bs(r3) && (n3.types[0].prettierIgnore = true, r3.unignore = true);
          return false;
        }(o2, a2, i2, e2) || $s(a2, r2, e2, u2) || function(e3, t3, n3, r3, u3) {
          if (n3 && n3.type === "ImportSpecifier" && t3 && t3.type === "ImportDeclaration" && Fs(e3, u3.locEnd(r3)))
            return ks(n3, r3), true;
          return false;
        }(t2, a2, o2, e2, n2) || function(e3, t3) {
          if (e3 && e3.type === "AssignmentPattern")
            return Ts(e3, t3), true;
          return false;
        }(a2, e2) || Rs(t2, a2, o2, e2, n2) || Ws(a2, e2);
      }, handleEndOfLineComment: function(e2, t2, n2, r2, u2) {
        const {precedingNode: o2, enclosingNode: a2, followingNode: i2} = e2;
        return function(e3, t3) {
          if (e3 && Js(t3))
            return Ts(e3, t3), true;
          return false;
        }(i2, e2) || qs(t2, o2, a2, i2, e2, n2) || function(e3, t3, n3, r3, u3, o3) {
          const a3 = t3 && !ws(u3, o3.locEnd(t3), o3.locStart(r3));
          if ((!t3 || !a3) && e3 && (e3.type === "ConditionalExpression" || e3.type === "TSConditionalType") && n3)
            return Ts(n3, r3), true;
          return false;
        }(a2, o2, i2, e2, t2, n2) || Vs(a2, e2) || Is(t2, o2, a2, i2, e2, n2) || js(t2, o2, a2, i2, e2, n2) || Ms(a2, o2, i2, e2) || Ls(a2, o2, i2, e2) || Ws(a2, e2) || function(e3, t3, n3) {
          if (t3 && (t3.type === "CallExpression" || t3.type === "OptionalCallExpression") && e3 && t3.callee === e3 && t3.arguments.length > 0)
            return Ts(t3.arguments[0], n3), true;
          return false;
        }(o2, a2, e2) || function(e3, t3) {
          if (e3 && (e3.type === "Property" || e3.type === "ObjectProperty"))
            return Ts(e3, t3), true;
          return false;
        }(a2, e2) || $s(a2, r2, e2, u2) || function(e3, t3, n3) {
          if (e3 && e3.type === "TypeAlias")
            return Ts(e3, n3), true;
          return false;
        }(a2, 0, e2) || function(e3, t3, n3) {
          if (e3 && (e3.type === "VariableDeclarator" || e3.type === "AssignmentExpression") && t3 && (t3.type === "ObjectExpression" || t3.type === "ArrayExpression" || t3.type === "TemplateLiteral" || t3.type === "TaggedTemplateExpression" || Us(n3)))
            return Ts(t3, n3), true;
          return false;
        }(a2, i2, e2);
      }, handleRemainingComment: function(e2, t2, n2, r2, u2) {
        const {precedingNode: o2, enclosingNode: a2, followingNode: i2} = e2;
        return !!(Is(t2, o2, a2, i2, e2, n2) || js(t2, o2, a2, i2, e2, n2) || function(e3, t3, n3) {
          if (e3 && (e3.type === "ObjectProperty" || e3.type === "Property") && e3.shorthand && e3.key === t3 && e3.value.type === "AssignmentPattern")
            return ks(e3.value.left, n3), true;
          return false;
        }(a2, o2, e2) || function(e3, t3, n3, r3) {
          if (Ss(e3, n3, r3.locEnd) !== ")")
            return false;
          if (t3 && (zs(t3) && (t3.params || t3.parameters).length === 0 || (t3.type === "CallExpression" || t3.type === "OptionalCallExpression" || t3.type === "NewExpression") && t3.arguments.length === 0))
            return Ns(t3, n3), true;
          if (t3 && t3.type === "MethodDefinition" && t3.value.params.length === 0)
            return Ns(t3.value, n3), true;
          return false;
        }(t2, a2, e2, n2) || Rs(t2, a2, o2, e2, n2) || $s(a2, r2, e2, u2) || function(e3, t3, n3, r3) {
          if (!t3 || t3.type !== "ArrowFunctionExpression")
            return false;
          const u3 = Os(e3, n3, r3.locEnd);
          if (u3 !== false && e3.slice(u3, u3 + 2) === "=>")
            return Ns(t3, n3), true;
          return false;
        }(t2, a2, e2, n2) || function(e3, t3, n3, r3, u3) {
          if (Ss(e3, r3, u3.locEnd) !== "(")
            return false;
          if (n3 && t3 && (t3.type === "FunctionDeclaration" || t3.type === "FunctionExpression" || t3.type === "ClassMethod" || t3.type === "MethodDefinition" || t3.type === "ObjectMethod"))
            return ks(n3, r3), true;
          return false;
        }(t2, a2, o2, e2, n2) || function(e3, t3, n3, r3, u3) {
          if (!t3 || t3.type !== "TSMappedType")
            return false;
          if (r3 && r3.type === "TSTypeParameter" && r3.name)
            return Ts(r3.name, u3), true;
          if (n3 && n3.type === "TSTypeParameter" && n3.constraint)
            return ks(n3.constraint, u3), true;
          return false;
        }(0, a2, o2, i2, e2) || function(e3, t3) {
          if (e3 && (e3.type === "ContinueStatement" || e3.type === "BreakStatement") && !e3.label)
            return ks(e3, t3), true;
          return false;
        }(a2, e2) || function(e3, t3, n3, r3, u3) {
          if (!n3 && t3 && (t3.type === "TSMethodSignature" || t3.type === "TSDeclareFunction" || t3.type === "TSAbstractMethodDefinition") && Ss(e3, r3, u3.locEnd) === ";")
            return ks(t3, r3), true;
          return false;
        }(t2, a2, i2, e2, n2));
      }, hasLeadingComment: function(e2, t2 = () => true) {
        return e2.leadingComments ? e2.leadingComments.some(t2) : !!e2.comments && e2.comments.some((e3) => e3.leading && t2(e3));
      }, isBlockComment: Us, isTypeCastComment: Js, getGapRegex: function(e2) {
        if (e2 && e2.type !== "BinaryExpression" && e2.type !== "LogicalExpression")
          return /^[\s&(|]*$/;
      }, getCommentChildNodes: function(e2, t2) {
        if ((t2.parser === "typescript" || t2.parser === "flow") && e2.type === "MethodDefinition" && e2.value && e2.value.type === "FunctionExpression" && e2.value.params.length === 0 && !e2.value.returnType && (!e2.value.typeParameters || e2.value.typeParameters.length === 0) && e2.value.body)
          return [...e2.decorators || [], e2.key, e2.value.body];
      }};
      const {builders: {indent: Hs, join: Xs, line: Ys, hardline: Ks, softline: Qs, literalline: Zs, concat: el, group: tl, dedentToRoot: nl}, utils: {mapDoc: rl, replaceNewlinesWithLiterallines: ul}} = dn, {isBlockComment: ol, hasLeadingComment: al} = Gs;
      function il(e2) {
        return e2.replace(/([\\`]|\${)/g, "\\$1");
      }
      function sl(e2, t2) {
        return rl(e2, (e3) => {
          if (!e3.parts)
            return e3;
          const n2 = e3.parts.map((e4) => typeof e4 == "string" ? t2 ? e4.replace(/(\\*)`/g, "$1$1\\`") : il(e4) : e4);
          return Object.assign({}, e3, {parts: n2});
        });
      }
      function ll(e2) {
        const t2 = [];
        let n2 = false;
        return e2.map((e3) => e3.trim()).forEach((e3, r2, u2) => {
          e3 !== "" && (u2[r2 - 1] === "" && n2 ? t2.push(el([Ks, e3])) : t2.push(e3), n2 = true);
        }), t2.length === 0 ? null : Xs(Ks, t2);
      }
      function cl(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode(), r2 = e2.getParentNode(1);
        return r2 && t2.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e3) => e3.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
      }
      function pl(e2) {
        return e2.match((e3) => e3.type === "TemplateLiteral", (e3, t2) => e3.type === "ArrayExpression" && t2 === "elements", (e3, t2) => (e3.type === "Property" || e3.type === "ObjectProperty") && e3.key.type === "Identifier" && e3.key.name === "styles" && t2 === "value", ...dl);
      }
      const dl = [(e2, t2) => e2.type === "ObjectExpression" && t2 === "properties", (e2, t2) => e2.type === "CallExpression" && e2.callee.type === "Identifier" && e2.callee.name === "Component" && t2 === "arguments", (e2, t2) => e2.type === "Decorator" && t2 === "expression"];
      function fl(e2) {
        const t2 = e2.getParentNode();
        if (!t2 || t2.type !== "TaggedTemplateExpression")
          return false;
        const {tag: n2} = t2;
        switch (n2.type) {
          case "MemberExpression":
            return ml(n2.object) || gl(n2);
          case "CallExpression":
            return ml(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (ml(n2.callee.object.object) || gl(n2.callee.object)) || n2.callee.object.type === "CallExpression" && ml(n2.callee.object.callee));
          case "Identifier":
            return n2.name === "css";
          default:
            return false;
        }
      }
      function hl(e2) {
        const t2 = e2.getParentNode(), n2 = e2.getParentNode(1);
        return n2 && t2.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
      }
      function ml(e2) {
        return e2.type === "Identifier" && e2.name === "styled";
      }
      function gl(e2) {
        return /^[A-Z]/.test(e2.object.name) && e2.property.name === "extend";
      }
      function Dl(e2, t2) {
        return al(e2, (e3) => ol(e3) && e3.value === " ".concat(t2, " "));
      }
      let yl = 0;
      var El = function(e2, t2, n2, r2) {
        const u2 = e2.getValue(), o2 = e2.getParentNode(), a2 = e2.getParentNode(1);
        switch (u2.type) {
          case "TemplateLiteral": {
            if ([cl, fl, hl, pl].some((t3) => t3(e2))) {
              const r3 = u2.quasis.map((e3) => e3.value.raw);
              let o4 = 0;
              const a3 = r3.reduce((e3, t3, n3) => n3 === 0 ? t3 : e3 + "@prettier-placeholder-" + o4++ + "-id" + t3, "");
              return function(e3, t3, n3) {
                const r4 = t3.getValue();
                if (r4.quasis.length === 1 && !r4.quasis[0].value.raw.trim())
                  return "``";
                const u3 = r4.expressions ? t3.map(n3, "expressions") : [], o5 = function(e4, t4) {
                  if (!t4 || !t4.length)
                    return e4;
                  let n4 = 0;
                  const r5 = rl(e4, (e5) => {
                    if (!e5 || !e5.parts || !e5.parts.length)
                      return e5;
                    let {parts: r6} = e5;
                    const u4 = r6.indexOf("@"), o6 = u4 + 1;
                    if (u4 > -1 && typeof r6[o6] == "string" && r6[o6].startsWith("prettier-placeholder")) {
                      const e6 = r6[u4], t5 = r6[o6], n5 = r6.slice(o6 + 1);
                      r6 = r6.slice(0, u4).concat([e6 + t5]).concat(n5);
                    }
                    const a4 = [];
                    return r6.forEach((e6) => {
                      typeof e6 == "string" && e6.includes("@prettier-placeholder") ? e6.split(/@prettier-placeholder-(\d+)-id/).forEach((e7, r7) => {
                        r7 % 2 != 0 ? (a4.push("${", t4[e7], "}"), n4++) : a4.push(ul(e7));
                      }) : a4.push(e6);
                    }), Object.assign({}, e5, {parts: a4});
                  });
                  return t4.length === n4 ? r5 : null;
                }(e3, u3);
                if (!o5)
                  throw new Error("Couldn't insert all the expressions");
                return el(["`", Hs(el([Ks, o5])), Qs, "`"]);
              }(n2(a3, {parser: "scss"}, {stripTrailingHardline: true}), e2, t2);
            }
            if (function(e3) {
              const t3 = e3.getValue(), n3 = e3.getParentNode();
              return Dl(t3, "GraphQL") || n3 && (n3.type === "TaggedTemplateExpression" && (n3.tag.type === "MemberExpression" && n3.tag.object.name === "graphql" && n3.tag.property.name === "experimental" || n3.tag.type === "Identifier" && (n3.tag.name === "gql" || n3.tag.name === "graphql")) || n3.type === "CallExpression" && n3.callee.type === "Identifier" && n3.callee.name === "graphql");
            }(e2)) {
              const r3 = u2.expressions ? e2.map(t2, "expressions") : [], o4 = u2.quasis.length;
              if (o4 === 1 && u2.quasis[0].value.raw.trim() === "")
                return "``";
              const a3 = [];
              for (let e3 = 0; e3 < o4; e3++) {
                const t3 = e3 === 0, i3 = e3 === o4 - 1, s2 = u2.quasis[e3].value.cooked;
                if (typeof s2 != "string")
                  return null;
                const l2 = s2.split("\n"), c2 = l2.length, p2 = r3[e3], d2 = c2 > 2 && l2[0].trim() === "" && l2[1].trim() === "", f2 = c2 > 2 && l2[c2 - 1].trim() === "" && l2[c2 - 2].trim() === "", h2 = l2.every((e4) => /^\s*(?:#[^\n\r]*)?$/.test(e4));
                if (!i3 && /#[^\n\r]*$/.test(l2[c2 - 1]))
                  return null;
                let m2 = null;
                m2 = h2 ? ll(l2) : n2(s2, {parser: "graphql"}, {stripTrailingHardline: true}), m2 ? (m2 = sl(m2, false), !t3 && d2 && a3.push(""), a3.push(m2), !i3 && f2 && a3.push("")) : t3 || i3 || !d2 || a3.push(""), p2 && a3.push(el(["${", p2, "}"]));
              }
              return el(["`", Hs(el([Ks, Xs(Ks, a3)])), Ks, "`"]);
            }
            const o3 = function(e3) {
              return Dl(e3.getValue(), "HTML") || e3.match((e4) => e4.type === "TemplateLiteral", (e4, t3) => e4.type === "TaggedTemplateExpression" && e4.tag.type === "Identifier" && e4.tag.name === "html" && t3 === "quasi");
            }(e2) ? "html" : function(e3) {
              return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t3) => (e4.type === "Property" || e4.type === "ObjectProperty") && e4.key.type === "Identifier" && e4.key.name === "template" && t3 === "value", ...dl);
            }(e2) ? "angular" : void 0;
            if (o3)
              return function(e3, t3, n3, r3, u3) {
                const o4 = e3.getValue(), a3 = yl;
                yl = yl + 1 >>> 0;
                const i3 = (e4) => "PRETTIER_HTML_PLACEHOLDER_".concat(e4, "_").concat(a3, "_IN_JS"), s2 = o4.quasis.map((e4, t4, n4) => t4 === n4.length - 1 ? e4.value.cooked : e4.value.cooked + i3(t4)).join(""), l2 = e3.map(t3, "expressions");
                if (l2.length === 0 && s2.trim().length === 0)
                  return "``";
                const c2 = new RegExp(i3("(\\d+)"), "g");
                let p2 = 0;
                const d2 = rl(n3(s2, {parser: r3, __onHtmlRoot(e4) {
                  p2 = e4.children.length;
                }}, {stripTrailingHardline: true}), (e4) => {
                  if (typeof e4 != "string")
                    return e4;
                  const t4 = [], n4 = e4.split(c2);
                  for (let e5 = 0; e5 < n4.length; e5++) {
                    let r4 = n4[e5];
                    if (e5 % 2 == 0) {
                      r4 && (r4 = il(r4), u3.embeddedInHtml && (r4 = r4.replace(/<\/(script)\b/gi, "<\\/$1")), t4.push(r4));
                      continue;
                    }
                    const o5 = +r4;
                    t4.push(el(["${", tl(l2[o5]), "}"]));
                  }
                  return el(t4);
                }), f2 = /^\s/.test(s2) ? " " : "", h2 = /\s$/.test(s2) ? " " : "", m2 = u3.htmlWhitespaceSensitivity === "ignore" ? Ks : f2 && h2 ? Ys : null;
                if (m2)
                  return tl(el(["`", Hs(el([m2, tl(d2)])), m2, "`"]));
                return tl(el(["`", f2, p2 > 1 ? Hs(tl(d2)) : tl(d2), h2, "`"]));
              }(e2, t2, n2, o3, r2);
            break;
          }
          case "TemplateElement":
            if (a2 && a2.type === "TaggedTemplateExpression" && o2.quasis.length === 1 && a2.tag.type === "Identifier" && (a2.tag.name === "md" || a2.tag.name === "markdown")) {
              const e3 = o2.quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e4, t4) => "\\".repeat(t4.length / 2) + "`"), t3 = function(e4) {
                const t4 = e4.match(/^([^\S\n]*)\S/m);
                return t4 === null ? "" : t4[1];
              }(e3);
              return el([t3 !== "" ? Hs(el([Qs, i2(e3.replace(new RegExp("^".concat(t3), "gm"), ""))])) : el([Zs, nl(i2(e3))]), Qs]);
            }
        }
        function i2(e3) {
          return sl(n2(e3, {parser: "markdown", __inJsTemplate: true}, {stripTrailingHardline: true}), true);
        }
      };
      var Cl = function(e2, t2, n2) {
        if (["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"].forEach((e3) => {
          delete t2[e3];
        }), e2.type === "Program" && delete t2.sourceType, e2.type === "BigIntLiteral" && (t2.value && (t2.value = t2.value.toLowerCase()), t2.bigint && (t2.bigint = t2.bigint.toLowerCase())), e2.type === "DecimalLiteral" && (t2.value = Number(t2.value)), e2.type === "EmptyStatement")
          return null;
        if (e2.type === "JSXText")
          return null;
        if (e2.type === "JSXExpressionContainer" && (e2.expression.type === "Literal" || e2.expression.type === "StringLiteral") && e2.expression.value === " ")
          return null;
        if (e2.type !== "Property" && e2.type !== "ObjectProperty" && e2.type !== "MethodDefinition" && e2.type !== "ClassProperty" && e2.type !== "ClassMethod" && e2.type !== "TSDeclareMethod" && e2.type !== "TSPropertySignature" && e2.type !== "ObjectTypeProperty" || typeof e2.key != "object" || !e2.key || e2.key.type !== "Literal" && e2.key.type !== "NumericLiteral" && e2.key.type !== "StringLiteral" && e2.key.type !== "Identifier" || delete t2.key, e2.type === "OptionalMemberExpression" && e2.optional === false && (t2.type = "MemberExpression", delete t2.optional), e2.type === "JSXElement" && e2.openingElement.name.name === "style" && e2.openingElement.attributes.some((e3) => e3.name.name === "jsx")) {
          t2.children.filter((e3) => e3.type === "JSXExpressionContainer" && e3.expression.type === "TemplateLiteral").map((e3) => e3.expression).reduce((e3, t3) => e3.concat(t3.quasis), []).forEach((e3) => delete e3.value);
        }
        e2.type === "JSXAttribute" && e2.name.name === "css" && e2.value.type === "JSXExpressionContainer" && e2.value.expression.type === "TemplateLiteral" && t2.value.expression.quasis.forEach((e3) => delete e3.value), e2.type === "JSXAttribute" && e2.value && e2.value.type === "Literal" && /["']|&quot;|&apos;/.test(e2.value.value) && (t2.value.value = t2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
        const r2 = e2.expression || e2.callee;
        if (e2.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
          const n3 = e2.expression.arguments[0].properties;
          t2.expression.arguments[0].properties.forEach((e3, t3) => {
            let r3 = null;
            switch (n3[t3].key.name) {
              case "styles":
                e3.value.type === "ArrayExpression" && (r3 = e3.value.elements[0]);
                break;
              case "template":
                e3.value.type === "TemplateLiteral" && (r3 = e3.value);
            }
            r3 && r3.quasis.forEach((e4) => delete e4.value);
          });
        }
        if (e2.type !== "TaggedTemplateExpression" || e2.tag.type !== "MemberExpression" && (e2.tag.type !== "Identifier" || e2.tag.name !== "gql" && e2.tag.name !== "graphql" && e2.tag.name !== "css" && e2.tag.name !== "md" && e2.tag.name !== "markdown" && e2.tag.name !== "html") && e2.tag.type !== "CallExpression" || t2.quasi.quasis.forEach((e3) => delete e3.value), e2.type === "TemplateLiteral") {
          (e2.leadingComments && e2.leadingComments.some((e3) => e3.type === "CommentBlock" && ["GraphQL", "HTML"].some((t3) => e3.value === " ".concat(t3, " "))) || n2.type === "CallExpression" && n2.callee.name === "graphql") && t2.quasis.forEach((e3) => delete e3.value), e2.leadingComments || t2.quasis.forEach((e3) => {
            e3.value && delete e3.value.cooked;
          });
        }
        e2.type === "InterpreterDirective" && (t2.value = t2.value.trimEnd());
      };
      const bl = (e2) => {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        const t2 = e2.match(/(?:\r?\n)/g) || [];
        if (t2.length === 0)
          return;
        const n2 = t2.filter((e3) => e3 === "\r\n").length;
        return n2 > t2.length - n2 ? "\r\n" : "\n";
      };
      var Al = bl;
      Al.graceful = (e2) => typeof e2 == "string" && bl(e2) || "\n";
      var vl = $e(function(e2, t2) {
        function n2() {
          const e3 = Rr;
          return n2 = function() {
            return e3;
          }, e3;
        }
        function r2() {
          const e3 = (t3 = Al) && t3.__esModule ? t3 : {default: t3};
          var t3;
          return r2 = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", {value: true}), t2.extract = function(e3) {
          const t3 = e3.match(a2);
          return t3 ? t3[0].trimLeft() : "";
        }, t2.strip = function(e3) {
          const t3 = e3.match(a2);
          return t3 && t3[0] ? e3.substring(t3[0].length) : e3;
        }, t2.parse = function(e3) {
          return f2(e3).pragmas;
        }, t2.parseWithComments = f2, t2.print = function({comments: e3 = "", pragmas: t3 = {}}) {
          const u3 = (0, r2().default)(e3) || n2().EOL, o3 = Object.keys(t3), a3 = o3.map((e4) => h2(e4, t3[e4])).reduce((e4, t4) => e4.concat(t4), []).map((e4) => " * " + e4 + u3).join("");
          if (!e3) {
            if (o3.length === 0)
              return "";
            if (o3.length === 1 && !Array.isArray(t3[o3[0]])) {
              const e4 = t3[o3[0]];
              return "".concat("/**", " ").concat(h2(o3[0], e4)[0]).concat(" */");
            }
          }
          const i3 = e3.split(u3).map((e4) => "".concat(" *", " ").concat(e4)).join(u3) + u3;
          return "/**" + u3 + (e3 ? i3 : "") + (e3 && o3.length ? " *" + u3 : "") + a3 + " */";
        };
        const u2 = /\*\/$/, o2 = /^\/\*\*/, a2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i2 = /(^|\s+)\/\/([^\r\n]*)/g, s2 = /^(\r?\n)+/, l2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, c2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p2 = /(\r?\n|^) *\* ?/g, d2 = [];
        function f2(e3) {
          const t3 = (0, r2().default)(e3) || n2().EOL;
          e3 = e3.replace(o2, "").replace(u2, "").replace(p2, "$1");
          let a3 = "";
          for (; a3 !== e3; )
            a3 = e3, e3 = e3.replace(l2, "".concat(t3, "$1 $2").concat(t3));
          e3 = e3.replace(s2, "").trimRight();
          const f3 = Object.create(null), h3 = e3.replace(c2, "").replace(s2, "").trimRight();
          let m2;
          for (; m2 = c2.exec(e3); ) {
            const e4 = m2[2].replace(i2, "");
            typeof f3[m2[1]] == "string" || Array.isArray(f3[m2[1]]) ? f3[m2[1]] = d2.concat(f3[m2[1]], e4) : f3[m2[1]] = e4;
          }
          return {comments: h3, pragmas: f3};
        }
        function h2(e3, t3) {
          return d2.concat(t3).map((t4) => "@".concat(e3, " ").concat(t4).trim());
        }
      });
      const {parseWithComments: Fl, strip: xl, extract: Sl, print: wl} = vl, {getShebang: Bl} = Lt, {normalizeEndOfLine: Tl} = Rt;
      function kl(e2) {
        const t2 = Bl(e2);
        t2 && (e2 = e2.slice(t2.length + 1));
        const n2 = Sl(e2), {pragmas: r2, comments: u2} = Fl(n2);
        return {shebang: t2, text: e2, pragmas: r2, comments: u2};
      }
      var Nl = {hasPragma: function(e2) {
        const t2 = Object.keys(kl(e2).pragmas);
        return t2.includes("prettier") || t2.includes("format");
      }, insertPragma: function(e2) {
        const {shebang: t2, text: n2, pragmas: r2, comments: u2} = kl(e2), o2 = xl(n2), a2 = wl({pragmas: Object.assign({format: ""}, r2), comments: u2.trimStart()});
        return (t2 ? "".concat(t2, "\n") : "") + Tl(a2) + (o2.startsWith("\n") ? "\n" : "\n\n") + o2;
      }}, Ol = $e(function(e2) {
        !function() {
          function t2(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "BlockStatement":
              case "BreakStatement":
              case "ContinueStatement":
              case "DebuggerStatement":
              case "DoWhileStatement":
              case "EmptyStatement":
              case "ExpressionStatement":
              case "ForInStatement":
              case "ForStatement":
              case "IfStatement":
              case "LabeledStatement":
              case "ReturnStatement":
              case "SwitchStatement":
              case "ThrowStatement":
              case "TryStatement":
              case "VariableDeclaration":
              case "WhileStatement":
              case "WithStatement":
                return true;
            }
            return false;
          }
          function n2(e3) {
            switch (e3.type) {
              case "IfStatement":
                return e3.alternate != null ? e3.alternate : e3.consequent;
              case "LabeledStatement":
              case "ForStatement":
              case "ForInStatement":
              case "WhileStatement":
              case "WithStatement":
                return e3.body;
            }
            return null;
          }
          e2.exports = {isExpression: function(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "ArrayExpression":
              case "AssignmentExpression":
              case "BinaryExpression":
              case "CallExpression":
              case "ConditionalExpression":
              case "FunctionExpression":
              case "Identifier":
              case "Literal":
              case "LogicalExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ObjectExpression":
              case "SequenceExpression":
              case "ThisExpression":
              case "UnaryExpression":
              case "UpdateExpression":
                return true;
            }
            return false;
          }, isStatement: t2, isIterationStatement: function(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "DoWhileStatement":
              case "ForInStatement":
              case "ForStatement":
              case "WhileStatement":
                return true;
            }
            return false;
          }, isSourceElement: function(e3) {
            return t2(e3) || e3 != null && e3.type === "FunctionDeclaration";
          }, isProblematicIfStatement: function(e3) {
            var t3;
            if (e3.type !== "IfStatement")
              return false;
            if (e3.alternate == null)
              return false;
            t3 = e3.consequent;
            do {
              if (t3.type === "IfStatement" && t3.alternate == null)
                return true;
              t3 = n2(t3);
            } while (t3);
            return false;
          }, trailingStatement: n2};
        }();
      }), Pl = $e(function(e2) {
        !function() {
          var t2, n2, r2, u2, o2, a2;
          function i2(e3) {
            return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode(Math.floor((e3 - 65536) / 1024) + 55296) + String.fromCharCode((e3 - 65536) % 1024 + 56320);
          }
          for (n2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/}, t2 = {NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/}, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], u2 = new Array(128), a2 = 0; a2 < 128; ++a2)
            u2[a2] = a2 >= 97 && a2 <= 122 || a2 >= 65 && a2 <= 90 || a2 === 36 || a2 === 95;
          for (o2 = new Array(128), a2 = 0; a2 < 128; ++a2)
            o2[a2] = a2 >= 97 && a2 <= 122 || a2 >= 65 && a2 <= 90 || a2 >= 48 && a2 <= 57 || a2 === 36 || a2 === 95;
          e2.exports = {isDecimalDigit: function(e3) {
            return 48 <= e3 && e3 <= 57;
          }, isHexDigit: function(e3) {
            return 48 <= e3 && e3 <= 57 || 97 <= e3 && e3 <= 102 || 65 <= e3 && e3 <= 70;
          }, isOctalDigit: function(e3) {
            return e3 >= 48 && e3 <= 55;
          }, isWhiteSpace: function(e3) {
            return e3 === 32 || e3 === 9 || e3 === 11 || e3 === 12 || e3 === 160 || e3 >= 5760 && r2.indexOf(e3) >= 0;
          }, isLineTerminator: function(e3) {
            return e3 === 10 || e3 === 13 || e3 === 8232 || e3 === 8233;
          }, isIdentifierStartES5: function(e3) {
            return e3 < 128 ? u2[e3] : n2.NonAsciiIdentifierStart.test(i2(e3));
          }, isIdentifierPartES5: function(e3) {
            return e3 < 128 ? o2[e3] : n2.NonAsciiIdentifierPart.test(i2(e3));
          }, isIdentifierStartES6: function(e3) {
            return e3 < 128 ? u2[e3] : t2.NonAsciiIdentifierStart.test(i2(e3));
          }, isIdentifierPartES6: function(e3) {
            return e3 < 128 ? o2[e3] : t2.NonAsciiIdentifierPart.test(i2(e3));
          }};
        }();
      }), _l = $e(function(e2) {
        !function() {
          var t2 = Pl;
          function n2(e3, t3) {
            return !(!t3 && e3 === "yield") && r2(e3, t3);
          }
          function r2(e3, t3) {
            if (t3 && function(e4) {
              switch (e4) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }(e3))
              return true;
            switch (e3.length) {
              case 2:
                return e3 === "if" || e3 === "in" || e3 === "do";
              case 3:
                return e3 === "var" || e3 === "for" || e3 === "new" || e3 === "try";
              case 4:
                return e3 === "this" || e3 === "else" || e3 === "case" || e3 === "void" || e3 === "with" || e3 === "enum";
              case 5:
                return e3 === "while" || e3 === "break" || e3 === "catch" || e3 === "throw" || e3 === "const" || e3 === "yield" || e3 === "class" || e3 === "super";
              case 6:
                return e3 === "return" || e3 === "typeof" || e3 === "delete" || e3 === "switch" || e3 === "export" || e3 === "import";
              case 7:
                return e3 === "default" || e3 === "finally" || e3 === "extends";
              case 8:
                return e3 === "function" || e3 === "continue" || e3 === "debugger";
              case 10:
                return e3 === "instanceof";
              default:
                return false;
            }
          }
          function u2(e3, t3) {
            return e3 === "null" || e3 === "true" || e3 === "false" || n2(e3, t3);
          }
          function o2(e3, t3) {
            return e3 === "null" || e3 === "true" || e3 === "false" || r2(e3, t3);
          }
          function a2(e3) {
            var n3, r3, u3;
            if (e3.length === 0)
              return false;
            if (u3 = e3.charCodeAt(0), !t2.isIdentifierStartES5(u3))
              return false;
            for (n3 = 1, r3 = e3.length; n3 < r3; ++n3)
              if (u3 = e3.charCodeAt(n3), !t2.isIdentifierPartES5(u3))
                return false;
            return true;
          }
          function i2(e3) {
            var n3, r3, u3, o3, a3;
            if (e3.length === 0)
              return false;
            for (a3 = t2.isIdentifierStartES6, n3 = 0, r3 = e3.length; n3 < r3; ++n3) {
              if (55296 <= (u3 = e3.charCodeAt(n3)) && u3 <= 56319) {
                if (++n3 >= r3)
                  return false;
                if (!(56320 <= (o3 = e3.charCodeAt(n3)) && o3 <= 57343))
                  return false;
                u3 = 1024 * (u3 - 55296) + (o3 - 56320) + 65536;
              }
              if (!a3(u3))
                return false;
              a3 = t2.isIdentifierPartES6;
            }
            return true;
          }
          e2.exports = {isKeywordES5: n2, isKeywordES6: r2, isReservedWordES5: u2, isReservedWordES6: o2, isRestrictedWord: function(e3) {
            return e3 === "eval" || e3 === "arguments";
          }, isIdentifierNameES5: a2, isIdentifierNameES6: i2, isIdentifierES5: function(e3, t3) {
            return a2(e3) && !u2(e3, t3);
          }, isIdentifierES6: function(e3, t3) {
            return i2(e3) && !o2(e3, t3);
          }};
        }();
      });
      const Il = $e(function(e2, t2) {
        t2.ast = Ol, t2.code = Pl, t2.keyword = _l;
      }).keyword.isIdentifierNameES5, {getLast: jl, hasNewline: Ml, hasNewlineInRange: Ll, hasIgnoreComment: Rl, hasNodeIgnoreComment: ql, skipWhitespace: Vl} = Lt, Wl = new RegExp("^".concat("(?:(?=.)\\s)", "*:")), $l = new RegExp("^".concat("(?:(?=.)\\s)", "*::"));
      function Ul(e2, t2) {
        if (!e2 || typeof e2 != "object")
          return false;
        if (Array.isArray(e2))
          return e2.some((e3) => Ul(e3, t2));
        const n2 = t2(e2);
        return typeof n2 == "boolean" ? n2 : Object.keys(e2).some((n3) => Ul(e2[n3], t2));
      }
      function zl(e2) {
        return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || e2.type === "CallExpression" || e2.type === "OptionalCallExpression" || e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression" || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || e2.type === "TSAsExpression" || e2.type === "TSNonNullExpression";
      }
      const Jl = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
      function Gl(e2) {
        return e2 && Jl.has(e2.type);
      }
      function Hl(e2) {
        return e2.type === "BooleanLiteral" || e2.type === "DirectiveLiteral" || e2.type === "Literal" || e2.type === "NullLiteral" || e2.type === "NumericLiteral" || e2.type === "BigIntLiteral" || e2.type === "DecimalLiteral" || e2.type === "RegExpLiteral" || e2.type === "StringLiteral" || e2.type === "TemplateLiteral" || e2.type === "TSTypeLiteral" || e2.type === "JSXText";
      }
      function Xl(e2) {
        return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
      }
      function Yl(e2) {
        return e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string";
      }
      function Kl(e2) {
        return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression";
      }
      function Ql(e2) {
        return !(e2.type !== "CallExpression" && e2.type !== "OptionalCallExpression" || e2.callee.type !== "Identifier" || e2.callee.name !== "async" && e2.callee.name !== "inject" && e2.callee.name !== "fakeAsync");
      }
      function Zl(e2) {
        return e2.type === "JSXElement" || e2.type === "JSXFragment";
      }
      function ec(e2) {
        return e2.kind === "get" || e2.kind === "set";
      }
      function tc(e2, t2, n2) {
        return n2.locStart(e2) === n2.locStart(t2);
      }
      function nc(e2, t2) {
        return ec(e2) || tc(e2, e2.value, t2);
      }
      const rc = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
      const uc = new Set(["AnyTypeAnnotation", "NullLiteralTypeAnnotation", "GenericTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation", "BooleanTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringTypeAnnotation"]);
      const oc = /^(skip|[fx]?(it|describe|test))$/;
      function ac(e2) {
        return e2.type === "CallExpression" || e2.type === "OptionalCallExpression";
      }
      const ic = new RegExp("([ \n\r	]+)"), sc = new RegExp("[^ \n\r	]");
      function lc(e2) {
        return Hl(e2) && (sc.test(fc(e2)) || !/\n/.test(fc(e2)));
      }
      function cc(e2, t2, n2) {
        if (Zl(t2))
          return ql(t2);
        return t2.comments && t2.comments.some((t3) => t3.leading && Ml(e2, n2.locEnd(t3)));
      }
      function pc(e2) {
        return /^(\d+|\d+\.\d+)$/.test(e2);
      }
      function dc(e2) {
        return e2.quasis.some((e3) => e3.value.raw.includes("\n"));
      }
      function fc(e2) {
        return e2.extra ? e2.extra.raw : e2.raw;
      }
      const hc = {"==": true, "!=": true, "===": true, "!==": true}, mc = {"*": true, "/": true, "%": true}, gc = {">>": true, ">>>": true, "<<": true};
      const Dc = {};
      function yc(e2) {
        return Dc[e2];
      }
      [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].forEach((e2, t2) => {
        e2.forEach((e3) => {
          Dc[e3] = t2;
        });
      });
      var Ec = {classChildNeedsASIProtection: function(e2) {
        if (e2) {
          if (e2.static || e2.accessibility)
            return false;
          if (!e2.computed) {
            const t2 = e2.key && e2.key.name;
            if (t2 === "in" || t2 === "instanceof")
              return true;
          }
          switch (e2.type) {
            case "ClassProperty":
            case "TSAbstractClassProperty":
              return e2.computed;
            case "MethodDefinition":
            case "TSAbstractMethodDefinition":
            case "ClassMethod":
            case "ClassPrivateMethod": {
              const t2 = e2.value ? e2.value.async : e2.async, n2 = e2.value ? e2.value.generator : e2.generator;
              return !t2 && e2.kind !== "get" && e2.kind !== "set" && !(!e2.computed && !n2);
            }
            case "TSIndexSignature":
              return true;
            default:
              return false;
          }
        }
      }, classPropMayCauseASIProblems: function(e2) {
        const t2 = e2.getNode();
        if (t2.type !== "ClassProperty")
          return false;
        const n2 = t2.key && t2.key.name;
        return !(n2 !== "static" && n2 !== "get" && n2 !== "set" || t2.value || t2.typeAnnotation) || void 0;
      }, getFlowVariance: function(e2) {
        if (!e2.variance)
          return null;
        const t2 = e2.variance.kind || e2.variance;
        switch (t2) {
          case "plus":
            return "+";
          case "minus":
            return "-";
          default:
            return t2;
        }
      }, getLeftSidePathName: function(e2, t2) {
        if (t2.expressions)
          return ["expressions", 0];
        if (t2.left)
          return ["left"];
        if (t2.test)
          return ["test"];
        if (t2.object)
          return ["object"];
        if (t2.callee)
          return ["callee"];
        if (t2.tag)
          return ["tag"];
        if (t2.argument)
          return ["argument"];
        if (t2.expression)
          return ["expression"];
        throw new Error("Unexpected node has no left side.");
      }, getParentExportDeclaration: function(e2) {
        const t2 = e2.getParentNode();
        return e2.getName() === "declaration" && Gl(t2) ? t2 : null;
      }, getTypeScriptMappedTypeModifier: function(e2, t2) {
        return e2 === "+" ? "+" + t2 : e2 === "-" ? "-" + t2 : t2;
      }, hasDanglingComments: function(e2) {
        return e2.comments && e2.comments.some((e3) => !e3.leading && !e3.trailing);
      }, hasFlowAnnotationComment: function(e2) {
        return e2 && $l.test(e2[0].value);
      }, hasFlowShorthandAnnotationComment: function(e2) {
        return e2.extra && e2.extra.parenthesized && e2.trailingComments && Wl.test(e2.trailingComments[0].value);
      }, hasLeadingComment: function(e2) {
        return e2.comments && e2.comments.some((e3) => e3.leading);
      }, hasLeadingOwnLineComment: cc, hasNakedLeftSide: zl, hasNewlineBetweenOrAfterDecorators: function(e2, t2) {
        return Ll(t2.originalText, t2.locStart(e2.decorators[0]), t2.locEnd(jl(e2.decorators))) || Ml(t2.originalText, t2.locEnd(jl(e2.decorators)));
      }, hasNgSideEffect: function(e2) {
        return Ul(e2.getValue(), (e3) => {
          switch (e3.type) {
            case void 0:
              return false;
            case "CallExpression":
            case "OptionalCallExpression":
            case "AssignmentExpression":
              return true;
          }
        });
      }, hasNode: Ul, hasPrettierIgnore: function(e2) {
        return Rl(e2) || function(e3) {
          const t2 = e3.getValue(), n2 = e3.getParentNode();
          if (!(n2 && t2 && Zl(t2) && Zl(n2)))
            return false;
          let r2 = null;
          for (let e4 = n2.children.indexOf(t2); e4 > 0; e4--) {
            const t3 = n2.children[e4 - 1];
            if (t3.type !== "JSXText" || lc(t3)) {
              r2 = t3;
              break;
            }
          }
          return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && r2.expression.comments && r2.expression.comments.some((e4) => e4.value.trim() === "prettier-ignore");
        }(e2);
      }, hasTrailingComment: function(e2) {
        return e2.comments && e2.comments.some((e3) => e3.trailing);
      }, hasTrailingLineComment: function(e2) {
        return e2.comments && e2.comments.some((e3) => e3.trailing && !Gs.isBlockComment(e3));
      }, identity: function(e2) {
        return e2;
      }, isBinaryish: function(e2) {
        return rc.has(e2.type);
      }, isCallOrOptionalCallExpression: ac, isEmptyJSXElement: function(e2) {
        if (e2.children.length === 0)
          return true;
        if (e2.children.length > 1)
          return false;
        const t2 = e2.children[0];
        return Hl(t2) && !lc(t2);
      }, isExportDeclaration: Gl, isFlowAnnotationComment: function(e2, t2, n2) {
        const r2 = n2.locStart(t2), u2 = Vl(e2, n2.locEnd(t2));
        return u2 !== false && e2.slice(r2, r2 + 2) === "/*" && e2.slice(u2, u2 + 2) === "*/";
      }, isFunctionCompositionArgs: function(e2) {
        if (e2.length <= 1)
          return false;
        let t2 = 0;
        for (const n2 of e2)
          if (Kl(n2)) {
            if (t2 += 1, t2 > 1)
              return true;
          } else if (ac(n2)) {
            for (const e3 of n2.arguments)
              if (Kl(e3))
                return true;
          }
        return false;
      }, isFunctionNotation: nc, isFunctionOrArrowExpression: Kl, isGetterOrSetter: ec, isJestEachTemplateLiteral: function(e2, t2) {
        const n2 = /^[fx]?(describe|it|test)$/;
        return t2.type === "TaggedTemplateExpression" && t2.quasi === e2 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && n2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && n2.test(t2.tag.object.object.name));
      }, isJSXNode: Zl, isJSXWhitespaceExpression: function(e2) {
        return e2.type === "JSXExpressionContainer" && Hl(e2.expression) && e2.expression.value === " " && !e2.expression.comments;
      }, isLastStatement: function(e2) {
        const t2 = e2.getParentNode();
        if (!t2)
          return true;
        const n2 = e2.getValue(), r2 = (t2.body || t2.consequent).filter((e3) => e3.type !== "EmptyStatement");
        return r2[r2.length - 1] === n2;
      }, isLiteral: Hl, isLongCurriedCallExpression: function(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode();
        return ac(t2) && ac(n2) && n2.callee === t2 && t2.arguments.length > n2.arguments.length && n2.arguments.length > 0;
      }, isSimpleCallArgument: function e2(t2, n2) {
        if (n2 >= 2)
          return false;
        const r2 = (t3) => e2(t3, n2 + 1), u2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
        return !(u2 && u2.length > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e3) => !e3.computed && (e3.shorthand || e3.value && r2(e3.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e3) => e3 === null || r2(e3)) : t2.type === "ImportExpression" ? r2(t2.source) : t2.type === "CallExpression" || t2.type === "OptionalCallExpression" || t2.type === "NewExpression" ? e2(t2.callee, n2) && t2.arguments.every(r2) : t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression" ? e2(t2.object, n2) && e2(t2.property, n2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e2(t2.expression, n2) : e2(t2.argument, n2)));
      }, isMeaningfulJSXText: lc, isMemberExpressionChain: function e2(t2) {
        return (t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression") && (t2.object.type === "Identifier" || e2(t2.object));
      }, isMemberish: function(e2) {
        return e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression" || e2.type === "BindExpression" && Boolean(e2.object);
      }, isNgForOf: function(e2, t2, n2) {
        return e2.type === "NGMicrosyntaxKeyedExpression" && e2.key.name === "of" && t2 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
      }, isNumericLiteral: Xl, isObjectType: function(e2) {
        return e2.type === "ObjectTypeAnnotation" || e2.type === "TSTypeLiteral";
      }, isObjectTypePropertyAFunction: function(e2, t2) {
        return !(e2.type !== "ObjectTypeProperty" && e2.type !== "ObjectTypeInternalSlot" || e2.value.type !== "FunctionTypeAnnotation" || e2.static || nc(e2, t2));
      }, isSimpleFlowType: function(e2) {
        return e2 && uc.has(e2.type) && !(e2.type === "GenericTypeAnnotation" && e2.typeParameters);
      }, isSimpleNumber: pc, isSimpleTemplateLiteral: function(e2) {
        return e2.expressions.length !== 0 && e2.expressions.every((e3) => {
          if (e3.comments)
            return false;
          if (e3.type === "Identifier" || e3.type === "ThisExpression")
            return true;
          if (e3.type === "MemberExpression" || e3.type === "OptionalMemberExpression") {
            let t2 = e3;
            for (; t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression"; ) {
              if (t2.property.type !== "Identifier" && t2.property.type !== "Literal" && t2.property.type !== "StringLiteral" && t2.property.type !== "NumericLiteral")
                return false;
              if (t2 = t2.object, t2.comments)
                return false;
            }
            return t2.type === "Identifier" || t2.type === "ThisExpression";
          }
          return false;
        });
      }, isStringLiteral: Yl, isStringPropSafeToUnquote: function(e2, t2) {
        return t2.parser !== "json" && Yl(e2.key) && fc(e2.key).slice(1, -1) === e2.key.value && (Il(e2.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e2.type === "ClassProperty") || pc(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && t2.parser === "babel");
      }, isTemplateOnItsOwnLine: function(e2, t2, n2) {
        return (e2.type === "TemplateLiteral" && dc(e2) || e2.type === "TaggedTemplateExpression" && dc(e2.quasi)) && !Ml(t2, n2.locStart(e2), {backwards: true});
      }, isTestCall: function e2(t2, n2) {
        if (t2.type !== "CallExpression")
          return false;
        if (t2.arguments.length === 1) {
          if (Ql(t2) && n2 && e2(n2))
            return Kl(t2.arguments[0]);
          if ((r2 = t2).callee.type === "Identifier" && /^(before|after)(Each|All)$/.test(r2.callee.name) && r2.arguments.length === 1)
            return Ql(t2.arguments[0]);
        } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && oc.test(t2.callee.name) || function(e3) {
          return (e3.callee.type === "MemberExpression" || e3.callee.type === "OptionalMemberExpression") && e3.callee.object.type === "Identifier" && e3.callee.property.type === "Identifier" && oc.test(e3.callee.object.name) && (e3.callee.property.name === "only" || e3.callee.property.name === "skip");
        }(t2)) && (function(e3) {
          return e3.type === "TemplateLiteral";
        }(t2.arguments[0]) || Yl(t2.arguments[0])))
          return !(t2.arguments[2] && !Xl(t2.arguments[2])) && ((t2.arguments.length === 2 ? Kl(t2.arguments[1]) : function(e3) {
            return e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression" && e3.body.type === "BlockStatement";
          }(t2.arguments[1]) && t2.arguments[1].params.length <= 1) || Ql(t2.arguments[1]));
        var r2;
        return false;
      }, isTheOnlyJSXElementInMarkdown: function(e2, t2) {
        if (e2.parentParser !== "markdown" && e2.parentParser !== "mdx")
          return false;
        const n2 = t2.getNode();
        if (!n2.expression || !Zl(n2.expression))
          return false;
        const r2 = t2.getParentNode();
        return r2.type === "Program" && r2.body.length === 1;
      }, isTSXFile: function(e2) {
        return e2.filepath && /\.tsx$/i.test(e2.filepath);
      }, isTypeAnnotationAFunction: function(e2, t2) {
        return !(e2.type !== "TypeAnnotation" && e2.type !== "TSTypeAnnotation" || e2.typeAnnotation.type !== "FunctionTypeAnnotation" || e2.static || tc(e2, e2.typeAnnotation, t2));
      }, matchJsxWhitespaceRegex: ic, needsHardlineAfterDanglingComment: function(e2) {
        if (!e2.comments)
          return false;
        const t2 = jl(e2.comments.filter((e3) => !e3.leading && !e3.trailing));
        return t2 && !Gs.isBlockComment(t2);
      }, rawText: fc, returnArgumentHasLeadingComment: function(e2, t2) {
        if (cc(e2.originalText, t2, e2))
          return true;
        if (zl(t2)) {
          let r2, u2 = t2;
          for (; r2 = (n2 = u2).expressions ? n2.expressions[0] : n2.left || n2.test || n2.callee || n2.object || n2.tag || n2.argument || n2.expression; )
            if (u2 = r2, cc(e2.originalText, u2, e2))
              return true;
        }
        var n2;
        return false;
      }, shouldPrintComma: function(e2, t2 = "es5") {
        return e2.trailingComma === "es5" && t2 === "es5" || e2.trailingComma === "all" && (t2 === "all" || t2 === "es5");
      }, isBitwiseOperator: function(e2) {
        return !!gc[e2] || e2 === "|" || e2 === "^" || e2 === "&";
      }, shouldFlatten: function(e2, t2) {
        return yc(t2) === yc(e2) && (e2 !== "**" && ((!hc[e2] || !hc[t2]) && (!(t2 === "%" && mc[e2] || e2 === "%" && mc[t2]) && ((t2 === e2 || !mc[t2] || !mc[e2]) && (!gc[e2] || !gc[t2])))));
      }, startsWithNoLookaheadToken: function e2(t2, n2) {
        switch ((t2 = function(e3) {
          for (; e3.left; )
            e3 = e3.left;
          return e3;
        }(t2)).type) {
          case "FunctionExpression":
          case "ClassExpression":
          case "DoExpression":
            return n2;
          case "ObjectExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return e2(t2.object, n2);
          case "TaggedTemplateExpression":
            return t2.tag.type !== "FunctionExpression" && e2(t2.tag, n2);
          case "CallExpression":
          case "OptionalCallExpression":
            return t2.callee.type !== "FunctionExpression" && e2(t2.callee, n2);
          case "ConditionalExpression":
            return e2(t2.test, n2);
          case "UpdateExpression":
            return !t2.prefix && e2(t2.argument, n2);
          case "BindExpression":
            return t2.object && e2(t2.object, n2);
          case "SequenceExpression":
            return e2(t2.expressions[0], n2);
          case "TSAsExpression":
            return e2(t2.expression, n2);
          default:
            return false;
        }
      }, getPrecedence: yc};
      const {getLeftSidePathName: Cc, hasFlowShorthandAnnotationComment: bc, hasNakedLeftSide: Ac, hasNode: vc, isBitwiseOperator: Fc, startsWithNoLookaheadToken: xc, shouldFlatten: Sc, getPrecedence: wc} = Ec;
      function Bc(e2, t2) {
        const n2 = e2.getParentNode();
        if (!n2)
          return false;
        const r2 = e2.getName(), u2 = e2.getNode();
        if (e2.getValue() !== u2)
          return false;
        if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && function(e3) {
          switch (e3.type) {
            case "ObjectExpression":
              return true;
            default:
              return false;
          }
        }(u2) && Tc(e2))
          return true;
        if (function(e3) {
          return e3.type === "BlockStatement" || e3.type === "BreakStatement" || e3.type === "ClassBody" || e3.type === "ClassDeclaration" || e3.type === "ClassMethod" || e3.type === "ClassProperty" || e3.type === "ClassPrivateProperty" || e3.type === "ContinueStatement" || e3.type === "DebuggerStatement" || e3.type === "DeclareClass" || e3.type === "DeclareExportAllDeclaration" || e3.type === "DeclareExportDeclaration" || e3.type === "DeclareFunction" || e3.type === "DeclareInterface" || e3.type === "DeclareModule" || e3.type === "DeclareModuleExports" || e3.type === "DeclareVariable" || e3.type === "DoWhileStatement" || e3.type === "EnumDeclaration" || e3.type === "ExportAllDeclaration" || e3.type === "ExportDefaultDeclaration" || e3.type === "ExportNamedDeclaration" || e3.type === "ExpressionStatement" || e3.type === "ForInStatement" || e3.type === "ForOfStatement" || e3.type === "ForStatement" || e3.type === "FunctionDeclaration" || e3.type === "IfStatement" || e3.type === "ImportDeclaration" || e3.type === "InterfaceDeclaration" || e3.type === "LabeledStatement" || e3.type === "MethodDefinition" || e3.type === "ReturnStatement" || e3.type === "SwitchStatement" || e3.type === "ThrowStatement" || e3.type === "TryStatement" || e3.type === "TSDeclareFunction" || e3.type === "TSEnumDeclaration" || e3.type === "TSImportEqualsDeclaration" || e3.type === "TSInterfaceDeclaration" || e3.type === "TSModuleDeclaration" || e3.type === "TSNamespaceExportDeclaration" || e3.type === "TypeAlias" || e3.type === "VariableDeclaration" || e3.type === "WhileStatement" || e3.type === "WithStatement";
        }(u2))
          return false;
        if (t2.parser !== "flow" && bc(e2.getValue()))
          return true;
        if (u2.type === "Identifier")
          return !!(u2.extra && u2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(u2.name));
        if (n2.type === "ParenthesizedExpression")
          return false;
        if (!(n2.type !== "ClassDeclaration" && n2.type !== "ClassExpression" || n2.superClass !== u2 || u2.type !== "ArrowFunctionExpression" && u2.type !== "AssignmentExpression" && u2.type !== "AwaitExpression" && u2.type !== "BinaryExpression" && u2.type !== "ConditionalExpression" && u2.type !== "LogicalExpression" && u2.type !== "NewExpression" && u2.type !== "ObjectExpression" && u2.type !== "ParenthesizedExpression" && u2.type !== "SequenceExpression" && u2.type !== "TaggedTemplateExpression" && u2.type !== "UnaryExpression" && u2.type !== "UpdateExpression" && u2.type !== "YieldExpression"))
          return true;
        if (n2.type === "ExportDefaultDeclaration")
          return function e3(t3, n3) {
            const r3 = t3.getValue(), u3 = t3.getParentNode();
            if (r3.type === "FunctionExpression" || r3.type === "ClassExpression")
              return u3.type === "ExportDefaultDeclaration" || !Bc(t3, n3);
            if (!Ac(r3) || u3.type !== "ExportDefaultDeclaration" && Bc(t3, n3))
              return false;
            return t3.call((t4) => e3(t4, n3), ...Cc(t3, r3));
          }(e2, t2) || u2.type === "SequenceExpression";
        if (n2.type === "Decorator" && n2.expression === u2) {
          let e3 = false, t3 = false, n3 = u2;
          for (; n3; )
            switch (n3.type) {
              case "MemberExpression":
                t3 = true, n3 = n3.object;
                break;
              case "CallExpression":
                if (t3 || e3)
                  return true;
                e3 = true, n3 = n3.callee;
                break;
              case "Identifier":
                return false;
              default:
                return true;
            }
          return true;
        }
        if (n2.type === "ArrowFunctionExpression" && n2.body === u2 && u2.type !== "SequenceExpression" && xc(u2, false) || n2.type === "ExpressionStatement" && xc(u2, true))
          return true;
        switch (u2.type) {
          case "SpreadElement":
          case "SpreadProperty":
            return n2.type === "MemberExpression" && r2 === "object" && n2.object === u2;
          case "UpdateExpression":
            if (n2.type === "UnaryExpression")
              return u2.prefix && (u2.operator === "++" && n2.operator === "+" || u2.operator === "--" && n2.operator === "-");
          case "UnaryExpression":
            switch (n2.type) {
              case "UnaryExpression":
                return u2.operator === n2.operator && (u2.operator === "+" || u2.operator === "-");
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "TaggedTemplateExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "BinaryExpression":
                return n2.operator === "**" && r2 === "left";
              case "TSNonNullExpression":
                return true;
              default:
                return false;
            }
          case "BinaryExpression": {
            if (n2.type === "UpdateExpression" || n2.type === "PipelineTopicExpression" && u2.operator === "|>")
              return true;
            const t3 = (t4) => {
              let n3 = 0;
              for (; t4; ) {
                const r3 = e2.getParentNode(n3++);
                if (!r3)
                  return false;
                if (r3.type === "ForStatement" && r3.init === t4)
                  return true;
                t4 = r3;
              }
              return false;
            };
            if (u2.operator === "in" && t3(u2))
              return true;
            if (u2.operator === "|>" && u2.extra && u2.extra.parenthesized) {
              const t4 = e2.getParentNode(1);
              if (t4.type === "BinaryExpression" && t4.operator === "|>")
                return true;
            }
          }
          case "TSTypeAssertion":
          case "TSAsExpression":
          case "LogicalExpression":
            switch (n2.type) {
              case "ConditionalExpression":
                return u2.type === "TSAsExpression";
              case "CallExpression":
              case "NewExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "ClassExpression":
              case "ClassDeclaration":
                return r2 === "superClass" && n2.superClass === u2;
              case "TSTypeAssertion":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "JSXSpreadAttribute":
              case "SpreadElement":
              case "SpreadProperty":
              case "BindExpression":
              case "AwaitExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "UpdateExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "AssignmentExpression":
                return n2.left === u2 && (u2.type === "TSTypeAssertion" || u2.type === "TSAsExpression");
              case "LogicalExpression":
                if (u2.type === "LogicalExpression")
                  return n2.operator !== u2.operator;
              case "BinaryExpression": {
                if (!u2.operator && u2.type !== "TSTypeAssertion")
                  return true;
                const e3 = n2.operator, t3 = wc(e3), o2 = u2.operator, a2 = wc(o2);
                return t3 > a2 || (t3 === a2 && r2 === "right" ? (Xa.strictEqual(n2.right, u2), true) : t3 === a2 && !Sc(e3, o2) || (t3 < a2 && o2 === "%" ? e3 === "+" || e3 === "-" : !!Fc(e3)));
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (n2.type) {
              case "ReturnStatement":
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return r2 !== "expression";
              case "ArrowFunctionExpression":
                return r2 !== "body";
              default:
                return true;
            }
          case "YieldExpression":
            if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
              return true;
          case "AwaitExpression":
            switch (n2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "ConditionalExpression":
                return n2.test === u2;
              case "BinaryExpression":
                return !(!u2.argument && n2.operator === "|>");
              default:
                return false;
            }
          case "TSJSDocFunctionType":
          case "TSConditionalType":
            if (n2.type === "TSConditionalType" && u2 === n2.extendsType)
              return true;
          case "TSFunctionType":
          case "TSConstructorType":
            if (n2.type === "TSConditionalType" && u2 === n2.checkType)
              return true;
          case "TSUnionType":
          case "TSIntersectionType":
            if (n2.type === "TSUnionType" || n2.type === "TSIntersectionType")
              return true;
          case "TSInferType":
            if (u2.type === "TSInferType" && n2.type === "TSRestType")
              return false;
          case "TSTypeOperator":
            return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || n2.type === "TSIndexedAccessType" && u2 === n2.objectType || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && /^TSJSDoc/.test(e2.getParentNode(1).type);
          case "ArrayTypeAnnotation":
            return n2.type === "NullableTypeAnnotation";
          case "IntersectionTypeAnnotation":
          case "UnionTypeAnnotation":
            return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation";
          case "NullableTypeAnnotation":
            return n2.type === "ArrayTypeAnnotation";
          case "FunctionTypeAnnotation": {
            const t3 = n2.type === "NullableTypeAnnotation" ? e2.getParentNode(1) : n2;
            return t3.type === "UnionTypeAnnotation" || t3.type === "IntersectionTypeAnnotation" || t3.type === "ArrayTypeAnnotation" || t3.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && u2.params && u2.params.some((e3) => e3.typeAnnotation && e3.typeAnnotation.type === "NullableTypeAnnotation");
          }
          case "StringLiteral":
          case "NumericLiteral":
          case "Literal":
            if (typeof u2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
              const t3 = e2.getParentNode(1);
              return t3.type === "Program" || t3.type === "BlockStatement";
            }
            return n2.type === "MemberExpression" && typeof u2.value == "number" && r2 === "object" && n2.object === u2;
          case "AssignmentExpression": {
            const t3 = e2.getParentNode(1);
            return n2.type === "ArrowFunctionExpression" && n2.body === u2 || (n2.type !== "ClassProperty" || n2.key !== u2 || !n2.computed) && ((n2.type !== "TSPropertySignature" || n2.name !== u2) && ((n2.type !== "ForStatement" || n2.init !== u2 && n2.update !== u2) && (n2.type === "ExpressionStatement" ? u2.left.type === "ObjectPattern" : (n2.type !== "TSPropertySignature" || n2.key !== u2) && (n2.type !== "AssignmentExpression" && ((n2.type !== "SequenceExpression" || !t3 || t3.type !== "ForStatement" || t3.init !== n2 && t3.update !== n2) && ((n2.type !== "Property" || n2.value !== u2) && n2.type !== "NGChainedExpression"))))));
          }
          case "ConditionalExpression":
            switch (n2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
              case "NGPipeExpression":
              case "ExportDefaultDeclaration":
              case "AwaitExpression":
              case "JSXSpreadAttribute":
              case "TSTypeAssertion":
              case "TypeCastExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "ConditionalExpression":
                return r2 === "test" && n2.test === u2;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              default:
                return false;
            }
          case "FunctionExpression":
            switch (n2.type) {
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "TaggedTemplateExpression":
                return true;
              default:
                return false;
            }
          case "ArrowFunctionExpression":
            switch (n2.type) {
              case "PipelineTopicExpression":
                return !(!u2.extra || !u2.extra.parenthesized);
              case "BinaryExpression":
                return n2.operator !== "|>" || u2.extra && u2.extra.parenthesized;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "TSAsExpression":
              case "BindExpression":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "AwaitExpression":
              case "TSTypeAssertion":
                return true;
              case "ConditionalExpression":
                return r2 === "test";
              default:
                return false;
            }
          case "ClassExpression":
            switch (n2.type) {
              case "NewExpression":
                return r2 === "callee" && n2.callee === u2;
              default:
                return false;
            }
          case "OptionalMemberExpression":
          case "OptionalCallExpression": {
            const t3 = e2.getParentNode(1);
            if (n2.type === "MemberExpression" && r2 === "object" || (n2.type === "CallExpression" || n2.type === "NewExpression") && r2 === "callee" || n2.type === "TSNonNullExpression" && t3.type === "MemberExpression" && t3.object === n2)
              return true;
          }
          case "CallExpression":
          case "MemberExpression":
          case "TaggedTemplateExpression":
          case "TSNonNullExpression":
            if ((n2.type === "BindExpression" || n2.type === "NewExpression") && r2 === "callee") {
              let e3 = u2;
              for (; e3; )
                switch (e3.type) {
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                  case "BindExpression":
                    e3 = e3.object;
                    break;
                  case "TaggedTemplateExpression":
                    e3 = e3.tag;
                    break;
                  case "TSNonNullExpression":
                    e3 = e3.expression;
                    break;
                  default:
                    return false;
                }
            }
            return false;
          case "BindExpression":
            return (n2.type === "BindExpression" || n2.type === "NewExpression") && r2 === "callee" || (n2.type === "MemberExpression" || n2.type === "OptionalMemberExpression") && r2 === "object";
          case "NGPipeExpression":
            return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || !(n2.type !== "ObjectProperty" || u2.extra && u2.extra.parenthesized) || n2.type === "ArrayExpression" || (n2.type === "CallExpression" || n2.type === "OptionalCallExpression") && n2.arguments[r2] === u2 || n2.type === "NGPipeExpression" && r2 === "right" || n2.type === "MemberExpression" && r2 === "property" || n2.type === "AssignmentExpression");
          case "JSXFragment":
          case "JSXElement":
            return r2 === "callee" || n2.type === "BinaryExpression" && n2.operator === "<" && r2 === "left" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "CallExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && n2.type !== "ObjectProperty" && n2.type !== "OptionalCallExpression" && n2.type !== "Property" && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator";
          case "TypeAnnotation":
            return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e3) {
              return vc(e3, (e4) => e4.type === "ObjectTypeAnnotation" && vc(e4, (e5) => e5.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }(u2);
        }
        return false;
      }
      function Tc(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode(), r2 = e2.getName();
        switch (n2.type) {
          case "NGPipeExpression":
            if (typeof r2 == "number" && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2)
              return e2.callParent(Tc);
            break;
          case "ObjectProperty":
            if (r2 === "value") {
              const t3 = e2.getParentNode(1);
              return t3.properties[t3.properties.length - 1] === n2;
            }
            break;
          case "BinaryExpression":
          case "LogicalExpression":
            if (r2 === "right")
              return e2.callParent(Tc);
            break;
          case "ConditionalExpression":
            if (r2 === "alternate")
              return e2.callParent(Tc);
            break;
          case "UnaryExpression":
            if (n2.prefix)
              return e2.callParent(Tc);
        }
        return false;
      }
      var kc = Bc;
      const {builders: {concat: Nc, join: Oc, line: Pc}} = dn;
      var _c = {isVueEventBindingExpression: function e2(t2) {
        switch (t2.type) {
          case "MemberExpression":
            switch (t2.property.type) {
              case "Identifier":
              case "NumericLiteral":
              case "StringLiteral":
                return e2(t2.object);
            }
            return false;
          case "Identifier":
            return true;
          default:
            return false;
        }
      }, printHtmlBinding: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (t2.__onHtmlBindingRoot && e2.getName() === null && t2.__onHtmlBindingRoot(r2, t2), r2.type === "File")
          return t2.__isVueForBindingLeft ? e2.call((e3) => {
            const {params: t3} = e3.getValue();
            return Nc([t3.length > 1 ? "(" : "", Oc(Nc([",", Pc]), e3.map(n2, "params")), t3.length > 1 ? ")" : ""]);
          }, "program", "body", 0) : t2.__isVueSlotScope ? e2.call((e3) => Oc(Nc([",", Pc]), e3.map(n2, "params")), "program", "body", 0) : void 0;
      }};
      var Ic = function(e2, t2) {
        switch (t2.parser) {
          case "json":
          case "json5":
          case "json-stringify":
          case "__js_expression":
          case "__vue_expression":
            return Object.assign({}, e2, {type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e2, comments: [], rootMarker: t2.rootMarker});
          default:
            return e2;
        }
      };
      const {getLast: jc, getPenultimate: Mc, isNextLineEmpty: Lc} = Lt, {hasLeadingComment: Rc, hasTrailingComment: qc, isFunctionCompositionArgs: Vc, isJSXNode: Wc, isLongCurriedCallExpression: $c, shouldPrintComma: Uc} = Ec, {builders: {concat: zc, line: Jc, hardline: Gc, softline: Hc, group: Xc, indent: Yc, conditionalGroup: Kc, ifBreak: Qc, breakParent: Zc}, utils: {willBreak: ep}} = dn;
      function tp(e2) {
        return e2.type === "ObjectExpression" && (e2.properties.length > 0 || e2.comments) || e2.type === "ArrayExpression" && (e2.elements.length > 0 || e2.comments) || e2.type === "TSTypeAssertion" && tp(e2.expression) || e2.type === "TSAsExpression" && tp(e2.expression) || e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && (!e2.returnType || !e2.returnType.typeAnnotation || e2.returnType.typeAnnotation.type !== "TSTypeReference") && (e2.body.type === "BlockStatement" || e2.body.type === "ArrowFunctionExpression" || e2.body.type === "ObjectExpression" || e2.body.type === "ArrayExpression" || e2.body.type === "CallExpression" || e2.body.type === "OptionalCallExpression" || e2.body.type === "ConditionalExpression" || Wc(e2.body));
      }
      var np = function(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = r2.type === "ImportExpression", o2 = u2 ? [r2.source] : r2.arguments;
        if (o2.length === 0)
          return zc(["(", Di.printDanglingComments(e2, t2, true), ")"]);
        if (o2.length === 2 && o2[0].type === "ArrowFunctionExpression" && o2[0].params.length === 0 && o2[0].body.type === "BlockStatement" && o2[1].type === "ArrayExpression" && !o2.some((e3) => e3.comments))
          return zc(["(", e2.call(n2, "arguments", 0), ", ", e2.call(n2, "arguments", 1), ")"]);
        let a2 = false, i2 = false, s2 = false;
        const l2 = o2.length - 1, c2 = (e3, r3) => {
          const u3 = e3.getNode(), o3 = [n2(e3)];
          return r3 === l2 || (Lc(t2.originalText, u3, t2.locEnd) ? (r3 === 0 && (s2 = true), a2 = true, o3.push(",", Gc, Gc)) : o3.push(",", Jc)), i2 = function(e4, t3) {
            if (!e4 || e4.type !== "ArrowFunctionExpression" || !e4.body || e4.body.type !== "BlockStatement" || !e4.params || e4.params.length < 1)
              return false;
            let r4 = false;
            return t3.each((e5) => {
              const t4 = zc([n2(e5)]);
              r4 = r4 || ep(t4);
            }, "params"), r4;
          }(u3, e3), zc(o3);
        }, p2 = u2 ? [e2.call((e3) => c2(e3, 0), "source")] : e2.map(c2, "arguments"), d2 = u2 || r2.callee && r2.callee.type === "Import" || !Uc(t2, "all") ? "" : ",";
        function f2() {
          return Xc(zc(["(", Yc(zc([Jc, zc(p2)])), d2, Jc, ")"]), {shouldBreak: true});
        }
        if (e2.getParentNode().type !== "Decorator" && Vc(o2))
          return f2();
        const h2 = function(e3) {
          if (e3.length !== 2)
            return false;
          const [t3, n3] = e3;
          return !(t3.comments && t3.comments.length || t3.type !== "FunctionExpression" && (t3.type !== "ArrowFunctionExpression" || t3.body.type !== "BlockStatement") || n3.type === "FunctionExpression" || n3.type === "ArrowFunctionExpression" || n3.type === "ConditionalExpression" || tp(n3));
        }(o2), m2 = function(e3) {
          const t3 = jc(e3), n3 = Mc(e3);
          return !Rc(t3) && !qc(t3) && tp(t3) && (!n3 || n3.type !== t3.type);
        }(o2);
        if (h2 || m2) {
          const t3 = (h2 ? p2.slice(1).some(ep) : p2.slice(0, -1).some(ep)) || a2 || i2;
          let l3 = [], c3 = 0;
          const d3 = (e3) => {
            h2 && c3 === 0 && (l3 = [zc([e3.call((e4) => n2(e4, {expandFirstArg: true})), p2.length > 1 ? "," : "", s2 ? Gc : Jc, s2 ? Gc : ""])].concat(p2.slice(1))), m2 && c3 === o2.length - 1 && (l3 = p2.slice(0, -1).concat(e3.call((e4) => n2(e4, {expandLastArg: true})))), c3++;
          };
          u2 ? e2.call(d3, "source") : e2.each(d3, "arguments");
          const g3 = p2.some(ep), D2 = zc(["(", zc(l3), ")"]);
          return zc([g3 ? Zc : "", Kc([g3 || r2.typeArguments || r2.typeParameters ? Qc(f2(), D2) : D2, zc(h2 ? ["(", Xc(l3[0], {shouldBreak: true}), zc(l3.slice(1)), ")"] : ["(", zc(p2.slice(0, -1)), Xc(jc(l3), {shouldBreak: true}), ")"]), f2()], {shouldBreak: t3})]);
        }
        const g2 = zc(["(", Yc(zc([Hc, zc(p2)])), Qc(d2), Hc, ")"]);
        return $c(e2) ? g2 : Xc(g2, {shouldBreak: p2.some(ep) || a2});
      };
      const {isNumericLiteral: rp} = Ec, {builders: {concat: up, softline: op, group: ap, indent: ip}} = dn;
      function sp(e2) {
        const t2 = e2.getValue();
        return !t2.optional || t2.type === "Identifier" && t2 === e2.getParentNode().key ? "" : t2.type === "OptionalCallExpression" || t2.type === "OptionalMemberExpression" && t2.computed ? "?." : "?";
      }
      var lp = {printOptionalToken: sp, printFunctionTypeParameters: function(e2, t2, n2) {
        const r2 = e2.getValue();
        return r2.typeArguments ? e2.call(n2, "typeArguments") : r2.typeParameters ? e2.call(n2, "typeParameters") : "";
      }, printMemberLookup: function(e2, t2, n2) {
        const r2 = e2.call(n2, "property"), u2 = e2.getValue(), o2 = sp(e2);
        return u2.computed ? !u2.property || rp(u2.property) ? up([o2, "[", r2, "]"]) : ap(up([o2, "[", ip(up([op, r2])), op, "]"])) : up([o2, ".", r2]);
      }, printBindExpressionCallee: function(e2, t2, n2) {
        return up(["::", e2.call(n2, "callee")]);
      }};
      const {getLast: cp, isNextLineEmpty: pp, isNextLineEmptyAfterIndex: dp, getNextNonSpaceNonCommentCharacterIndex: fp} = Lt, {hasLeadingComment: hp, hasTrailingComment: mp, isCallOrOptionalCallExpression: gp, isFunctionOrArrowExpression: Dp, isLongCurriedCallExpression: yp, isMemberish: Ep, isNumericLiteral: Cp, isSimpleCallArgument: bp} = Ec, {builders: {concat: Ap, join: vp, hardline: Fp, group: xp, indent: Sp, conditionalGroup: wp, breakParent: Bp}, utils: {willBreak: Tp}} = dn, {printOptionalToken: kp, printFunctionTypeParameters: Np, printMemberLookup: Op, printBindExpressionCallee: Pp} = lp;
      var _p = function(e2, t2, n2) {
        const r2 = e2.getParentNode(), u2 = !r2 || r2.type === "ExpressionStatement", o2 = [];
        function a2(e3) {
          const {originalText: n3} = t2, r3 = fp(n3, e3, t2.locEnd);
          return n3.charAt(r3) === ")" ? r3 !== false && dp(n3, r3 + 1) : pp(n3, e3, t2.locEnd);
        }
        const i2 = e2.getValue();
        o2.unshift({node: i2, printed: Ap([kp(e2), Np(e2, t2, n2), np(e2, t2, n2)])}), i2.callee && e2.call((e3) => function e4(r3) {
          const u3 = r3.getValue();
          gp(u3) && (Ep(u3.callee) || gp(u3.callee)) ? (o2.unshift({node: u3, printed: Ap([Di.printComments(r3, () => Ap([kp(r3), Np(r3, t2, n2), np(r3, t2, n2)]), t2), a2(u3) ? Fp : ""])}), r3.call((t3) => e4(t3), "callee")) : Ep(u3) ? (o2.unshift({node: u3, needsParens: kc(r3, t2), printed: Di.printComments(r3, () => u3.type === "OptionalMemberExpression" || u3.type === "MemberExpression" ? Op(r3, t2, n2) : Pp(r3, t2, n2), t2)}), r3.call((t3) => e4(t3), "object")) : u3.type === "TSNonNullExpression" ? (o2.unshift({node: u3, printed: Di.printComments(r3, () => "!", t2)}), r3.call((t3) => e4(t3), "expression")) : o2.unshift({node: u3, printed: r3.call(n2)});
        }(e3), "callee");
        const s2 = [];
        let l2 = [o2[0]], c2 = 1;
        for (; c2 < o2.length && (o2[c2].node.type === "TSNonNullExpression" || gp(o2[c2].node) || (o2[c2].node.type === "MemberExpression" || o2[c2].node.type === "OptionalMemberExpression") && o2[c2].node.computed && Cp(o2[c2].node.property)); ++c2)
          l2.push(o2[c2]);
        if (!gp(o2[0].node))
          for (; c2 + 1 < o2.length && (Ep(o2[c2].node) && Ep(o2[c2 + 1].node)); ++c2)
            l2.push(o2[c2]);
        s2.push(l2), l2 = [];
        let p2 = false;
        for (; c2 < o2.length; ++c2) {
          if (p2 && Ep(o2[c2].node)) {
            if (o2[c2].node.computed && Cp(o2[c2].node.property)) {
              l2.push(o2[c2]);
              continue;
            }
            s2.push(l2), l2 = [], p2 = false;
          }
          (gp(o2[c2].node) || o2[c2].node.type === "ImportExpression") && (p2 = true), l2.push(o2[c2]), o2[c2].node.comments && o2[c2].node.comments.some((e3) => e3.trailing) && (s2.push(l2), l2 = [], p2 = false);
        }
        function d2(e3) {
          return /^[A-Z]|^[$_]+$/.test(e3);
        }
        l2.length > 0 && s2.push(l2);
        const f2 = s2.length >= 2 && !s2[1][0].node.comments && function(e3) {
          const n3 = e3[1].length && e3[1][0].node.computed;
          if (e3[0].length === 1) {
            const r4 = e3[0][0].node;
            return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || u2 && function(e4) {
              return e4.length <= t2.tabWidth;
            }(r4.name) || n3);
          }
          const r3 = cp(e3[0]).node;
          return (r3.type === "MemberExpression" || r3.type === "OptionalMemberExpression") && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
        }(s2);
        function h2(e3) {
          const t3 = e3.map((e4) => e4.printed);
          return e3.length > 0 && e3[e3.length - 1].needsParens ? Ap(["(", ...t3, ")"]) : Ap(t3);
        }
        const m2 = s2.map(h2), g2 = Ap(m2), D2 = f2 ? 3 : 2, y2 = Go(s2), E2 = y2.slice(1, -1).some((e3) => hp(e3.node)) || y2.slice(0, -1).some((e3) => mp(e3.node)) || s2[D2] && hp(s2[D2][0].node);
        if (s2.length <= D2 && !E2)
          return yp(e2) ? g2 : xp(g2);
        const C2 = cp(s2[f2 ? 1 : 0]).node, b2 = !gp(C2) && a2(C2), A2 = Ap([h2(s2[0]), f2 ? Ap(s2.slice(1, 2).map(h2)) : "", b2 ? Fp : "", function(e3) {
          return e3.length === 0 ? "" : Sp(xp(Ap([Fp, vp(Fp, e3.map(h2))])));
        }(s2.slice(f2 ? 2 : 1))]), v2 = o2.map(({node: e3}) => e3).filter(gp);
        return E2 || v2.length > 2 && v2.some((e3) => !e3.arguments.every((e4) => bp(e4, 0))) || m2.slice(0, -1).some(Tp) || function() {
          const e3 = cp(cp(s2)).node, t3 = cp(m2);
          return gp(e3) && Tp(t3) && v2.slice(0, -1).some((e4) => e4.arguments.some(Dp));
        }() ? xp(A2) : Ap([Tp(g2) || b2 ? Bp : "", wp([g2, A2])]);
      };
      const {builders: {concat: Ip, softline: jp, group: Mp, indent: Lp, join: Rp, line: qp, ifBreak: Vp}} = dn, {shouldPrintComma: Wp} = Ec;
      var $p = {printModuleSource: function(e2, t2, n2) {
        return e2.getValue().source ? Ip([" from ", e2.call(n2, "source")]) : "";
      }, printModuleSpecifiers: function(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = [r2.type === "ImportDeclaration" ? " " : ""];
        if (r2.specifiers && r2.specifiers.length > 0) {
          const o2 = [], a2 = [];
          if (e2.each((t3) => {
            const r3 = e2.getValue().type;
            if (r3 === "ExportNamespaceSpecifier" || r3 === "ExportDefaultSpecifier" || r3 === "ImportNamespaceSpecifier" || r3 === "ImportDefaultSpecifier")
              o2.push(n2(t3));
            else {
              if (r3 !== "ExportSpecifier" && r3 !== "ImportSpecifier")
                throw new Error("Unknown specifier type ".concat(JSON.stringify(r3)));
              a2.push(n2(t3));
            }
          }, "specifiers"), u2.push(Rp(", ", o2)), a2.length !== 0) {
            o2.length !== 0 && u2.push(", ");
            a2.length > 1 || o2.length > 0 || r2.specifiers.some((e3) => e3.comments) ? u2.push(Mp(Ip(["{", Lp(Ip([t2.bracketSpacing ? qp : jp, Rp(Ip([",", qp]), a2)])), Vp(Wp(t2) ? "," : ""), t2.bracketSpacing ? qp : jp, "}"]))) : u2.push(Ip(["{", t2.bracketSpacing ? " " : "", Ip(a2), t2.bracketSpacing ? " " : "", "}"]));
          }
        } else
          u2.push("{}");
        return Ip(u2);
      }};
      const {isJSXNode: Up} = Ec, {hasNewlineInRange: zp} = Lt, {builders: {concat: Jp, line: Gp, softline: Hp, group: Xp, indent: Yp, align: Kp, ifBreak: Qp, dedent: Zp, breakParent: ed}} = dn;
      var td = function(e2, t2, n2, r2) {
        const u2 = e2.getValue(), o2 = u2[r2.consequentNodePropertyName], a2 = u2[r2.alternateNodePropertyName], i2 = [];
        let s2 = false;
        const l2 = e2.getParentNode(), c2 = l2.type === r2.conditionalNodeType && r2.testNodePropertyNames.some((e3) => l2[e3] === u2);
        let p2, d2, f2 = l2.type === r2.conditionalNodeType && !c2, h2 = 0;
        do {
          d2 = p2 || u2, p2 = e2.getParentNode(h2), h2++;
        } while (p2 && p2.type === r2.conditionalNodeType && r2.testNodePropertyNames.every((e3) => p2[e3] !== d2));
        const m2 = p2 || l2, g2 = d2;
        if (r2.shouldCheckJsx && (Up(u2[r2.testNodePropertyNames[0]]) || Up(o2) || Up(a2) || function(e3) {
          return function(e4) {
            const t3 = [];
            return function e5(n3) {
              n3.type === "ConditionalExpression" ? (e5(n3.test), e5(n3.consequent), e5(n3.alternate)) : t3.push(n3);
            }(e4), t3;
          }(e3).some(Up);
        }(g2))) {
          s2 = true, f2 = true;
          const t3 = (e3) => Jp([Qp("(", ""), Yp(Jp([Hp, e3])), Hp, Qp(")", "")]), u3 = (e3) => e3.type === "NullLiteral" || e3.type === "Literal" && e3.value === null || e3.type === "Identifier" && e3.name === "undefined";
          i2.push(" ? ", u3(o2) ? e2.call(n2, r2.consequentNodePropertyName) : t3(e2.call(n2, r2.consequentNodePropertyName)), " : ", a2.type === r2.conditionalNodeType || u3(a2) ? e2.call(n2, r2.alternateNodePropertyName) : t3(e2.call(n2, r2.alternateNodePropertyName)));
        } else {
          const s3 = Jp([Gp, "? ", o2.type === r2.conditionalNodeType ? Qp("", "(") : "", Kp(2, e2.call(n2, r2.consequentNodePropertyName)), o2.type === r2.conditionalNodeType ? Qp("", ")") : "", Gp, ": ", a2.type === r2.conditionalNodeType ? e2.call(n2, r2.alternateNodePropertyName) : Kp(2, e2.call(n2, r2.alternateNodePropertyName))]);
          i2.push(l2.type !== r2.conditionalNodeType || l2[r2.alternateNodePropertyName] === u2 || c2 ? s3 : t2.useTabs ? Zp(Yp(s3)) : Kp(Math.max(0, t2.tabWidth - 2), s3));
        }
        const D2 = Go([...r2.testNodePropertyNames.map((e3) => u2[e3].comments), o2.comments, a2.comments]).filter(Boolean).some((e3) => Gs.isBlockComment(e3) && zp(t2.originalText, t2.locStart(e3), t2.locEnd(e3))), y2 = !s2 && (l2.type === "MemberExpression" || l2.type === "OptionalMemberExpression" || l2.type === "NGPipeExpression" && l2.left === u2) && !l2.computed, E2 = ((e3) => l2 === m2 ? Xp(e3, {shouldBreak: D2}) : D2 ? Jp([e3, ed]) : e3)(Jp([].concat((C2 = Jp(r2.beforeParts()), l2.type === r2.conditionalNodeType && l2[r2.alternateNodePropertyName] === u2 ? Kp(2, C2) : C2), f2 ? Jp(i2) : Yp(Jp(i2)), r2.afterParts(y2))));
        var C2;
        return c2 ? Xp(Jp([Yp(Jp([Hp, E2])), Hp])) : E2;
      };
      const {getNextNonSpaceNonCommentCharacter: nd, hasNewline: rd, hasNewlineInRange: ud, getLast: od, getStringWidth: ad, printString: id, printNumber: sd, hasIgnoreComment: ld, hasNodeIgnoreComment: cd, getIndentSize: pd, getPreferredQuote: dd} = Lt, {isNextLineEmpty: fd, getNextNonSpaceNonCommentCharacterIndex: hd} = bs, {builders: {concat: md, join: gd, line: Dd, hardline: yd, softline: Ed, literalline: Cd, group: bd, indent: Ad, align: vd, conditionalGroup: Fd, fill: xd, ifBreak: Sd, lineSuffixBoundary: wd, addAlignmentToDoc: Bd}, utils: {willBreak: Td, isLineNext: kd, isEmpty: Nd, removeLines: Od, normalizeParts: Pd}, printer: {printDocToString: _d}} = dn, {insertPragma: Id} = Nl, {printHtmlBinding: jd, isVueEventBindingExpression: Md} = _c, {classChildNeedsASIProtection: Ld, classPropMayCauseASIProblems: Rd, getFlowVariance: qd, getLeftSidePathName: Vd, getParentExportDeclaration: Wd, getTypeScriptMappedTypeModifier: $d, hasDanglingComments: Ud, hasFlowAnnotationComment: zd, hasFlowShorthandAnnotationComment: Jd, hasLeadingOwnLineComment: Gd, hasNakedLeftSide: Hd, hasNewlineBetweenOrAfterDecorators: Xd, hasNgSideEffect: Yd, hasPrettierIgnore: Kd, hasTrailingComment: Qd, hasTrailingLineComment: Zd, identity: ef, isBinaryish: tf, isCallOrOptionalCallExpression: nf, isEmptyJSXElement: rf, isExportDeclaration: uf, isFlowAnnotationComment: of, isFunctionNotation: af, isGetterOrSetter: sf, isJestEachTemplateLiteral: lf, isJSXNode: cf, isJSXWhitespaceExpression: pf, isLastStatement: df, isLiteral: ff, isMeaningfulJSXText: hf, isMemberExpressionChain: mf, isMemberish: gf, isNgForOf: Df, isNumericLiteral: yf, isObjectType: Ef, isObjectTypePropertyAFunction: Cf, isSimpleFlowType: bf, isSimpleNumber: Af, isSimpleTemplateLiteral: vf, isStringLiteral: Ff, isStringPropSafeToUnquote: xf, isTemplateOnItsOwnLine: Sf, isTestCall: wf, isTheOnlyJSXElementInMarkdown: Bf, isTSXFile: Tf, isTypeAnnotationAFunction: kf, matchJsxWhitespaceRegex: Nf, needsHardlineAfterDanglingComment: Of, rawText: Pf, returnArgumentHasLeadingComment: _f, shouldPrintComma: If, shouldFlatten: jf, startsWithNoLookaheadToken: Mf} = Ec, {printOptionalToken: Lf, printFunctionTypeParameters: Rf, printMemberLookup: qf, printBindExpressionCallee: Vf} = lp, {printModuleSource: Wf, printModuleSpecifiers: $f} = $p, Uf = new WeakMap();
      let zf = 0;
      function Jf(e2, t2, n2) {
        const r2 = e2.getValue();
        return bd(md([gd(Dd, e2.map(n2, "decorators")), Xd(r2, t2) ? yd : Dd]));
      }
      function Gf(e2, t2, n2) {
        const r2 = [], u2 = e2.getNode(), o2 = u2.type === "ClassBody";
        return e2.map((e3, a2) => {
          const i2 = e3.getValue();
          if (!i2)
            return;
          if (i2.type === "EmptyStatement")
            return;
          const s2 = n2(e3), l2 = t2.originalText, c2 = [];
          if (t2.semi || o2 || Bf(t2, e3) || !function(e4, t3) {
            if (e4.getNode().type !== "ExpressionStatement")
              return false;
            return e4.call((e5) => function e6(t4, n3) {
              const r3 = t4.getValue();
              if (kc(t4, n3) || r3.type === "ParenthesizedExpression" || r3.type === "TypeCastExpression" || r3.type === "ArrowFunctionExpression" && !Zf(t4, n3) || r3.type === "ArrayExpression" || r3.type === "ArrayPattern" || r3.type === "UnaryExpression" && r3.prefix && (r3.operator === "+" || r3.operator === "-") || r3.type === "TemplateLiteral" || r3.type === "TemplateElement" || cf(r3) || r3.type === "BindExpression" && !r3.object || r3.type === "RegExpLiteral" || r3.type === "Literal" && r3.pattern || r3.type === "Literal" && r3.regex)
                return true;
              if (!Hd(r3))
                return false;
              return t4.call((t5) => e6(t5, n3), ...Vd(t4, r3));
            }(e5, t3), "expression");
          }(e3, t2) ? c2.push(s2) : i2.comments && i2.comments.some((e4) => e4.leading) ? c2.push(n2(e3, {needsSemi: true})) : c2.push(";", s2), !t2.semi && o2) {
            if (Rd(e3))
              c2.push(";");
            else if (i2.type === "ClassProperty") {
              const e4 = u2.body[a2 + 1];
              Ld(e4) && c2.push(";");
            }
          }
          fd(l2, i2, t2.locEnd) && !df(e3) && c2.push(yd), r2.push(md(c2));
        }), gd(yd, r2);
      }
      function Hf(e2, t2, n2) {
        const r2 = e2.getNode();
        if (r2.computed)
          return md(["[", e2.call(n2, "key"), "]"]);
        const u2 = e2.getParentNode(), {key: o2} = r2;
        if (r2.type === "ClassPrivateProperty" && o2.type === "Identifier")
          return md(["#", e2.call(n2, "key")]);
        if (t2.quoteProps === "consistent" && !Uf.has(u2)) {
          const e3 = (u2.properties || u2.body || u2.members).some((e4) => !e4.computed && e4.key && Ff(e4.key) && !xf(e4, t2));
          Uf.set(u2, e3);
        }
        if ((o2.type === "Identifier" || yf(o2) && Af(sd(Pf(o2))) && String(o2.value) === sd(Pf(o2)) && t2.parser !== "typescript" && t2.parser !== "babel-ts") && (t2.parser === "json" || t2.quoteProps === "consistent" && Uf.get(u2))) {
          const n3 = id(JSON.stringify(o2.type === "Identifier" ? o2.name : o2.value.toString()), t2);
          return e2.call((e3) => Di.printComments(e3, () => n3, t2), "key");
        }
        return xf(r2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !Uf.get(u2)) ? e2.call((e3) => Di.printComments(e3, () => /^\d/.test(o2.value) ? sd(o2.value) : o2.value, t2), "key") : e2.call(n2, "key");
      }
      function Xf(e2, t2, n2) {
        const r2 = e2.getNode(), {kind: u2} = r2, o2 = r2.value || r2, a2 = [];
        return u2 && u2 !== "init" && u2 !== "method" && u2 !== "constructor" ? (Xa.ok(u2 === "get" || u2 === "set"), a2.push(u2, " ")) : (o2.async && a2.push("async "), o2.generator && a2.push("*")), a2.push(Hf(e2, t2, n2), r2.optional || r2.key.optional ? "?" : "", r2 === o2 ? Yf(e2, t2, n2) : e2.call((e3) => Yf(e3, t2, n2), "value")), md(a2);
      }
      function Yf(e2, t2, n2) {
        const r2 = [Rf(e2, t2, n2), bd(md([Qf(e2, n2, t2), th(e2, n2, t2)]))];
        return e2.getNode().body ? r2.push(" ", e2.call(n2, "body")) : r2.push(t2.semi ? ";" : ""), md(r2);
      }
      function Kf(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2.typeAnnotation)
          return "";
        const u2 = e2.getParentNode(), o2 = r2.definite || u2 && u2.type === "VariableDeclarator" && u2.definite, a2 = u2.type === "DeclareFunction" && u2.id === r2;
        return of(t2.originalText, r2.typeAnnotation, t2) ? md([" /*: ", e2.call(n2, "typeAnnotation"), " */"]) : md([a2 ? "" : o2 ? "!: " : ": ", e2.call(n2, "typeAnnotation")]);
      }
      function Qf(e2, t2, n2, r2, u2) {
        const o2 = e2.getValue(), a2 = e2.getParentNode(), i2 = o2.parameters ? "parameters" : "params", s2 = wf(a2), l2 = yh(o2), c2 = r2 && !(o2[i2] && o2[i2].some((e3) => e3.comments)), p2 = u2 ? Rf(e2, n2, t2) : "";
        let d2 = [];
        if (o2[i2]) {
          const r3 = o2[i2].length - 1;
          d2 = e2.map((e3, u3) => {
            const a3 = [], i3 = e3.getValue();
            return a3.push(t2(e3)), u3 === r3 ? o2.rest && a3.push(",", Dd) : s2 || l2 || c2 ? a3.push(", ") : fd(n2.originalText, i3, n2.locEnd) ? a3.push(",", yd, yd) : a3.push(",", Dd), md(a3);
          }, i2);
        }
        if (o2.rest && d2.push(md(["...", e2.call(t2, "rest")])), d2.length === 0)
          return md([p2, "(", Di.printDanglingComments(e2, n2, true, (e3) => nd(n2.originalText, e3, n2.locEnd) === ")"), ")"]);
        const f2 = od(o2[i2]);
        if (c2)
          return bd(md([Od(p2), "(", md(d2.map(Od)), ")"]));
        const h2 = o2[i2].every((e3) => !e3.decorators);
        if (l2 && h2)
          return md([p2, "(", md(d2), ")"]);
        if (s2)
          return md([p2, "(", md(d2), ")"]);
        if ((Cf(a2, n2) || kf(a2, n2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === o2) && o2[i2].length === 1 && o2[i2][0].name === null && o2[i2][0].typeAnnotation && o2.typeParameters === null && bf(o2[i2][0].typeAnnotation) && !o2.rest)
          return n2.arrowParens === "always" ? md(["(", md(d2), ")"]) : md(d2);
        const m2 = !(f2 && f2.type === "RestElement" || o2.rest);
        return md([p2, "(", Ad(md([Ed, md(d2)])), Sd(m2 && If(n2, "all") ? "," : ""), Ed, ")"]);
      }
      function Zf(e2, t2) {
        if (t2.arrowParens === "always")
          return false;
        if (t2.arrowParens === "avoid") {
          return function(e3) {
            return !(e3.params.length !== 1 || e3.rest || e3.typeParameters || Ud(e3) || e3.params[0].type !== "Identifier" || e3.params[0].typeAnnotation || e3.params[0].comments || e3.params[0].optional || e3.predicate || e3.returnType);
          }(e2.getValue());
        }
        return false;
      }
      function eh(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = [];
        return r2.async && u2.push("async "), r2.generator ? u2.push("function* ") : u2.push("function "), r2.id && u2.push(e2.call(t2, "id")), u2.push(Rf(e2, n2, t2), bd(md([Qf(e2, t2, n2), th(e2, t2, n2)])), r2.body ? " " : "", e2.call(t2, "body")), md(u2);
      }
      function th(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = e2.call(t2, "returnType");
        if (r2.returnType && of(n2.originalText, r2.returnType, n2))
          return md([" /*: ", u2, " */"]);
        const o2 = [u2];
        return r2.returnType && r2.returnType.typeAnnotation && o2.unshift(": "), r2.predicate && o2.push(r2.returnType ? " " : ": ", e2.call(t2, "predicate")), md(o2);
      }
      function nh(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = t2.semi ? ";" : "", o2 = ["export "], a2 = r2.default || r2.type === "ExportDefaultDeclaration";
        return a2 && o2.push("default "), o2.push(Di.printDanglingComments(e2, t2, true)), Of(r2) && o2.push(yd), r2.declaration ? (o2.push(e2.call(n2, "declaration")), a2 && r2.declaration.type !== "ClassDeclaration" && r2.declaration.type !== "FunctionDeclaration" && r2.declaration.type !== "TSInterfaceDeclaration" && r2.declaration.type !== "DeclareClass" && r2.declaration.type !== "DeclareFunction" && r2.declaration.type !== "TSDeclareFunction" && r2.declaration.type !== "EnumDeclaration" && o2.push(u2)) : (o2.push(r2.exportKind === "type" ? "type " : ""), o2.push($f(e2, t2, n2)), o2.push(Wf(e2, t2, n2)), o2.push(u2)), md(o2);
      }
      function rh(e2, t2) {
        const n2 = Wd(e2);
        return n2 ? Xa.strictEqual(n2.type, "DeclareExportDeclaration") : t2.unshift("declare "), md(t2);
      }
      function uh(e2, t2, n2) {
        const r2 = e2.getValue();
        return r2.modifiers && r2.modifiers.length ? md([gd(" ", e2.map(n2, "modifiers")), " "]) : "";
      }
      const oh = new WeakMap();
      function ah(e2) {
        return oh.has(e2) || oh.set(e2, Symbol("typeParameters")), oh.get(e2);
      }
      function ih(e2, t2, n2, r2) {
        const u2 = e2.getValue();
        if (!u2[r2])
          return "";
        if (!Array.isArray(u2[r2]))
          return e2.call(n2, r2);
        const o2 = e2.getNode(2), a2 = e2.getNode(3), i2 = e2.getNode(4);
        return o2 != null && wf(o2) || u2[r2].length === 0 || u2[r2].length === 1 && (Dh(u2[r2][0]) || u2[r2][0].type === "GenericTypeAnnotation" && Dh(u2[r2][0].id) || u2[r2][0].type === "TSTypeReference" && Dh(u2[r2][0].typeName) || u2[r2][0].type === "NullableTypeAnnotation" || i2 && i2.type === "VariableDeclarator" && o2.type === "TSTypeAnnotation" && a2.type !== "ArrowFunctionExpression" && u2[r2][0].type !== "TSUnionType" && u2[r2][0].type !== "UnionTypeAnnotation" && u2[r2][0].type !== "TSIntersectionType" && u2[r2][0].type !== "IntersectionTypeAnnotation" && u2[r2][0].type !== "TSConditionalType" && u2[r2][0].type !== "TSMappedType" && u2[r2][0].type !== "TSTypeOperator" && u2[r2][0].type !== "TSIndexedAccessType" && u2[r2][0].type !== "TSArrayType") ? md(["<", gd(", ", e2.map(n2, r2)), function(n3) {
          if (!Ud(n3))
            return "";
          const r3 = n3.comments.every(Gs.isBlockComment), u3 = Di.printDanglingComments(e2, t2, r3);
          return r3 ? u3 : md([u3, yd]);
        }(u2), ">"]) : bd(md(["<", Ad(md([Ed, gd(md([",", Dd]), e2.map(n2, r2))])), Sd(t2.parser !== "typescript" && t2.parser !== "babel-ts" && If(t2, "all") ? "," : ""), Ed, ">"]), {id: ah(u2)});
      }
      function sh(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = [];
        r2.abstract && u2.push("abstract "), u2.push("class");
        const o2 = r2.id && Qd(r2.id) || r2.superClass && r2.superClass.comments && r2.superClass.comments.length !== 0 || r2.extends && r2.extends.length !== 0 || r2.mixins && r2.mixins.length !== 0 || r2.implements && r2.implements.length !== 0, a2 = [], i2 = [];
        r2.id && a2.push(" ", e2.call(n2, "id")), a2.push(e2.call(n2, "typeParameters"));
        const s2 = ["superClass", "extends", "mixins", "implements"].filter((e3) => !!r2[e3]).length > 1, l2 = r2.typeParameters && !Zd(r2.typeParameters) && !s2;
        function c2(u3) {
          if (r2[u3] && r2[u3].length !== 0) {
            const o3 = Di.printDanglingComments(e2, t2, true, ({marker: e3}) => e3 === u3);
            i2.push(l2 ? Sd(" ", Dd, {groupId: ah(r2.typeParameters)}) : Dd, o3, o3 && yd, u3, bd(Ad(md([Dd, gd(md([",", Dd]), e2.map(n2, u3))]))));
          }
        }
        if (r2.superClass) {
          const r3 = md(["extends ", e2.call(n2, "superClass"), e2.call(n2, "superTypeParameters")]), u3 = e2.call((e3) => Di.printComments(e3, () => r3, t2), "superClass");
          o2 ? i2.push(Dd, bd(u3)) : i2.push(" ", u3);
        } else
          c2("extends");
        if (c2("mixins"), c2("implements"), o2) {
          const e3 = md(i2);
          l2 ? u2.push(bd(md(a2.concat(Sd(Ad(e3), e3))))) : u2.push(bd(Ad(md(a2.concat(e3)))));
        } else
          u2.push(...a2, ...i2);
        return u2.push(" ", e2.call(n2, "body")), u2;
      }
      function lh(e2, t2, n2, r2) {
        return e2 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t2.length === 1 ? Ed : yd : Ed;
      }
      function ch(e2, t2, n2, r2) {
        return e2 ? yd : t2.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? yd : Ed : yd;
      }
      function ph(e2) {
        return e2.type === "LogicalExpression" && (e2.right.type === "ObjectExpression" && e2.right.properties.length !== 0 || (e2.right.type === "ArrayExpression" && e2.right.elements.length !== 0 || !!cf(e2.right)));
      }
      function dh(e2, t2, n2, r2) {
        if (Gd(r2.originalText, t2, r2))
          return Ad(md([Dd, n2]));
        return tf(t2) && !ph(t2) || t2.type === "ConditionalExpression" && tf(t2.test) && !ph(t2.test) || t2.type === "StringLiteralTypeAnnotation" || t2.type === "ClassExpression" && t2.decorators && t2.decorators.length || (e2.type === "Identifier" || Ff(e2) || e2.type === "MemberExpression") && (Ff(t2) || mf(t2)) && r2.parser !== "json" && r2.parser !== "json5" || t2.type === "SequenceExpression" ? bd(Ad(md([Dd, n2]))) : md([" ", n2]);
      }
      function fh(e2, t2, n2, r2, u2, o2) {
        if (!r2)
          return t2;
        const a2 = dh(e2, r2, u2, o2);
        return bd(md([t2, n2, a2]));
      }
      function hh(e2, t2, n2) {
        return e2.type === "EmptyStatement" ? ";" : e2.type === "BlockStatement" || n2 ? md([" ", t2]) : Ad(md([Dd, t2]));
      }
      function mh(e2, t2, n2) {
        const r2 = Pf(e2), u2 = n2 || e2.type === "DirectiveLiteral";
        return id(r2, t2, u2);
      }
      function gh(e2) {
        const t2 = e2.flags.split("").sort().join("");
        return "/".concat(e2.pattern, "/").concat(t2);
      }
      function Dh(e2) {
        if (bf(e2) || Ef(e2))
          return true;
        if (e2.type === "UnionTypeAnnotation" || e2.type === "TSUnionType") {
          const t2 = e2.types.filter((e3) => e3.type === "VoidTypeAnnotation" || e3.type === "TSVoidKeyword" || e3.type === "NullLiteralTypeAnnotation" || e3.type === "TSNullKeyword").length, n2 = e2.types.some((e3) => e3.type === "ObjectTypeAnnotation" || e3.type === "TSTypeLiteral" || e3.type === "GenericTypeAnnotation" || e3.type === "TSTypeReference");
          if (e2.types.length - 1 === t2 && n2)
            return true;
        }
        return false;
      }
      function yh(e2) {
        if (!e2 || e2.rest)
          return false;
        const t2 = e2.params || e2.parameters;
        if (!t2 || t2.length !== 1)
          return false;
        const n2 = t2[0];
        return !n2.comments && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && Ef(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && Ef(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
      }
      function Eh(e2, t2, n2, r2) {
        const u2 = [];
        let o2 = [];
        return e2.each((e3) => {
          u2.push(md(o2)), u2.push(bd(r2(e3))), o2 = [",", Dd], e3.getValue() && fd(t2.originalText, e3.getValue(), t2.locEnd) && o2.push(Ed);
        }, n2), md(u2);
      }
      function Ch(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = t2.semi ? ";" : "", o2 = [];
        r2.argument && (_f(t2, r2.argument) ? o2.push(md([" (", Ad(md([yd, e2.call(n2, "argument")])), yd, ")"])) : tf(r2.argument) || r2.argument.type === "SequenceExpression" ? o2.push(bd(md([Sd(" (", " "), Ad(md([Ed, e2.call(n2, "argument")])), Ed, Sd(")")]))) : o2.push(" ", e2.call(n2, "argument")));
        const a2 = Array.isArray(r2.comments) && r2.comments[r2.comments.length - 1], i2 = a2 && (a2.type === "CommentLine" || a2.type === "Line");
        return i2 && o2.push(u2), Ud(r2) && o2.push(" ", Di.printDanglingComments(e2, t2, true)), i2 || o2.push(u2), md(o2);
      }
      function bh(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode();
        return (t2 && (cf(t2) || Jd(t2) || n2 && (n2.type === "CallExpression" || n2.type === "OptionalCallExpression") && (zd(t2.leadingComments) || zd(t2.trailingComments))) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t2)) && (!ld(e2) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
      }
      var Ah = {preprocess: Ic, print: function(e2, t2, n2, r2) {
        const u2 = e2.getValue();
        let o2 = false;
        const a2 = function(e3, t3, n3, r3) {
          const u3 = e3.getValue(), o3 = t3.semi ? ";" : "";
          if (!u3)
            return "";
          if (typeof u3 == "string")
            return u3;
          const a3 = jd(e3, t3, n3);
          if (a3)
            return a3;
          let i3 = [];
          switch (u3.type) {
            case "JsExpressionRoot":
              return e3.call(n3, "node");
            case "JsonRoot":
              return md([e3.call(n3, "node"), yd]);
            case "File":
              return u3.program && u3.program.interpreter && i3.push(e3.call((e4) => e4.call(n3, "interpreter"), "program")), i3.push(e3.call(n3, "program")), md(i3);
            case "Program": {
              const r4 = !u3.body.every(({type: e4}) => e4 === "EmptyStatement") || u3.comments;
              if (u3.directives) {
                const a4 = u3.directives.length;
                e3.map((e4, u4) => {
                  i3.push(n3(e4), o3, yd), (u4 < a4 - 1 || r4) && fd(t3.originalText, e4.getValue(), t3.locEnd) && i3.push(yd);
                }, "directives");
              }
              return i3.push(e3.call((e4) => Gf(e4, t3, n3), "body")), i3.push(Di.printDanglingComments(e3, t3, true)), r4 && i3.push(yd), md(i3);
            }
            case "EmptyStatement":
              return "";
            case "ExpressionStatement":
              if (u3.directive)
                return md([mh(u3.expression, t3, true), o3]);
              if (t3.parser === "__vue_event_binding") {
                const t4 = e3.getParentNode();
                if (t4.type === "Program" && t4.body.length === 1 && t4.body[0] === u3)
                  return md([e3.call(n3, "expression"), Md(u3.expression) ? ";" : ""]);
              }
              return md([e3.call(n3, "expression"), Bf(t3, e3) ? "" : o3]);
            case "ParenthesizedExpression":
              return !u3.expression.comments ? md(["(", e3.call(n3, "expression"), ")"]) : bd(md(["(", Ad(md([Ed, e3.call(n3, "expression")])), Ed, ")"]));
            case "AssignmentExpression":
              return fh(u3.left, e3.call(n3, "left"), md([" ", u3.operator]), u3.right, e3.call(n3, "right"), t3);
            case "BinaryExpression":
            case "LogicalExpression":
            case "NGPipeExpression": {
              const r4 = e3.getParentNode(), o4 = e3.getParentNode(1), a4 = u3 !== r4.body && (r4.type === "IfStatement" || r4.type === "WhileStatement" || r4.type === "SwitchStatement" || r4.type === "DoWhileStatement"), i4 = function e4(t4, n4, r5, u4, o5) {
                let a5 = [];
                const i5 = t4.getValue();
                if (tf(i5)) {
                  jf(i5.operator, i5.left.operator) ? a5 = a5.concat(t4.call((t5) => e4(t5, n4, r5, true, o5), "left")) : a5.push(bd(t4.call(n4, "left")));
                  const s4 = ph(i5), l4 = (i5.operator === "|>" || i5.type === "NGPipeExpression" || i5.operator === "|" && r5.parser === "__vue_expression") && !Gd(r5.originalText, i5.right, r5), c3 = i5.type === "NGPipeExpression" ? "|" : i5.operator, p3 = i5.type === "NGPipeExpression" && i5.arguments.length !== 0 ? bd(Ad(md([Ed, ": ", gd(md([Ed, ":", Sd(" ")]), t4.map(n4, "arguments").map((e5) => vd(2, bd(e5))))]))) : "", d3 = md(s4 ? [c3, " ", t4.call(n4, "right"), p3] : [l4 ? Dd : "", c3, l4 ? " " : Dd, t4.call(n4, "right"), p3]), f3 = t4.getParentNode(), h3 = Zd(i5.left), m3 = h3 || !(o5 && i5.type === "LogicalExpression") && f3.type !== i5.type && i5.left.type !== i5.type && i5.right.type !== i5.type;
                  a5.push(l4 ? "" : " ", m3 ? bd(d3, {shouldBreak: h3}) : d3), u4 && i5.comments && (a5 = Pd(Di.printComments(t4, () => md(a5), r5).parts));
                } else
                  a5.push(bd(t4.call(n4)));
                return a5;
              }(e3, n3, t3, false, a4);
              if (a4)
                return md(i4);
              if ((r4.type === "CallExpression" || r4.type === "OptionalCallExpression") && r4.callee === u3 || r4.type === "UnaryExpression" || (r4.type === "MemberExpression" || r4.type === "OptionalMemberExpression") && !r4.computed)
                return bd(md([Ad(md([Ed, md(i4)])), Ed]));
              const s3 = r4.type === "ReturnStatement" || r4.type === "ThrowStatement" || r4.type === "JSXExpressionContainer" && o4.type === "JSXAttribute" || u3.operator !== "|" && r4.type === "JsExpressionRoot" || u3.type !== "NGPipeExpression" && (r4.type === "NGRoot" && t3.parser === "__ng_binding" || r4.type === "NGMicrosyntaxExpression" && o4.type === "NGMicrosyntax" && o4.body.length === 1) || u3 === r4.body && r4.type === "ArrowFunctionExpression" || u3 !== r4.body && r4.type === "ForStatement" || r4.type === "ConditionalExpression" && o4.type !== "ReturnStatement" && o4.type !== "ThrowStatement" && o4.type !== "CallExpression" && o4.type !== "OptionalCallExpression" || r4.type === "TemplateLiteral", l3 = r4.type === "AssignmentExpression" || r4.type === "VariableDeclarator" || r4.type === "ClassProperty" || r4.type === "TSAbstractClassProperty" || r4.type === "ClassPrivateProperty" || r4.type === "ObjectProperty" || r4.type === "Property", c2 = tf(u3.left) && jf(u3.operator, u3.left.operator);
              if (s3 || ph(u3) && !c2 || !ph(u3) && l3)
                return bd(md(i4));
              if (i4.length === 0)
                return "";
              const p2 = cf(u3.right), d2 = i4.findIndex((e4) => typeof e4 != "string" && e4.type === "group"), f2 = i4.slice(0, d2 === -1 ? 1 : d2 + 1), h2 = md(i4.slice(f2.length, p2 ? -1 : void 0)), m2 = Symbol("logicalChain-" + ++zf), g2 = bd(md([...f2, Ad(h2)]), {id: m2});
              if (!p2)
                return g2;
              const D2 = od(i4);
              return bd(md([g2, Sd(Ad(D2), D2, {groupId: m2})]));
            }
            case "AssignmentPattern":
              return md([e3.call(n3, "left"), " = ", e3.call(n3, "right")]);
            case "TSTypeAssertion": {
              const t4 = !(u3.expression.type === "ArrayExpression" || u3.expression.type === "ObjectExpression"), r4 = bd(md(["<", Ad(md([Ed, e3.call(n3, "typeAnnotation")])), Ed, ">"])), o4 = md([Sd("("), Ad(md([Ed, e3.call(n3, "expression")])), Ed, Sd(")")]);
              return t4 ? Fd([md([r4, e3.call(n3, "expression")]), md([r4, bd(o4, {shouldBreak: true})]), md([r4, e3.call(n3, "expression")])]) : bd(md([r4, e3.call(n3, "expression")]));
            }
            case "OptionalMemberExpression":
            case "MemberExpression": {
              const r4 = e3.getParentNode();
              let o4, a4 = 0;
              do {
                o4 = e3.getParentNode(a4), a4++;
              } while (o4 && (o4.type === "MemberExpression" || o4.type === "OptionalMemberExpression" || o4.type === "TSNonNullExpression"));
              const i4 = o4 && (o4.type === "NewExpression" || o4.type === "BindExpression" || o4.type === "VariableDeclarator" && o4.id.type !== "Identifier" || o4.type === "AssignmentExpression" && o4.left.type !== "Identifier") || u3.computed || u3.object.type === "Identifier" && u3.property.type === "Identifier" && r4.type !== "MemberExpression" && r4.type !== "OptionalMemberExpression";
              return md([e3.call(n3, "object"), i4 ? qf(e3, t3, n3) : bd(Ad(md([Ed, qf(e3, t3, n3)])))]);
            }
            case "MetaProperty":
              return md([e3.call(n3, "meta"), ".", e3.call(n3, "property")]);
            case "BindExpression":
              return u3.object && i3.push(e3.call(n3, "object")), i3.push(bd(Ad(md([Ed, Vf(e3, t3, n3)])))), md(i3);
            case "Identifier":
              return md([u3.name, Lf(e3), Kf(e3, t3, n3)]);
            case "V8IntrinsicIdentifier":
              return md(["%", u3.name]);
            case "SpreadElement":
            case "SpreadElementPattern":
            case "SpreadProperty":
            case "SpreadPropertyPattern":
            case "RestElement":
            case "ObjectTypeSpreadProperty":
              return md(["...", e3.call(n3, "argument"), Kf(e3, t3, n3)]);
            case "FunctionDeclaration":
            case "FunctionExpression":
              return i3.push(eh(e3, n3, t3)), u3.body || i3.push(o3), md(i3);
            case "ArrowFunctionExpression": {
              u3.async && i3.push("async "), Zf(e3, t3) ? i3.push(e3.call(n3, "params", 0)) : i3.push(bd(md([Qf(e3, n3, t3, r3 && (r3.expandLastArg || r3.expandFirstArg), true), th(e3, n3, t3)])));
              const o4 = Di.printDanglingComments(e3, t3, true, (e4) => {
                const n4 = hd(t3.originalText, e4, t3.locEnd);
                return n4 !== false && t3.originalText.slice(n4, n4 + 2) === "=>";
              });
              o4 && i3.push(" ", o4), i3.push(" =>");
              const a4 = e3.call((e4) => n3(e4, r3), "body");
              if (!Gd(t3.originalText, u3.body, t3) && (u3.body.type === "ArrayExpression" || u3.body.type === "ObjectExpression" || u3.body.type === "BlockStatement" || cf(u3.body) || Sf(u3.body, t3.originalText, t3) || u3.body.type === "ArrowFunctionExpression" || u3.body.type === "DoExpression"))
                return bd(md([md(i3), " ", a4]));
              if (u3.body.type === "SequenceExpression")
                return bd(md([md(i3), bd(md([" (", Ad(md([Ed, a4])), Ed, ")"]))]));
              const s3 = (r3 && r3.expandLastArg || e3.getParentNode().type === "JSXExpressionContainer") && !(u3.comments && u3.comments.length), l3 = r3 && r3.expandLastArg && If(t3, "all"), c2 = u3.body.type === "ConditionalExpression" && !Mf(u3.body, false);
              return bd(md([md(i3), bd(md([Ad(md([Dd, c2 ? Sd("", "(") : "", a4, c2 ? Sd("", ")") : ""])), s3 ? md([Sd(l3 ? "," : ""), Ed]) : ""]))]));
            }
            case "YieldExpression":
              return i3.push("yield"), u3.delegate && i3.push("*"), u3.argument && i3.push(" ", e3.call(n3, "argument")), md(i3);
            case "AwaitExpression": {
              i3.push("await"), u3.argument && i3.push(" ", e3.call(n3, "argument"));
              const t4 = e3.getParentNode();
              return (t4.type === "CallExpression" || t4.type === "OptionalCallExpression") && t4.callee === u3 || (t4.type === "MemberExpression" || t4.type === "OptionalMemberExpression") && t4.object === u3 ? bd(md([Ad(md([Ed, md(i3)])), Ed])) : md(i3);
            }
            case "ImportSpecifier":
              return u3.importKind && i3.push(e3.call(n3, "importKind"), " "), i3.push(e3.call(n3, "imported")), u3.local && u3.local.name !== u3.imported.name && i3.push(" as ", e3.call(n3, "local")), md(i3);
            case "ExportSpecifier":
              return i3.push(e3.call(n3, "local")), u3.exported && u3.exported.name !== u3.local.name && i3.push(" as ", e3.call(n3, "exported")), md(i3);
            case "ImportNamespaceSpecifier":
              return i3.push("* as "), i3.push(e3.call(n3, "local")), md(i3);
            case "ImportDefaultSpecifier":
              return e3.call(n3, "local");
            case "TSExportAssignment":
              return md(["export = ", e3.call(n3, "expression"), o3]);
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              return nh(e3, t3, n3);
            case "DeclareExportDeclaration":
              return md(["declare ", nh(e3, t3, n3)]);
            case "ExportAllDeclaration":
              return i3.push("export"), u3.exportKind === "type" && i3.push(" type"), i3.push(" *"), u3.exported && i3.push(" as ", e3.call(n3, "exported")), i3.push(Wf(e3, t3, n3), o3), md(i3);
            case "ExportNamespaceSpecifier":
              return md(["* as ", e3.call(n3, "exported")]);
            case "ExportDefaultSpecifier":
              return e3.call(n3, "exported");
            case "ImportDeclaration":
              return i3.push("import"), u3.importKind && u3.importKind !== "value" && i3.push(" ", u3.importKind), u3.specifiers && u3.specifiers.length > 0 ? (i3.push($f(e3, t3, n3)), i3.push(Wf(e3, t3, n3))) : u3.importKind && u3.importKind === "type" || /{\s*}/.test(t3.originalText.slice(t3.locStart(u3), t3.locStart(u3.source))) ? i3.push(" {}", Wf(e3, t3, n3)) : i3.push(" ", e3.call(n3, "source")), Array.isArray(u3.attributes) && u3.attributes.length !== 0 && i3.push(" with ", md(e3.map(n3, "attributes"))), i3.push(o3), md(i3);
            case "ImportAttribute":
              return md([e3.call(n3, "key"), ": ", e3.call(n3, "value")]);
            case "Import":
              return "import";
            case "TSModuleBlock":
            case "BlockStatement": {
              const r4 = e3.call((e4) => Gf(e4, t3, n3), "body"), a4 = u3.body.some((e4) => e4.type !== "EmptyStatement"), s3 = u3.directives && u3.directives.length > 0, l3 = e3.getParentNode(), c2 = e3.getParentNode(1);
              return a4 || s3 || Ud(u3) || l3.type !== "ArrowFunctionExpression" && l3.type !== "FunctionExpression" && l3.type !== "FunctionDeclaration" && l3.type !== "ObjectMethod" && l3.type !== "ClassMethod" && l3.type !== "ClassPrivateMethod" && l3.type !== "ForStatement" && l3.type !== "WhileStatement" && l3.type !== "DoWhileStatement" && l3.type !== "DoExpression" && (l3.type !== "CatchClause" || c2.finalizer) && l3.type !== "TSModuleDeclaration" ? (i3.push("{"), s3 && e3.each((e4) => {
                i3.push(Ad(md([yd, n3(e4), o3]))), fd(t3.originalText, e4.getValue(), t3.locEnd) && i3.push(yd);
              }, "directives"), a4 && i3.push(Ad(md([yd, r4]))), i3.push(Di.printDanglingComments(e3, t3)), i3.push(yd, "}"), md(i3)) : "{}";
            }
            case "ReturnStatement":
              return md(["return", Ch(e3, t3, n3)]);
            case "NewExpression":
            case "ImportExpression":
            case "OptionalCallExpression":
            case "CallExpression": {
              const r4 = u3.type === "NewExpression", o4 = u3.type === "ImportExpression", a4 = Lf(e3), i4 = o4 ? [u3.source] : u3.arguments;
              if (!o4 && !r4 && u3.callee.type === "Identifier" && (u3.callee.name === "require" || u3.callee.name === "define") || i4.length === 1 && Sf(i4[0], t3.originalText, t3) || !r4 && wf(u3, e3.getParentNode()))
                return md([r4 ? "new " : "", e3.call(n3, "callee"), a4, Rf(e3, t3, n3), md(["(", o4 ? e3.call(n3, "source") : gd(", ", e3.map(n3, "arguments")), ")"])]);
              const s3 = u3.callee && u3.callee.type === "Identifier" && zd(u3.callee.trailingComments);
              if (s3 && (u3.callee.trailingComments[0].printed = true), !o4 && !r4 && gf(u3.callee) && !e3.call((e4) => kc(e4, t3), "callee"))
                return _p(e3, t3, n3);
              const l3 = md([r4 ? "new " : "", o4 ? "import" : e3.call(n3, "callee"), a4, s3 ? "/*:: ".concat(u3.callee.trailingComments[0].value.slice(2).trim(), " */") : "", Rf(e3, t3, n3), np(e3, t3, n3)]);
              return o4 || nf(u3.callee) ? bd(l3) : l3;
            }
            case "ObjectTypeInternalSlot":
              return md([u3.static ? "static " : "", "[[", e3.call(n3, "id"), "]]", Lf(e3), u3.method ? "" : ": ", e3.call(n3, "value")]);
            case "ObjectExpression":
            case "ObjectPattern":
            case "ObjectTypeAnnotation":
            case "TSInterfaceBody":
            case "TSTypeLiteral":
            case "RecordExpression": {
              let r4;
              r4 = u3.type === "TSTypeLiteral" ? "members" : u3.type === "TSInterfaceBody" ? "body" : "properties";
              const a4 = u3.type === "ObjectTypeAnnotation", i4 = [];
              a4 && i4.push("indexers", "callProperties", "internalSlots"), i4.push(r4);
              const s3 = i4.map((e4) => u3[e4][0]).sort((e4, n4) => t3.locStart(e4) - t3.locStart(n4))[0], l3 = e3.getParentNode(0), c2 = a4 && l3 && (l3.type === "InterfaceDeclaration" || l3.type === "DeclareInterface" || l3.type === "DeclareClass") && e3.getName() === "body", p2 = u3.type === "TSInterfaceBody" || c2 || u3.type === "ObjectPattern" && l3.type !== "FunctionDeclaration" && l3.type !== "FunctionExpression" && l3.type !== "ArrowFunctionExpression" && l3.type !== "ObjectMethod" && l3.type !== "ClassMethod" && l3.type !== "ClassPrivateMethod" && l3.type !== "AssignmentPattern" && l3.type !== "CatchClause" && u3.properties.some((e4) => e4.value && (e4.value.type === "ObjectPattern" || e4.value.type === "ArrayPattern")) || u3.type !== "ObjectPattern" && s3 && ud(t3.originalText, t3.locStart(u3), t3.locStart(s3)), d2 = c2 ? ";" : u3.type === "TSInterfaceBody" || u3.type === "TSTypeLiteral" ? Sd(o3, ";") : ",", f2 = u3.type === "RecordExpression" ? "#{" : u3.exact ? "{|" : "{", h2 = u3.exact ? "|}" : "}", m2 = [];
              i4.forEach((r5) => {
                e3.each((e4) => {
                  const r6 = e4.getValue();
                  m2.push({node: r6, printed: n3(e4), loc: t3.locStart(r6)});
                }, r5);
              });
              let g2 = [];
              const D2 = m2.sort((e4, t4) => e4.loc - t4.loc).map((e4) => {
                const n4 = md(g2.concat(bd(e4.printed)));
                return g2 = [d2, Dd], e4.node.type !== "TSPropertySignature" && e4.node.type !== "TSMethodSignature" && e4.node.type !== "TSConstructSignatureDeclaration" || !cd(e4.node) || g2.shift(), fd(t3.originalText, e4.node, t3.locEnd) && g2.push(yd), n4;
              });
              if (u3.inexact) {
                let n4;
                if (Ud(u3)) {
                  const r5 = !u3.comments.every(Gs.isBlockComment), o4 = Di.printDanglingComments(e3, t3, true);
                  n4 = md([o4, r5 || rd(t3.originalText, t3.locEnd(u3.comments[u3.comments.length - 1])) ? yd : Dd, "..."]);
                } else
                  n4 = "...";
                D2.push(md(g2.concat(n4)));
              }
              const y2 = od(u3[r4]), E2 = !(u3.inexact || y2 && y2.type === "RestElement");
              let C2;
              if (D2.length === 0) {
                if (!Ud(u3))
                  return md([f2, h2, Kf(e3, t3, n3)]);
                C2 = bd(md([f2, Di.printDanglingComments(e3, t3), Ed, h2, Lf(e3), Kf(e3, t3, n3)]));
              } else
                C2 = md([f2, Ad(md([t3.bracketSpacing ? Dd : Ed, md(D2)])), Sd(E2 && (d2 !== "," || If(t3)) ? d2 : ""), md([t3.bracketSpacing ? Dd : Ed, h2]), Lf(e3), Kf(e3, t3, n3)]);
              return e3.match((e4) => e4.type === "ObjectPattern" && !e4.decorators, (e4, t4, n4) => yh(e4) && (t4 === "params" || t4 === "parameters") && n4 === 0) || e3.match(Dh, (e4, t4) => t4 === "typeAnnotation", (e4, t4) => t4 === "typeAnnotation", (e4, t4, n4) => yh(e4) && (t4 === "params" || t4 === "parameters") && n4 === 0) ? C2 : bd(C2, {shouldBreak: p2});
            }
            case "ObjectProperty":
            case "Property":
              return u3.method || u3.kind === "get" || u3.kind === "set" ? Xf(e3, t3, n3) : (u3.shorthand ? i3.push(e3.call(n3, "value")) : i3.push(fh(u3.key, Hf(e3, t3, n3), ":", u3.value, e3.call(n3, "value"), t3)), md(i3));
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "MethodDefinition":
            case "TSAbstractMethodDefinition":
            case "TSDeclareMethod":
              return u3.decorators && u3.decorators.length !== 0 && i3.push(Jf(e3, t3, n3)), u3.accessibility && i3.push(u3.accessibility + " "), u3.static && i3.push("static "), (u3.type === "TSAbstractMethodDefinition" || u3.abstract) && i3.push("abstract "), i3.push(Xf(e3, t3, n3)), md(i3);
            case "ObjectMethod":
              return Xf(e3, t3, n3);
            case "Decorator":
              return md(["@", e3.call(n3, "expression"), e3.call(n3, "callee")]);
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression": {
              const r4 = u3.type === "TupleExpression" ? "#[" : "[", o4 = "]";
              if (u3.elements.length === 0)
                Ud(u3) ? i3.push(bd(md([r4, Di.printDanglingComments(e3, t3), Ed, o4]))) : i3.push(r4, o4);
              else {
                const a4 = od(u3.elements), s3 = !(a4 && a4.type === "RestElement"), l3 = s3 && a4 === null, c2 = !t3.__inJestEach && u3.elements.length > 1 && u3.elements.every((e4, t4, n4) => {
                  const r5 = e4 && e4.type;
                  if (r5 !== "ArrayExpression" && r5 !== "ObjectExpression")
                    return false;
                  const u4 = n4[t4 + 1];
                  if (u4 && r5 !== u4.type)
                    return false;
                  const o5 = r5 === "ArrayExpression" ? "elements" : "properties";
                  return e4[o5] && e4[o5].length > 1;
                });
                i3.push(bd(md([r4, Ad(md([Ed, Eh(e3, t3, "elements", n3)])), l3 ? "," : "", Sd(s3 && !l3 && If(t3) ? "," : ""), Di.printDanglingComments(e3, t3, true), Ed, o4]), {shouldBreak: c2}));
              }
              return i3.push(Lf(e3), Kf(e3, t3, n3)), md(i3);
            }
            case "SequenceExpression": {
              const t4 = e3.getParentNode(0);
              if (t4.type === "ExpressionStatement" || t4.type === "ForStatement") {
                const t5 = [];
                return e3.each((e4) => {
                  e4.getName() === 0 ? t5.push(n3(e4)) : t5.push(",", Ad(md([Dd, n3(e4)])));
                }, "expressions"), bd(md(t5));
              }
              return bd(md([gd(md([",", Dd]), e3.map(n3, "expressions"))]));
            }
            case "ThisExpression":
              return "this";
            case "Super":
              return "super";
            case "NullLiteral":
              return "null";
            case "RegExpLiteral":
              return gh(u3);
            case "NumericLiteral":
              return sd(u3.extra.raw);
            case "DecimalLiteral":
              return sd(u3.value) + "m";
            case "BigIntLiteral":
              return (u3.bigint || u3.extra.raw).toLowerCase();
            case "BooleanLiteral":
            case "StringLiteral":
            case "Literal":
              return u3.regex ? gh(u3.regex) : u3.bigint ? u3.raw.toLowerCase() : typeof u3.value == "number" ? sd(u3.raw) : typeof u3.value != "string" ? "" + u3.value : mh(u3, t3);
            case "Directive":
              return e3.call(n3, "value");
            case "DirectiveLiteral":
              return mh(u3, t3);
            case "UnaryExpression":
              return i3.push(u3.operator), /[a-z]$/.test(u3.operator) && i3.push(" "), u3.argument.comments && u3.argument.comments.length > 0 ? i3.push(bd(md(["(", Ad(md([Ed, e3.call(n3, "argument")])), Ed, ")"]))) : i3.push(e3.call(n3, "argument")), md(i3);
            case "UpdateExpression":
              return i3.push(e3.call(n3, "argument"), u3.operator), u3.prefix && i3.reverse(), md(i3);
            case "ConditionalExpression":
              return td(e3, t3, n3, {beforeParts: () => [e3.call(n3, "test")], afterParts: (e4) => [e4 ? Ed : ""], shouldCheckJsx: true, conditionalNodeType: "ConditionalExpression", consequentNodePropertyName: "consequent", alternateNodePropertyName: "alternate", testNodePropertyNames: ["test"]});
            case "VariableDeclaration": {
              const t4 = e3.map((e4) => n3(e4), "declarations"), r4 = e3.getParentNode(), a4 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", s3 = u3.declarations.some((e4) => e4.init);
              let l3;
              return t4.length !== 1 || u3.declarations[0].comments ? t4.length > 0 && (l3 = Ad(t4[0])) : l3 = t4[0], i3 = [u3.declare ? "declare " : "", u3.kind, l3 ? md([" ", l3]) : "", Ad(md(t4.slice(1).map((e4) => md([",", s3 && !a4 ? yd : Dd, e4]))))], a4 && r4.body !== u3 || i3.push(o3), bd(md(i3));
            }
            case "TSTypeAliasDeclaration": {
              u3.declare && i3.push("declare ");
              const r4 = dh(u3.id, u3.typeAnnotation, u3.typeAnnotation && e3.call(n3, "typeAnnotation"), t3);
              return i3.push("type ", e3.call(n3, "id"), e3.call(n3, "typeParameters"), " =", r4, o3), bd(md(i3));
            }
            case "VariableDeclarator":
              return fh(u3.id, e3.call(n3, "id"), " =", u3.init, u3.init && e3.call(n3, "init"), t3);
            case "WithStatement":
              return bd(md(["with (", e3.call(n3, "object"), ")", hh(u3.body, e3.call(n3, "body"))]));
            case "IfStatement": {
              const r4 = hh(u3.consequent, e3.call(n3, "consequent")), o4 = bd(md(["if (", bd(md([Ad(md([Ed, e3.call(n3, "test")])), Ed])), ")", r4]));
              if (i3.push(o4), u3.alternate) {
                const r5 = Qd(u3.consequent) && u3.consequent.comments.some((e4) => e4.trailing && !Gs.isBlockComment(e4)) || Of(u3), o5 = u3.consequent.type === "BlockStatement" && !r5;
                i3.push(o5 ? " " : yd), Ud(u3) && i3.push(Di.printDanglingComments(e3, t3, true), r5 ? yd : " "), i3.push("else", bd(hh(u3.alternate, e3.call(n3, "alternate"), u3.alternate.type === "IfStatement")));
              }
              return md(i3);
            }
            case "ForStatement": {
              const r4 = hh(u3.body, e3.call(n3, "body")), o4 = Di.printDanglingComments(e3, t3, true), a4 = o4 ? md([o4, Ed]) : "";
              return u3.init || u3.test || u3.update ? md([a4, bd(md(["for (", bd(md([Ad(md([Ed, e3.call(n3, "init"), ";", Dd, e3.call(n3, "test"), ";", Dd, e3.call(n3, "update")])), Ed])), ")", r4]))]) : md([a4, bd(md(["for (;;)", r4]))]);
            }
            case "WhileStatement":
              return bd(md(["while (", bd(md([Ad(md([Ed, e3.call(n3, "test")])), Ed])), ")", hh(u3.body, e3.call(n3, "body"))]));
            case "ForInStatement":
              return bd(md([u3.each ? "for each (" : "for (", e3.call(n3, "left"), " in ", e3.call(n3, "right"), ")", hh(u3.body, e3.call(n3, "body"))]));
            case "ForOfStatement":
              return bd(md(["for", u3.await ? " await" : "", " (", e3.call(n3, "left"), " of ", e3.call(n3, "right"), ")", hh(u3.body, e3.call(n3, "body"))]));
            case "DoWhileStatement": {
              const t4 = hh(u3.body, e3.call(n3, "body")), r4 = bd(md(["do", t4]));
              return i3 = [r4], u3.body.type === "BlockStatement" ? i3.push(" ") : i3.push(yd), i3.push("while ("), i3.push(bd(md([Ad(md([Ed, e3.call(n3, "test")])), Ed])), ")", o3), md(i3);
            }
            case "DoExpression":
              return md(["do ", e3.call(n3, "body")]);
            case "BreakStatement":
              return i3.push("break"), u3.label && i3.push(" ", e3.call(n3, "label")), i3.push(o3), md(i3);
            case "ContinueStatement":
              return i3.push("continue"), u3.label && i3.push(" ", e3.call(n3, "label")), i3.push(o3), md(i3);
            case "LabeledStatement":
              return u3.body.type === "EmptyStatement" ? md([e3.call(n3, "label"), ":;"]) : md([e3.call(n3, "label"), ": ", e3.call(n3, "body")]);
            case "TryStatement":
              return md(["try ", e3.call(n3, "block"), u3.handler ? md([" ", e3.call(n3, "handler")]) : "", u3.finalizer ? md([" finally ", e3.call(n3, "finalizer")]) : ""]);
            case "CatchClause":
              if (u3.param) {
                const r4 = u3.param.comments && u3.param.comments.some((e4) => !Gs.isBlockComment(e4) || e4.leading && rd(t3.originalText, t3.locEnd(e4)) || e4.trailing && rd(t3.originalText, t3.locStart(e4), {backwards: true})), o4 = e3.call(n3, "param");
                return md(["catch ", md(r4 ? ["(", Ad(md([Ed, o4])), Ed, ") "] : ["(", o4, ") "]), e3.call(n3, "body")]);
              }
              return md(["catch ", e3.call(n3, "body")]);
            case "ThrowStatement":
              return md(["throw", Ch(e3, t3, n3)]);
            case "SwitchStatement":
              return md([bd(md(["switch (", Ad(md([Ed, e3.call(n3, "discriminant")])), Ed, ")"])), " {", u3.cases.length > 0 ? Ad(md([yd, gd(yd, e3.map((e4) => {
                const r4 = e4.getValue();
                return md([e4.call(n3), u3.cases.indexOf(r4) !== u3.cases.length - 1 && fd(t3.originalText, r4, t3.locEnd) ? yd : ""]);
              }, "cases"))])) : "", yd, "}"]);
            case "SwitchCase": {
              u3.test ? i3.push("case ", e3.call(n3, "test"), ":") : i3.push("default:");
              const r4 = u3.consequent.filter((e4) => e4.type !== "EmptyStatement");
              if (r4.length > 0) {
                const u4 = e3.call((e4) => Gf(e4, t3, n3), "consequent");
                i3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? md([" ", u4]) : Ad(md([yd, u4])));
              }
              return md(i3);
            }
            case "DebuggerStatement":
              return md(["debugger", o3]);
            case "JSXAttribute":
              if (i3.push(e3.call(n3, "name")), u3.value) {
                let r4;
                if (Ff(u3.value)) {
                  let e4 = Pf(u3.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                  const n4 = dd(e4, t3.jsxSingleQuote ? "'" : '"'), o4 = n4 === "'" ? "&apos;" : "&quot;";
                  e4 = e4.slice(1, -1).replace(new RegExp(n4, "g"), o4), r4 = md([n4, e4, n4]);
                } else
                  r4 = e3.call(n3, "value");
                i3.push("=", r4);
              }
              return md(i3);
            case "JSXIdentifier":
              return "" + u3.name;
            case "JSXNamespacedName":
              return gd(":", [e3.call(n3, "namespace"), e3.call(n3, "name")]);
            case "JSXMemberExpression":
              return gd(".", [e3.call(n3, "object"), e3.call(n3, "property")]);
            case "TSQualifiedName":
              return gd(".", [e3.call(n3, "left"), e3.call(n3, "right")]);
            case "JSXSpreadAttribute":
            case "JSXSpreadChild":
              return md(["{", e3.call((e4) => {
                const r4 = md(["...", n3(e4)]), u4 = e4.getValue();
                return u4.comments && u4.comments.length && bh(e4) ? md([Ad(md([Ed, Di.printComments(e4, () => r4, t3)])), Ed]) : r4;
              }, u3.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"]);
            case "JSXExpressionContainer": {
              const t4 = e3.getParentNode(0), r4 = u3.expression.comments && u3.expression.comments.length > 0, o4 = u3.expression.type === "JSXEmptyExpression" || !r4 && (u3.expression.type === "ArrayExpression" || u3.expression.type === "ObjectExpression" || u3.expression.type === "ArrowFunctionExpression" || u3.expression.type === "CallExpression" || u3.expression.type === "OptionalCallExpression" || u3.expression.type === "FunctionExpression" || u3.expression.type === "TemplateLiteral" || u3.expression.type === "TaggedTemplateExpression" || u3.expression.type === "DoExpression" || cf(t4) && (u3.expression.type === "ConditionalExpression" || tf(u3.expression)));
              return bd(o4 ? md(["{", e3.call(n3, "expression"), wd, "}"]) : md(["{", Ad(md([Ed, e3.call(n3, "expression")])), Ed, wd, "}"]));
            }
            case "JSXFragment":
            case "JSXElement": {
              const r4 = Di.printComments(e3, () => function(e4, t4, n4) {
                const r5 = e4.getValue();
                if (r5.type === "JSXElement" && rf(r5))
                  return md([e4.call(n4, "openingElement"), e4.call(n4, "closingElement")]);
                const u4 = r5.type === "JSXElement" ? e4.call(n4, "openingElement") : e4.call(n4, "openingFragment"), o4 = r5.type === "JSXElement" ? e4.call(n4, "closingElement") : e4.call(n4, "closingFragment");
                if (r5.children.length === 1 && r5.children[0].type === "JSXExpressionContainer" && (r5.children[0].expression.type === "TemplateLiteral" || r5.children[0].expression.type === "TaggedTemplateExpression"))
                  return md([u4, md(e4.map(n4, "children")), o4]);
                r5.children = r5.children.map((e5) => pf(e5) ? {type: "JSXText", value: " ", raw: " "} : e5);
                const a4 = r5.children.filter(cf).length > 0, i4 = r5.children.filter((e5) => e5.type === "JSXExpressionContainer").length > 1, s3 = r5.type === "JSXElement" && r5.openingElement.attributes.length > 1;
                let l3 = Td(u4) || a4 || s3 || i4;
                const c2 = e4.getParentNode().rootMarker === "mdx", p2 = t4.singleQuote ? "{' '}" : '{" "}', d2 = c2 ? md([" "]) : Sd(md([p2, Ed]), " "), f2 = r5.openingElement && r5.openingElement.name && r5.openingElement.name.name === "fbt", h2 = function(e5, t5, n5, r6, u5) {
                  const o5 = e5.getValue(), a5 = [];
                  return e5.map((e6, t6) => {
                    const i5 = e6.getValue();
                    if (ff(i5)) {
                      const e7 = Pf(i5);
                      if (hf(i5)) {
                        const n6 = e7.split(Nf);
                        if (n6[0] === "") {
                          if (a5.push(""), n6.shift(), /\n/.test(n6[0])) {
                            const e8 = o5.children[t6 + 1];
                            a5.push(ch(u5, n6[1], i5, e8));
                          } else
                            a5.push(r6);
                          n6.shift();
                        }
                        let s4;
                        if (od(n6) === "" && (n6.pop(), s4 = n6.pop()), n6.length === 0)
                          return;
                        if (n6.forEach((e8, t7) => {
                          t7 % 2 == 1 ? a5.push(Dd) : a5.push(e8);
                        }), s4 !== void 0)
                          if (/\n/.test(s4)) {
                            const e8 = o5.children[t6 + 1];
                            a5.push(ch(u5, od(a5), i5, e8));
                          } else
                            a5.push(r6);
                        else {
                          const e8 = o5.children[t6 + 1];
                          a5.push(lh(u5, od(a5), i5, e8));
                        }
                      } else
                        /\n/.test(e7) ? e7.match(/\n/g).length > 1 && (a5.push(""), a5.push(yd)) : (a5.push(""), a5.push(r6));
                    } else {
                      const r7 = n5(e6);
                      a5.push(r7);
                      const s4 = o5.children[t6 + 1];
                      if (s4 && hf(s4)) {
                        const e7 = Pf(s4).trim().split(Nf)[0];
                        a5.push(lh(u5, e7, i5, s4));
                      } else
                        a5.push(yd);
                    }
                  }, "children"), a5;
                }(e4, 0, n4, d2, f2), m2 = r5.children.some((e5) => hf(e5));
                for (let e5 = h2.length - 2; e5 >= 0; e5--) {
                  const t5 = h2[e5] === "" && h2[e5 + 1] === "", n5 = h2[e5] === yd && h2[e5 + 1] === "" && h2[e5 + 2] === yd, r6 = (h2[e5] === Ed || h2[e5] === yd) && h2[e5 + 1] === "" && h2[e5 + 2] === d2, u5 = h2[e5] === d2 && h2[e5 + 1] === "" && (h2[e5 + 2] === Ed || h2[e5 + 2] === yd), o5 = h2[e5] === d2 && h2[e5 + 1] === "" && h2[e5 + 2] === d2, a5 = h2[e5] === Ed && h2[e5 + 1] === "" && h2[e5 + 2] === yd || h2[e5] === yd && h2[e5 + 1] === "" && h2[e5 + 2] === Ed;
                  n5 && m2 || t5 || r6 || o5 || a5 ? h2.splice(e5, 2) : u5 && h2.splice(e5 + 1, 2);
                }
                for (; h2.length && (kd(od(h2)) || Nd(od(h2))); )
                  h2.pop();
                for (; h2.length && (kd(h2[0]) || Nd(h2[0])) && (kd(h2[1]) || Nd(h2[1])); )
                  h2.shift(), h2.shift();
                const g2 = [];
                h2.forEach((e5, t5) => {
                  if (e5 === d2) {
                    if (t5 === 1 && h2[t5 - 1] === "")
                      return h2.length === 2 ? void g2.push(p2) : void g2.push(md([p2, yd]));
                    if (t5 === h2.length - 1)
                      return void g2.push(p2);
                    if (h2[t5 - 1] === "" && h2[t5 - 2] === yd)
                      return void g2.push(p2);
                  }
                  g2.push(e5), Td(e5) && (l3 = true);
                });
                const D2 = m2 ? xd(g2) : bd(md(g2), {shouldBreak: true});
                if (c2)
                  return D2;
                const y2 = bd(md([u4, Ad(md([yd, D2])), yd, o4]));
                if (l3)
                  return y2;
                return Fd([bd(md([u4, md(h2), o4])), y2]);
              }(e3, t3, n3), t3);
              return function(e4, t4, n4) {
                const r5 = e4.getParentNode();
                if (!r5)
                  return t4;
                if ({ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true}[r5.type])
                  return t4;
                const u4 = e4.match(void 0, (e5) => e5.type === "ArrowFunctionExpression", nf, (e5) => e5.type === "JSXExpressionContainer"), o4 = kc(e4, n4);
                return bd(md([o4 ? "" : Sd("("), Ad(md([Ed, t4])), Ed, o4 ? "" : Sd(")")]), {shouldBreak: u4});
              }(e3, r4, t3);
            }
            case "JSXOpeningElement": {
              const r4 = e3.getValue(), u4 = r4.name && r4.name.comments && r4.name.comments.length > 0 || r4.typeParameters && r4.typeParameters.comments && r4.typeParameters.comments.length > 0;
              if (r4.selfClosing && !r4.attributes.length && !u4)
                return md(["<", e3.call(n3, "name"), e3.call(n3, "typeParameters"), " />"]);
              if (r4.attributes && r4.attributes.length === 1 && r4.attributes[0].value && Ff(r4.attributes[0].value) && !r4.attributes[0].value.value.includes("\n") && !u4 && (!r4.attributes[0].comments || !r4.attributes[0].comments.length))
                return bd(md(["<", e3.call(n3, "name"), e3.call(n3, "typeParameters"), " ", md(e3.map(n3, "attributes")), r4.selfClosing ? " />" : ">"]));
              const o4 = r4.attributes.length && Qd(od(r4.attributes)), a4 = !r4.attributes.length && !u4 || t3.jsxBracketSameLine && (!u4 || r4.attributes.length) && !o4, i4 = r4.attributes && r4.attributes.some((e4) => e4.value && Ff(e4.value) && e4.value.value.includes("\n"));
              return bd(md(["<", e3.call(n3, "name"), e3.call(n3, "typeParameters"), md([Ad(md(e3.map((e4) => md([Dd, n3(e4)]), "attributes"))), r4.selfClosing ? Dd : a4 ? ">" : Ed]), r4.selfClosing ? "/>" : a4 ? "" : ">"]), {shouldBreak: i4});
            }
            case "JSXClosingElement":
              return md(["</", e3.call(n3, "name"), ">"]);
            case "JSXOpeningFragment":
            case "JSXClosingFragment": {
              const n4 = u3.comments && u3.comments.length, r4 = n4 && !u3.comments.every(Gs.isBlockComment), o4 = u3.type === "JSXOpeningFragment";
              return md([o4 ? "<" : "</", Ad(md([r4 ? yd : n4 && !o4 ? " " : "", Di.printDanglingComments(e3, t3, true)])), r4 ? yd : "", ">"]);
            }
            case "JSXText":
              throw new Error("JSXTest should be handled by JSXElement");
            case "JSXEmptyExpression": {
              const n4 = u3.comments && !u3.comments.every(Gs.isBlockComment);
              return md([Di.printDanglingComments(e3, t3, !n4), n4 ? yd : ""]);
            }
            case "ClassBody":
              return u3.comments || u3.body.length !== 0 ? md(["{", u3.body.length > 0 ? Ad(md([yd, e3.call((e4) => Gf(e4, t3, n3), "body")])) : Di.printDanglingComments(e3, t3), yd, "}"]) : "{}";
            case "ClassProperty":
            case "TSAbstractClassProperty":
            case "ClassPrivateProperty": {
              u3.decorators && u3.decorators.length !== 0 && i3.push(Jf(e3, t3, n3)), u3.accessibility && i3.push(u3.accessibility + " "), u3.declare && i3.push("declare "), u3.static && i3.push("static "), (u3.type === "TSAbstractClassProperty" || u3.abstract) && i3.push("abstract "), u3.readonly && i3.push("readonly ");
              const r4 = qd(u3);
              return r4 && i3.push(r4), i3.push(Hf(e3, t3, n3), Lf(e3), Kf(e3, t3, n3)), u3.value && i3.push(" =", dh(u3.key, u3.value, e3.call(n3, "value"), t3)), i3.push(o3), bd(md(i3));
            }
            case "ClassDeclaration":
            case "ClassExpression":
              return u3.declare && i3.push("declare "), i3.push(md(sh(e3, t3, n3))), md(i3);
            case "TSInterfaceHeritage":
            case "TSExpressionWithTypeArguments":
              return i3.push(e3.call(n3, "expression")), u3.typeParameters && i3.push(e3.call(n3, "typeParameters")), md(i3);
            case "TemplateElement":
              return gd(Cd, u3.value.raw.split(/\r?\n/g));
            case "TemplateLiteral": {
              const r4 = e3.getParentNode();
              if (lf(u3, r4)) {
                const r5 = function(e4, t4, n4) {
                  const r6 = e4.getNode(), u4 = r6.quasis[0].value.raw.trim().split(/\s*\|\s*/);
                  if (u4.length > 1 || u4.some((e5) => e5.length !== 0)) {
                    t4.__inJestEach = true;
                    const o5 = e4.map(n4, "expressions");
                    t4.__inJestEach = false;
                    const a5 = [], i4 = o5.map((e5) => "${" + _d(e5, Object.assign({}, t4, {printWidth: 1 / 0, endOfLine: "lf"})).formatted + "}"), s3 = [{hasLineBreak: false, cells: []}];
                    for (let e5 = 1; e5 < r6.quasis.length; e5++) {
                      const t5 = s3[s3.length - 1], n5 = i4[e5 - 1];
                      t5.cells.push(n5), n5.includes("\n") && (t5.hasLineBreak = true), r6.quasis[e5].value.raw.includes("\n") && s3.push({hasLineBreak: false, cells: []});
                    }
                    const l3 = Math.max(u4.length, ...s3.map((e5) => e5.cells.length)), c2 = Array.from({length: l3}).fill(0), p2 = [{cells: u4}, ...s3.filter((e5) => e5.cells.length !== 0)];
                    for (const {cells: e5} of p2.filter((e6) => !e6.hasLineBreak))
                      e5.forEach((e6, t5) => {
                        c2[t5] = Math.max(c2[t5], ad(e6));
                      });
                    return a5.push(wd, "`", Ad(md([yd, gd(yd, p2.map((e5) => gd(" | ", e5.cells.map((t5, n5) => e5.hasLineBreak ? t5 : t5 + " ".repeat(c2[n5] - ad(t5))))))])), yd, "`"), md(a5);
                  }
                }(e3, t3, n3);
                if (r5)
                  return r5;
              }
              let o4 = e3.map(n3, "expressions");
              const a4 = vf(u3);
              return a4 && (o4 = o4.map((e4) => _d(e4, Object.assign({}, t3, {printWidth: 1 / 0})).formatted)), i3.push(wd, "`"), e3.each((e4) => {
                const r5 = e4.getName();
                if (i3.push(n3(e4)), r5 < o4.length) {
                  const {tabWidth: n4} = t3, s3 = e4.getValue(), l3 = pd(s3.value.raw, n4);
                  let c2 = o4[r5];
                  a4 || (u3.expressions[r5].comments && u3.expressions[r5].comments.length || u3.expressions[r5].type === "MemberExpression" || u3.expressions[r5].type === "OptionalMemberExpression" || u3.expressions[r5].type === "ConditionalExpression" || u3.expressions[r5].type === "SequenceExpression" || u3.expressions[r5].type === "TSAsExpression" || tf(u3.expressions[r5])) && (c2 = md([Ad(md([Ed, c2])), Ed]));
                  const p2 = l3 === 0 && s3.value.raw.endsWith("\n") ? vd(-1 / 0, c2) : Bd(c2, l3, n4);
                  i3.push(bd(md(["${", p2, wd, "}"])));
                }
              }, "quasis"), i3.push("`"), md(i3);
            }
            case "TaggedTemplateExpression":
              return md([e3.call(n3, "tag"), e3.call(n3, "typeParameters"), e3.call(n3, "quasi")]);
            case "Node":
            case "Printable":
            case "SourceLocation":
            case "Position":
            case "Statement":
            case "Function":
            case "Pattern":
            case "Expression":
            case "Declaration":
            case "Specifier":
            case "NamedSpecifier":
            case "Comment":
            case "MemberTypeAnnotation":
            case "Type":
              throw new Error("unprintable type: " + JSON.stringify(u3.type));
            case "TypeAnnotation":
            case "TSTypeAnnotation":
              return u3.typeAnnotation ? e3.call(n3, "typeAnnotation") : "";
            case "TSNamedTupleMember":
              return md([e3.call(n3, "label"), u3.optional ? "?" : "", ": ", e3.call(n3, "elementType")]);
            case "TSTupleType":
            case "TupleTypeAnnotation": {
              const r4 = u3.type === "TSTupleType" ? "elementTypes" : "types", o4 = u3[r4].length > 0 && od(u3[r4]).type === "TSRestType";
              return bd(md(["[", Ad(md([Ed, Eh(e3, t3, r4, n3)])), Sd(If(t3, "all") && !o4 ? "," : ""), Di.printDanglingComments(e3, t3, true), Ed, "]"]));
            }
            case "ExistsTypeAnnotation":
              return "*";
            case "EmptyTypeAnnotation":
              return "empty";
            case "AnyTypeAnnotation":
              return "any";
            case "MixedTypeAnnotation":
              return "mixed";
            case "ArrayTypeAnnotation":
              return md([e3.call(n3, "elementType"), "[]"]);
            case "BooleanTypeAnnotation":
              return "boolean";
            case "BooleanLiteralTypeAnnotation":
              return "" + u3.value;
            case "DeclareClass":
              return rh(e3, sh(e3, t3, n3));
            case "TSDeclareFunction":
              return md([u3.declare ? "declare " : "", eh(e3, n3, t3), o3]);
            case "DeclareFunction":
              return rh(e3, ["function ", e3.call(n3, "id"), u3.predicate ? " " : "", e3.call(n3, "predicate"), o3]);
            case "DeclareModule":
              return rh(e3, ["module ", e3.call(n3, "id"), " ", e3.call(n3, "body")]);
            case "DeclareModuleExports":
              return rh(e3, ["module.exports", ": ", e3.call(n3, "typeAnnotation"), o3]);
            case "DeclareVariable":
              return rh(e3, ["var ", e3.call(n3, "id"), o3]);
            case "DeclareExportAllDeclaration":
              return md(["declare export *", Wf(e3, t3, n3)]);
            case "DeclareOpaqueType":
            case "OpaqueType":
              return i3.push("opaque type ", e3.call(n3, "id"), e3.call(n3, "typeParameters")), u3.supertype && i3.push(": ", e3.call(n3, "supertype")), u3.impltype && i3.push(" = ", e3.call(n3, "impltype")), i3.push(o3), u3.type === "DeclareOpaqueType" ? rh(e3, i3) : md(i3);
            case "EnumDeclaration":
              return md(["enum ", e3.call(n3, "id"), " ", e3.call(n3, "body")]);
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              if (u3.type === "EnumSymbolBody" || u3.explicitType) {
                let e4 = null;
                switch (u3.type) {
                  case "EnumBooleanBody":
                    e4 = "boolean";
                    break;
                  case "EnumNumberBody":
                    e4 = "number";
                    break;
                  case "EnumStringBody":
                    e4 = "string";
                    break;
                  case "EnumSymbolBody":
                    e4 = "symbol";
                }
                i3.push("of ", e4, " ");
              }
              return u3.members.length === 0 ? i3.push(bd(md(["{", Di.printDanglingComments(e3, t3), Ed, "}"]))) : i3.push(bd(md(["{", Ad(md([yd, Eh(e3, t3, "members", n3), If(t3) ? "," : ""])), Di.printDanglingComments(e3, t3, true), yd, "}"]))), md(i3);
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
              return md([e3.call(n3, "id"), " = ", typeof u3.init == "object" ? e3.call(n3, "init") : String(u3.init)]);
            case "EnumDefaultedMember":
              return e3.call(n3, "id");
            case "FunctionTypeAnnotation":
            case "TSFunctionType": {
              const r4 = e3.getParentNode(0), o4 = e3.getParentNode(1), a4 = e3.getParentNode(2);
              let s3 = u3.type === "TSFunctionType" || !((r4.type === "ObjectTypeProperty" || r4.type === "ObjectTypeInternalSlot") && !qd(r4) && !r4.optional && t3.locStart(r4) === t3.locStart(u3) || r4.type === "ObjectTypeCallProperty" || a4 && a4.type === "DeclareFunction"), l3 = s3 && (r4.type === "TypeAnnotation" || r4.type === "TSTypeAnnotation");
              const c2 = l3 && s3 && (r4.type === "TypeAnnotation" || r4.type === "TSTypeAnnotation") && o4.type === "ArrowFunctionExpression";
              return Cf(r4, t3) && (s3 = true, l3 = true), c2 && i3.push("("), i3.push(Qf(e3, n3, t3, false, true)), (u3.returnType || u3.predicate || u3.typeAnnotation) && i3.push(s3 ? " => " : ": ", e3.call(n3, "returnType"), e3.call(n3, "predicate"), e3.call(n3, "typeAnnotation")), c2 && i3.push(")"), bd(md(i3));
            }
            case "TSRestType":
              return md(["...", e3.call(n3, "typeAnnotation")]);
            case "TSOptionalType":
              return md([e3.call(n3, "typeAnnotation"), "?"]);
            case "FunctionTypeParam":
              return md([e3.call(n3, "name"), Lf(e3), u3.name ? ": " : "", e3.call(n3, "typeAnnotation")]);
            case "GenericTypeAnnotation":
              return md([e3.call(n3, "id"), e3.call(n3, "typeParameters")]);
            case "DeclareInterface":
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
            case "TSInterfaceDeclaration": {
              (u3.type === "DeclareInterface" || u3.declare) && i3.push("declare "), u3.type === "TSInterfaceDeclaration" && i3.push(u3.abstract ? "abstract " : "", uh(e3, t3, n3)), i3.push("interface");
              const r4 = [], o4 = [];
              u3.type !== "InterfaceTypeAnnotation" && r4.push(" ", e3.call(n3, "id"), e3.call(n3, "typeParameters"));
              const a4 = u3.typeParameters && !Zd(u3.typeParameters);
              if (u3.extends && u3.extends.length !== 0 && o4.push(a4 ? Sd(" ", Dd, {groupId: ah(u3.typeParameters)}) : Dd, "extends ", (u3.extends.length === 1 ? ef : Ad)(gd(md([",", Dd]), e3.map(n3, "extends")))), u3.id && Qd(u3.id) || u3.extends && u3.extends.length !== 0) {
                const e4 = md(o4);
                a4 ? i3.push(bd(md(r4.concat(Sd(Ad(e4), e4))))) : i3.push(bd(Ad(md(r4.concat(e4)))));
              } else
                i3.push(...r4, ...o4);
              return i3.push(" ", e3.call(n3, "body")), bd(md(i3));
            }
            case "ClassImplements":
            case "InterfaceExtends":
              return md([e3.call(n3, "id"), e3.call(n3, "typeParameters")]);
            case "TSClassImplements":
              return md([e3.call(n3, "expression"), e3.call(n3, "typeParameters")]);
            case "TSIntersectionType":
            case "IntersectionTypeAnnotation": {
              const t4 = e3.map(n3, "types"), r4 = [];
              let o4 = false;
              for (let e4 = 0; e4 < t4.length; ++e4)
                e4 === 0 ? r4.push(t4[e4]) : Ef(u3.types[e4 - 1]) && Ef(u3.types[e4]) ? r4.push(md([" & ", o4 ? Ad(t4[e4]) : t4[e4]])) : Ef(u3.types[e4 - 1]) || Ef(u3.types[e4]) ? (e4 > 1 && (o4 = true), r4.push(" & ", e4 > 1 ? Ad(t4[e4]) : t4[e4])) : r4.push(Ad(md([" &", Dd, t4[e4]])));
              return bd(md(r4));
            }
            case "TSUnionType":
            case "UnionTypeAnnotation": {
              const r4 = e3.getParentNode(), o4 = !(r4.type === "TypeParameterInstantiation" || r4.type === "TSTypeParameterInstantiation" || r4.type === "GenericTypeAnnotation" || r4.type === "TSTypeReference" || r4.type === "TSTypeAssertion" || r4.type === "TupleTypeAnnotation" || r4.type === "TSTupleType" || r4.type === "FunctionTypeParam" && !r4.name || (r4.type === "TypeAlias" || r4.type === "VariableDeclarator" || r4.type === "TSTypeAliasDeclaration") && Gd(t3.originalText, u3, t3)), a4 = Dh(u3), i4 = e3.map((e4) => {
                let r5 = e4.call(n3);
                return a4 || (r5 = vd(2, r5)), Di.printComments(e4, () => r5, t3);
              }, "types");
              if (a4)
                return gd(" | ", i4);
              const s3 = o4 && !Gd(t3.originalText, u3, t3), l3 = md([Sd(md([s3 ? Dd : "", "| "])), gd(md([Dd, "| "]), i4)]);
              return kc(e3, t3) ? bd(md([Ad(l3), Ed])) : r4.type === "TupleTypeAnnotation" && r4.types.length > 1 || r4.type === "TSTupleType" && r4.elementTypes.length > 1 ? bd(md([Ad(md([Sd(md(["(", Ed])), l3])), Ed, Sd(")")])) : bd(o4 ? Ad(l3) : l3);
            }
            case "NullableTypeAnnotation":
              return md(["?", e3.call(n3, "typeAnnotation")]);
            case "TSNullKeyword":
            case "NullLiteralTypeAnnotation":
              return "null";
            case "ThisTypeAnnotation":
              return "this";
            case "NumberTypeAnnotation":
              return "number";
            case "SymbolTypeAnnotation":
              return "symbol";
            case "ObjectTypeCallProperty":
              return u3.static && i3.push("static "), i3.push(e3.call(n3, "value")), md(i3);
            case "ObjectTypeIndexer": {
              const t4 = qd(u3);
              return md([t4 || "", "[", e3.call(n3, "id"), u3.id ? ": " : "", e3.call(n3, "key"), "]: ", e3.call(n3, "value")]);
            }
            case "ObjectTypeProperty": {
              const r4 = qd(u3);
              let o4 = "";
              return u3.proto ? o4 = "proto " : u3.static && (o4 = "static "), md([o4, sf(u3) ? u3.kind + " " : "", r4 || "", Hf(e3, t3, n3), Lf(e3), af(u3, t3) ? "" : ": ", e3.call(n3, "value")]);
            }
            case "QualifiedTypeIdentifier":
              return md([e3.call(n3, "qualification"), ".", e3.call(n3, "id")]);
            case "StringLiteralTypeAnnotation":
              return mh(u3, t3);
            case "NumberLiteralTypeAnnotation":
              return Xa.strictEqual(typeof u3.value, "number"), u3.extra != null ? sd(u3.extra.raw) : sd(u3.raw);
            case "StringTypeAnnotation":
              return "string";
            case "DeclareTypeAlias":
            case "TypeAlias": {
              (u3.type === "DeclareTypeAlias" || u3.declare) && i3.push("declare ");
              const r4 = dh(u3.id, u3.right, e3.call(n3, "right"), t3);
              return i3.push("type ", e3.call(n3, "id"), e3.call(n3, "typeParameters"), " =", r4, o3), bd(md(i3));
            }
            case "TypeCastExpression":
              return md(["(", e3.call(n3, "expression"), Kf(e3, t3, n3), ")"]);
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation": {
              const r4 = e3.getValue(), u4 = t3.originalText.slice(0, t3.locStart(r4)).lastIndexOf("/*");
              return u4 >= 0 && t3.originalText.slice(u4).match(/^\/\*\s*::/) ? md(["/*:: ", ih(e3, t3, n3, "params"), " */"]) : ih(e3, t3, n3, "params");
            }
            case "TSTypeParameterDeclaration":
            case "TSTypeParameterInstantiation":
              return ih(e3, t3, n3, "params");
            case "TSTypeParameter":
            case "TypeParameter": {
              const r4 = e3.getParentNode();
              if (r4.type === "TSMappedType")
                return i3.push("[", e3.call(n3, "name")), u3.constraint && i3.push(" in ", e3.call(n3, "constraint")), i3.push("]"), md(i3);
              const o4 = qd(u3);
              o4 && i3.push(o4), i3.push(e3.call(n3, "name")), u3.bound && (i3.push(": "), i3.push(e3.call(n3, "bound"))), u3.constraint && i3.push(" extends ", e3.call(n3, "constraint")), u3.default && i3.push(" = ", e3.call(n3, "default"));
              const a4 = e3.getNode(2);
              return r4.params && r4.params.length === 1 && Tf(t3) && !u3.constraint && a4.type === "ArrowFunctionExpression" && i3.push(","), md(i3);
            }
            case "TypeofTypeAnnotation":
              return md(["typeof ", e3.call(n3, "argument")]);
            case "VoidTypeAnnotation":
              return "void";
            case "InferredPredicate":
              return "%checks";
            case "DeclaredPredicate":
              return md(["%checks(", e3.call(n3, "value"), ")"]);
            case "TSAbstractKeyword":
              return "abstract";
            case "TSAnyKeyword":
              return "any";
            case "TSAsyncKeyword":
              return "async";
            case "TSBooleanKeyword":
              return "boolean";
            case "TSBigIntKeyword":
              return "bigint";
            case "TSConstKeyword":
              return "const";
            case "TSDeclareKeyword":
              return "declare";
            case "TSExportKeyword":
              return "export";
            case "TSNeverKeyword":
              return "never";
            case "TSNumberKeyword":
              return "number";
            case "TSObjectKeyword":
              return "object";
            case "TSProtectedKeyword":
              return "protected";
            case "TSPrivateKeyword":
              return "private";
            case "TSPublicKeyword":
              return "public";
            case "TSReadonlyKeyword":
              return "readonly";
            case "TSSymbolKeyword":
              return "symbol";
            case "TSStaticKeyword":
              return "static";
            case "TSStringKeyword":
              return "string";
            case "TSUndefinedKeyword":
              return "undefined";
            case "TSUnknownKeyword":
              return "unknown";
            case "TSVoidKeyword":
              return "void";
            case "TSAsExpression":
              return md([e3.call(n3, "expression"), " as ", e3.call(n3, "typeAnnotation")]);
            case "TSArrayType":
              return md([e3.call(n3, "elementType"), "[]"]);
            case "TSPropertySignature":
              return u3.export && i3.push("export "), u3.accessibility && i3.push(u3.accessibility + " "), u3.static && i3.push("static "), u3.readonly && i3.push("readonly "), i3.push(Hf(e3, t3, n3), Lf(e3)), u3.typeAnnotation && (i3.push(": "), i3.push(e3.call(n3, "typeAnnotation"))), u3.initializer && i3.push(" = ", e3.call(n3, "initializer")), md(i3);
            case "TSParameterProperty":
              return u3.accessibility && i3.push(u3.accessibility + " "), u3.export && i3.push("export "), u3.static && i3.push("static "), u3.readonly && i3.push("readonly "), i3.push(e3.call(n3, "parameter")), md(i3);
            case "TSTypeReference":
              return md([e3.call(n3, "typeName"), ih(e3, t3, n3, "typeParameters")]);
            case "TSTypeQuery":
              return md(["typeof ", e3.call(n3, "exprName")]);
            case "TSIndexSignature": {
              const r4 = e3.getParentNode(), a4 = u3.parameters.length > 1 ? Sd(If(t3) ? "," : "") : "", i4 = bd(md([Ad(md([Ed, gd(md([", ", Ed]), e3.map(n3, "parameters"))])), a4, Ed]));
              return md([u3.export ? "export " : "", u3.accessibility ? md([u3.accessibility, " "]) : "", u3.static ? "static " : "", u3.readonly ? "readonly " : "", "[", u3.parameters ? i4 : "", u3.typeAnnotation ? "]: " : "]", u3.typeAnnotation ? e3.call(n3, "typeAnnotation") : "", r4.type === "ClassBody" ? o3 : ""]);
            }
            case "TSTypePredicate":
              return md([u3.asserts ? "asserts " : "", e3.call(n3, "parameterName"), u3.typeAnnotation ? md([" is ", e3.call(n3, "typeAnnotation")]) : ""]);
            case "TSNonNullExpression":
              return md([e3.call(n3, "expression"), "!"]);
            case "TSThisType":
              return "this";
            case "TSImportType":
              return md([u3.isTypeOf ? "typeof " : "", "import(", e3.call(n3, u3.parameter ? "parameter" : "argument"), ")", u3.qualifier ? md([".", e3.call(n3, "qualifier")]) : "", ih(e3, t3, n3, "typeParameters")]);
            case "TSLiteralType":
              return e3.call(n3, "literal");
            case "TSIndexedAccessType":
              return md([e3.call(n3, "objectType"), "[", e3.call(n3, "indexType"), "]"]);
            case "TSConstructSignatureDeclaration":
            case "TSCallSignatureDeclaration":
            case "TSConstructorType":
              if (u3.type !== "TSCallSignatureDeclaration" && i3.push("new "), i3.push(bd(Qf(e3, n3, t3, false, true))), u3.returnType || u3.typeAnnotation) {
                const t4 = u3.type === "TSConstructorType";
                i3.push(t4 ? " => " : ": ", e3.call(n3, "returnType"), e3.call(n3, "typeAnnotation"));
              }
              return md(i3);
            case "TSTypeOperator":
              return md([u3.operator, " ", e3.call(n3, "typeAnnotation")]);
            case "TSMappedType": {
              const r4 = ud(t3.originalText, t3.locStart(u3), t3.locEnd(u3));
              return bd(md(["{", Ad(md([t3.bracketSpacing ? Dd : Ed, u3.readonly ? md([$d(u3.readonly, "readonly"), " "]) : "", uh(e3, t3, n3), e3.call(n3, "typeParameter"), u3.optional ? $d(u3.optional, "?") : "", u3.typeAnnotation ? ": " : "", e3.call(n3, "typeAnnotation"), Sd(o3, "")])), Di.printDanglingComments(e3, t3, true), t3.bracketSpacing ? Dd : Ed, "}"]), {shouldBreak: r4});
            }
            case "TSMethodSignature":
              return i3.push(u3.accessibility ? md([u3.accessibility, " "]) : "", u3.export ? "export " : "", u3.static ? "static " : "", u3.readonly ? "readonly " : "", u3.computed ? "[" : "", e3.call(n3, "key"), u3.computed ? "]" : "", Lf(e3), Qf(e3, n3, t3, false, true)), (u3.returnType || u3.typeAnnotation) && i3.push(": ", e3.call(n3, "returnType"), e3.call(n3, "typeAnnotation")), bd(md(i3));
            case "TSNamespaceExportDeclaration":
              return i3.push("export as namespace ", e3.call(n3, "id")), t3.semi && i3.push(";"), bd(md(i3));
            case "TSEnumDeclaration":
              return u3.declare && i3.push("declare "), u3.modifiers && i3.push(uh(e3, t3, n3)), u3.const && i3.push("const "), i3.push("enum ", e3.call(n3, "id"), " "), u3.members.length === 0 ? i3.push(bd(md(["{", Di.printDanglingComments(e3, t3), Ed, "}"]))) : i3.push(bd(md(["{", Ad(md([yd, Eh(e3, t3, "members", n3), If(t3, "es5") ? "," : ""])), Di.printDanglingComments(e3, t3, true), yd, "}"]))), md(i3);
            case "TSEnumMember":
              return i3.push(e3.call(n3, "id")), u3.initializer && i3.push(" = ", e3.call(n3, "initializer")), md(i3);
            case "TSImportEqualsDeclaration":
              return u3.isExport && i3.push("export "), i3.push("import ", e3.call(n3, "id"), " = ", e3.call(n3, "moduleReference")), t3.semi && i3.push(";"), bd(md(i3));
            case "TSExternalModuleReference":
              return md(["require(", e3.call(n3, "expression"), ")"]);
            case "TSModuleDeclaration": {
              const r4 = e3.getParentNode(), a4 = ff(u3.id), s3 = r4.type === "TSModuleDeclaration", l3 = u3.body && u3.body.type === "TSModuleDeclaration";
              if (s3)
                i3.push(".");
              else {
                u3.declare && i3.push("declare "), i3.push(uh(e3, t3, n3));
                const r5 = t3.originalText.slice(t3.locStart(u3), t3.locStart(u3.id));
                u3.id.type === "Identifier" && u3.id.name === "global" && !/namespace|module/.test(r5) || i3.push(a4 || /(^|\s)module(\s|$)/.test(r5) ? "module " : "namespace ");
              }
              return i3.push(e3.call(n3, "id")), l3 ? i3.push(e3.call(n3, "body")) : u3.body ? i3.push(" ", bd(e3.call(n3, "body"))) : i3.push(o3), md(i3);
            }
            case "PrivateName":
              return md(["#", e3.call(n3, "id")]);
            case "TSPrivateIdentifier":
              return u3.escapedText;
            case "TSConditionalType":
              return td(e3, t3, n3, {beforeParts: () => [e3.call(n3, "checkType"), " ", "extends", " ", e3.call(n3, "extendsType")], afterParts: () => [], shouldCheckJsx: false, conditionalNodeType: "TSConditionalType", consequentNodePropertyName: "trueType", alternateNodePropertyName: "falseType", testNodePropertyNames: ["checkType", "extendsType"]});
            case "TSInferType":
              return md(["infer", " ", e3.call(n3, "typeParameter")]);
            case "InterpreterDirective":
              return i3.push("#!", u3.value, yd), fd(t3.originalText, u3, t3.locEnd) && i3.push(yd), md(i3);
            case "NGRoot":
              return md([].concat(e3.call(n3, "node"), u3.node.comments && u3.node.comments.length !== 0 ? md([" //", u3.node.comments[0].value.trimEnd()]) : []));
            case "NGChainedExpression":
              return bd(gd(md([";", Dd]), e3.map((e4) => Yd(e4) ? n3(e4) : md(["(", n3(e4), ")"]), "expressions")));
            case "NGEmptyExpression":
              return "";
            case "NGQuotedExpression":
              return md([u3.prefix, ": ", u3.value.trim()]);
            case "NGMicrosyntax":
              return md(e3.map((e4, t4) => md([t4 === 0 ? "" : Df(e4.getValue(), t4, u3) ? " " : md([";", Dd]), n3(e4)]), "body"));
            case "NGMicrosyntaxKey":
              return /^[$_a-z][\w$]*(-[$_a-z][\w$])*$/i.test(u3.name) ? u3.name : JSON.stringify(u3.name);
            case "NGMicrosyntaxExpression":
              return md([e3.call(n3, "expression"), u3.alias === null ? "" : md([" as ", e3.call(n3, "alias")])]);
            case "NGMicrosyntaxKeyedExpression": {
              const t4 = e3.getName(), r4 = e3.getParentNode(), o4 = Df(u3, t4, r4) || (t4 === 1 && (u3.key.name === "then" || u3.key.name === "else") || t4 === 2 && u3.key.name === "else" && r4.body[t4 - 1].type === "NGMicrosyntaxKeyedExpression" && r4.body[t4 - 1].key.name === "then") && r4.body[0].type === "NGMicrosyntaxExpression";
              return md([e3.call(n3, "key"), o4 ? " " : ": ", e3.call(n3, "expression")]);
            }
            case "NGMicrosyntaxLet":
              return md(["let ", e3.call(n3, "key"), u3.value === null ? "" : md([" = ", e3.call(n3, "value")])]);
            case "NGMicrosyntaxAs":
              return md([e3.call(n3, "key"), " as ", e3.call(n3, "alias")]);
            case "PipelineBareFunction":
              return e3.call(n3, "callee");
            case "PipelineTopicExpression":
              return e3.call(n3, "expression");
            case "PipelinePrimaryTopicReference":
              return i3.push("#"), md(i3);
            case "ArgumentPlaceholder":
              return "?";
            case "TSJSDocAllType":
              return "*";
            case "TSJSDocUnknownType":
              return "?";
            case "TSJSDocNullableType":
              return md(["?", e3.call(n3, "typeAnnotation")]);
            case "TSJSDocNonNullableType":
              return md(["!", e3.call(n3, "typeAnnotation")]);
            case "TSJSDocFunctionType":
              return md(["function(", "): ", e3.call(n3, "typeAnnotation")]);
            default:
              throw new Error("unknown type: " + JSON.stringify(u3.type));
          }
        }(e2, t2, n2, r2);
        if (!u2 || Nd(a2))
          return a2;
        const i2 = Wd(e2), s2 = [];
        if (u2.type === "ClassMethod" || u2.type === "ClassPrivateMethod" || u2.type === "ClassProperty" || u2.type === "TSAbstractClassProperty" || u2.type === "ClassPrivateProperty" || u2.type === "MethodDefinition" || u2.type === "TSAbstractMethodDefinition" || u2.type === "TSDeclareMethod")
          ;
        else if (u2.decorators && u2.decorators.length > 0 && !(i2 && t2.locStart(i2, {ignoreDecorators: true}) > t2.locStart(u2.decorators[0]))) {
          const r3 = u2.type === "ClassExpression" || u2.type === "ClassDeclaration" || Xd(u2, t2) ? yd : Dd;
          e2.each((e3) => {
            let t3 = e3.getValue();
            t3 = t3.expression ? t3.expression : t3.callee, s2.push(n2(e3), r3);
          }, "decorators"), i2 && s2.unshift(yd);
        } else
          uf(u2) && u2.declaration && u2.declaration.decorators && u2.declaration.decorators.length > 0 && t2.locStart(u2, {ignoreDecorators: true}) > t2.locStart(u2.declaration.decorators[0]) ? e2.each((e3) => {
            const t3 = e3.getValue().type === "Decorator" ? "" : "@";
            s2.push(t3, n2(e3), yd);
          }, "declaration", "decorators") : o2 = kc(e2, t2);
        const l2 = [];
        if (o2 && l2.unshift("("), l2.push(a2), o2) {
          const t3 = e2.getValue();
          Jd(t3) && (l2.push(" /*"), l2.push(t3.trailingComments[0].value.trimStart()), l2.push("*/"), t3.trailingComments[0].printed = true), l2.push(")");
        }
        return s2.length > 0 ? bd(md(s2.concat(l2))) : md(l2);
      }, embed: El, insertPragma: Id, massageAstNode: Cl, hasPrettierIgnore: Kd, willPrintOwnComments: bh, canAttachComment: function(e2) {
        return e2.type && e2.type !== "CommentBlock" && e2.type !== "CommentLine" && e2.type !== "Line" && e2.type !== "Block" && e2.type !== "EmptyStatement" && e2.type !== "TemplateElement" && e2.type !== "Import";
      }, printComment: function(e2, t2) {
        const n2 = e2.getValue();
        switch (n2.type) {
          case "CommentBlock":
          case "Block": {
            if (function(e4) {
              const t3 = "*".concat(e4.value, "*").split("\n");
              return t3.length > 1 && t3.every((e5) => e5.trim()[0] === "*");
            }(n2)) {
              const e4 = function(e5) {
                const t3 = e5.value.split("\n");
                return md(["/*", gd(yd, t3.map((e6, n3) => n3 === 0 ? e6.trimEnd() : " " + (n3 < t3.length - 1 ? e6.trim() : e6.trimStart()))), "*/"]);
              }(n2);
              return n2.trailing && !rd(t2.originalText, t2.locStart(n2), {backwards: true}) ? md([yd, e4]) : e4;
            }
            const e3 = t2.locEnd(n2), r2 = t2.originalText.slice(e3 - 3, e3) === "*-/";
            return "/*" + n2.value + (r2 ? "*-/" : "*/");
          }
          case "CommentLine":
          case "Line":
            return t2.originalText.slice(t2.locStart(n2), t2.locEnd(n2)).trimEnd();
          default:
            throw new Error("Not a comment: " + JSON.stringify(n2));
        }
      }, isBlockComment: Gs.isBlockComment, handleComments: {ownLine: Gs.handleOwnLineComment, endOfLine: Gs.handleEndOfLineComment, remaining: Gs.handleRemainingComment}, getGapRegex: Gs.getGapRegex, getCommentChildNodes: Gs.getCommentChildNodes};
      const {concat: vh, hardline: Fh, indent: xh, join: Sh} = dn.builders;
      var wh = {preprocess: Ic, print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        switch (r2.type) {
          case "JsonRoot":
            return vh([e2.call(n2, "node"), Fh]);
          case "ArrayExpression":
            return r2.elements.length === 0 ? "[]" : vh(["[", xh(vh([Fh, Sh(vh([",", Fh]), e2.map(n2, "elements"))])), Fh, "]"]);
          case "ObjectExpression":
            return r2.properties.length === 0 ? "{}" : vh(["{", xh(vh([Fh, Sh(vh([",", Fh]), e2.map(n2, "properties"))])), Fh, "}"]);
          case "ObjectProperty":
            return vh([e2.call(n2, "key"), ": ", e2.call(n2, "value")]);
          case "UnaryExpression":
            return vh([r2.operator === "+" ? "" : r2.operator, e2.call(n2, "argument")]);
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return r2.value ? "true" : "false";
          case "StringLiteral":
          case "NumericLiteral":
            return JSON.stringify(r2.value);
          case "Identifier":
            return JSON.stringify(r2.name);
          default:
            throw new Error("unknown type: " + JSON.stringify(r2.type));
        }
      }, massageAstNode: function(e2, t2) {
        return delete t2.start, delete t2.end, delete t2.extra, delete t2.loc, delete t2.comments, delete t2.errors, delete t2.range, e2.type === "Identifier" ? {type: "StringLiteral", value: e2.name} : e2.type === "UnaryExpression" && e2.operator === "+" ? t2.argument : void 0;
      }};
      var Bh = {bracketSpacing: {since: "0.0.0", category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets."}, singleQuote: {since: "0.0.0", category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes."}, proseWrap: {since: "1.8.2", category: "Common", type: "choice", default: [{since: "1.8.2", value: true}, {since: "1.9.0", value: "preserve"}], description: "How to wrap prose.", choices: [{since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width."}, {since: "1.9.0", value: "never", description: "Do not wrap prose."}, {since: "1.9.0", value: "preserve", description: "Wrap prose as-is."}]}};
      var Th = {arrowParens: {since: "1.9.0", category: "JavaScript", type: "choice", default: [{since: "1.9.0", value: "avoid"}, {since: "2.0.0", value: "always"}], description: "Include parentheses around a sole arrow function parameter.", choices: [{value: "always", description: "Always include parens. Example: `(x) => x`"}, {value: "avoid", description: "Omit parens when possible. Example: `x => x`"}]}, bracketSpacing: Bh.bracketSpacing, jsxBracketSameLine: {since: "0.17.0", category: "JavaScript", type: "boolean", default: false, description: "Put > on the last line instead of at a new line."}, semi: {since: "1.0.0", category: "JavaScript", type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."}, singleQuote: Bh.singleQuote, jsxSingleQuote: {since: "1.15.0", category: "JavaScript", type: "boolean", default: false, description: "Use single quotes in JSX."}, quoteProps: {since: "1.17.0", category: "JavaScript", type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{value: "as-needed", description: "Only add quotes around object properties where required."}, {value: "consistent", description: "If at least one property in an object requires quotes, quote all properties."}, {value: "preserve", description: "Respect the input use of quotes in object properties."}]}, trailingComma: {since: "0.0.0", category: "JavaScript", type: "choice", default: [{since: "0.0.0", value: false}, {since: "0.19.0", value: "none"}, {since: "2.0.0", value: "es5"}], description: "Print trailing commas wherever possible when multi-line.", choices: [{value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"}, {value: "none", description: "No trailing commas."}, {value: "all", description: "Trailing commas wherever possible (including function arguments)."}]}}, kh = ["js", "node"], Nh = [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], Oh = ["Jakefile"], Ph = ["chakra", "d8", "gjs", "js", "node", "qjs", "rhino", "v8", "v8-shell"], _h = {name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: kh, extensions: Nh, filenames: Oh, interpreters: Ph, languageId: 183}, Ih = Object.freeze({__proto__: null, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: kh, extensions: Nh, filenames: Oh, interpreters: Ph, languageId: 183, default: _h}), jh = [".jsx"], Mh = {name: "JSX", type: "programming", group: "JavaScript", extensions: jh, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 178}, Lh = Object.freeze({__proto__: null, name: "JSX", type: "programming", group: "JavaScript", extensions: jh, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 178, default: Mh}), Rh = ["ts"], qh = ["deno", "ts-node"], Vh = [".ts"], Wh = {name: "TypeScript", type: "programming", color: "#2b7489", aliases: Rh, interpreters: qh, extensions: Vh, tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378}, $h = Object.freeze({__proto__: null, name: "TypeScript", type: "programming", color: "#2b7489", aliases: Rh, interpreters: qh, extensions: Vh, tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378, default: Wh}), Uh = [".tsx"], zh = {name: "TSX", type: "programming", group: "TypeScript", extensions: Uh, tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924}, Jh = Object.freeze({__proto__: null, name: "TSX", type: "programming", group: "TypeScript", extensions: Uh, tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924, default: zh}), Gh = [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], Hh = [".arcconfig", ".htmlhintrc", ".tern-config", ".tern-project", ".watchmanconfig", "composer.lock", "mcmod.info"], Xh = {name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", searchable: false, extensions: Gh, filenames: Hh, languageId: 174}, Yh = Object.freeze({__proto__: null, name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", searchable: false, extensions: Gh, filenames: Hh, languageId: 174, default: Xh}), Kh = ["jsonc"], Qh = [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], Zh = [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "jsconfig.json", "language-configuration.json", "tsconfig.json"], em = {name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: Kh, extensions: Qh, filenames: Zh, languageId: 423}, tm = Object.freeze({__proto__: null, name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: Kh, extensions: Qh, filenames: Zh, languageId: 423, default: em}), nm = [".json5"], rm = {name: "JSON5", type: "data", extensions: nm, tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175}, um = Object.freeze({__proto__: null, name: "JSON5", type: "data", extensions: nm, tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175, default: rm}), om = Ue(Ih), am = Ue(Lh), im = Ue($h), sm = Ue(Jh), lm = Ue(Yh), cm = Ue(tm), pm = Ue(um);
      var dm = {languages: [As(om, (e2) => ({since: "0.0.0", parsers: ["babel", "flow"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: e2.interpreters.concat(["nodejs"])})), As(om, () => ({name: "Flow", since: "0.0.0", parsers: ["babel", "flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"]})), As(am, () => ({since: "0.0.0", parsers: ["babel", "flow"], vscodeLanguageIds: ["javascriptreact"]})), As(im, () => ({since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"]})), As(sm, () => ({since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"]})), As(lm, () => ({name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"]})), As(lm, (e2) => ({since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], filenames: e2.filenames.concat([".prettierrc"])})), As(cm, (e2) => ({since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: e2.filenames.concat([".eslintrc"])})), As(pm, () => ({since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"]}))], options: Th, printers: {estree: Ah, "estree-json": wh}, parsers: {get babel() {
        return {}.parsers.babel;
      }, get "babel-flow"() {
        return {}.parsers["babel-flow"];
      }, get "babel-ts"() {
        return {}.parsers["babel-ts"];
      }, get json() {
        return {}.parsers.json;
      }, get json5() {
        return {}.parsers.json5;
      }, get "json-stringify"() {
        return {}.parsers["json-stringify"];
      }, get __js_expression() {
        return {}.parsers.__js_expression;
      }, get __vue_expression() {
        return {}.parsers.__vue_expression;
      }, get __vue_event_binding() {
        return {}.parsers.__vue_event_binding;
      }, get flow() {
        return {}.parsers.flow;
      }, get typescript() {
        return {}.parsers.typescript;
      }, get __ng_action() {
        return {}.parsers.__ng_action;
      }, get __ng_binding() {
        return {}.parsers.__ng_binding;
      }, get __ng_interpolation() {
        return {}.parsers.__ng_interpolation;
      }, get __ng_directive() {
        return {}.parsers.__ng_directive;
      }}};
      const {isFrontMatterNode: fm} = Lt;
      var hm = function(e2, t2, n2) {
        if (["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"].forEach((e3) => {
          delete t2[e3];
        }), fm(e2) && e2.lang === "yaml" && delete t2.value, e2.type === "css-comment" && n2.type === "css-root" && n2.nodes.length !== 0) {
          if ((n2.nodes[0] === e2 || fm(n2.nodes[0]) && n2.nodes[1] === e2) && (delete t2.text, /^\*\s*@(format|prettier)\s*$/.test(e2.text)))
            return null;
          if (n2.type === "css-root" && he(n2.nodes) === e2)
            return null;
        }
        if (e2.type === "value-root" && delete t2.text, e2.type !== "media-query" && e2.type !== "media-query-list" && e2.type !== "media-feature-expression" || delete t2.value, e2.type === "css-rule" && delete t2.params, e2.type === "selector-combinator" && (t2.value = t2.value.replace(/\s+/g, " ")), e2.type === "media-feature" && (t2.value = t2.value.replace(/ /g, "")), (e2.type === "value-word" && (e2.isColor && e2.isHex || ["initial", "inherit", "unset", "revert"].includes(t2.value.replace().toLowerCase())) || e2.type === "media-feature" || e2.type === "selector-root-invalid" || e2.type === "selector-pseudo") && (t2.value = t2.value.toLowerCase()), e2.type === "css-decl" && (t2.prop = t2.prop.toLowerCase()), e2.type !== "css-atrule" && e2.type !== "css-import" || (t2.name = t2.name.toLowerCase()), e2.type === "value-number" && (t2.unit = t2.unit.toLowerCase()), e2.type !== "media-feature" && e2.type !== "media-keyword" && e2.type !== "media-type" && e2.type !== "media-unknown" && e2.type !== "media-url" && e2.type !== "media-value" && e2.type !== "selector-attribute" && e2.type !== "selector-string" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "value-string" || !t2.value || (t2.value = t2.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e2.type === "selector-attribute" && (t2.attribute = t2.attribute.trim(), t2.namespace && typeof t2.namespace == "string" && (t2.namespace = t2.namespace.trim(), t2.namespace.length === 0 && (t2.namespace = true)), t2.value && (t2.value = t2.value.trim().replace(/^["']|["']$/g, ""), delete t2.quoted)), e2.type !== "media-value" && e2.type !== "media-type" && e2.type !== "value-number" && e2.type !== "selector-root-invalid" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "selector-tag" || !t2.value || (t2.value = t2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e3, t3, n3) => {
          const r2 = Number(t3);
          return isNaN(r2) ? e3 : r2 + n3.toLowerCase();
        })), e2.type === "selector-tag") {
          const n3 = e2.value.toLowerCase();
          ["from", "to"].includes(n3) && (t2.value = n3);
        }
        e2.type === "css-atrule" && e2.name.toLowerCase() === "supports" && delete t2.value, e2.type === "selector-unknown" && delete t2.value;
      };
      const {builders: {hardline: mm, concat: gm, markAsRoot: Dm}} = dn, ym = {"---": "yaml", "+++": "toml"};
      var Em = {parse: function(e2) {
        const t2 = Object.keys(ym).map(fe).join("|"), n2 = e2.match(new RegExp("^(".concat(t2, ")([^\\n]*)\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)")));
        if (n2 === null)
          return {frontMatter: null, content: e2};
        const [r2, u2, o2, a2] = n2;
        let i2 = ym[u2];
        return i2 !== "toml" && o2 && o2.trim() && (i2 = o2.trim()), {frontMatter: {type: "front-matter", lang: i2, value: a2, raw: r2.replace(/\n$/, "")}, content: r2.replace(/[^\n]/g, " ") + e2.slice(r2.length)};
      }, print: function(e2, t2) {
        if (e2.lang === "yaml") {
          const n2 = e2.value.trim(), r2 = n2 ? t2(n2, {parser: "yaml"}, {stripTrailingHardline: true}) : "";
          return Dm(gm(["---", mm, r2, r2 ? mm : "", "---"]));
        }
      }};
      const {builders: {hardline: Cm, concat: bm}} = dn, {print: Am} = Em;
      var vm = function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (r2.type === "front-matter") {
          const e3 = Am(r2, n2);
          return e3 ? bm([e3, Cm]) : "";
        }
      };
      const {parse: Fm} = Em;
      var xm = {hasPragma: function(e2) {
        return Nl.hasPragma(Fm(e2).content);
      }, insertPragma: function(e2) {
        const {frontMatter: t2, content: n2} = Fm(e2);
        return (t2 ? t2.raw + "\n\n" : "") + Nl.insertPragma(n2);
      }};
      const Sm = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
      function wm(e2, t2) {
        const n2 = [].concat(t2);
        let r2, u2 = -1;
        for (; r2 = e2.getParentNode(++u2); )
          if (n2.includes(r2.type))
            return u2;
        return -1;
      }
      function Bm(e2, t2) {
        const n2 = wm(e2, t2);
        return n2 === -1 ? null : e2.getParentNode(n2);
      }
      function Tm(e2) {
        return e2.type === "value-operator" && e2.value === "*";
      }
      function km(e2) {
        return e2.type === "value-operator" && e2.value === "/";
      }
      function Nm(e2) {
        return e2.type === "value-operator" && e2.value === "+";
      }
      function Om(e2) {
        return e2.type === "value-operator" && e2.value === "-";
      }
      function Pm(e2) {
        return e2.type === "value-operator" && e2.value === "%";
      }
      function _m(e2) {
        return e2.type === "value-comma_group" && e2.groups && e2.groups[1] && e2.groups[1].type === "value-colon";
      }
      function Im(e2) {
        return e2.type === "value-paren_group" && e2.groups && e2.groups[0] && _m(e2.groups[0]);
      }
      var jm = {getAncestorCounter: wm, getAncestorNode: Bm, getPropOfDeclNode: function(e2) {
        const t2 = Bm(e2, "css-decl");
        return t2 && t2.prop && t2.prop.toLowerCase();
      }, hasSCSSInterpolation: function(e2) {
        if (e2 && e2.length) {
          for (let t2 = e2.length - 1; t2 > 0; t2--)
            if (e2[t2].type === "word" && e2[t2].value === "{" && e2[t2 - 1].type === "word" && e2[t2 - 1].value.endsWith("#"))
              return true;
        }
        return false;
      }, hasStringOrFunction: function(e2) {
        if (e2 && e2.length) {
          for (let t2 = 0; t2 < e2.length; t2++)
            if (e2[t2].type === "string" || e2[t2].type === "func")
              return true;
        }
        return false;
      }, maybeToLowerCase: function(e2) {
        return e2.includes("$") || e2.includes("@") || e2.includes("#") || e2.startsWith("%") || e2.startsWith("--") || e2.startsWith(":--") || e2.includes("(") && e2.includes(")") ? e2 : e2.toLowerCase();
      }, insideValueFunctionNode: function(e2, t2) {
        const n2 = Bm(e2, "value-func");
        return n2 && n2.value && n2.value.toLowerCase() === t2;
      }, insideICSSRuleNode: function(e2) {
        const t2 = Bm(e2, "css-rule");
        return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
      }, insideAtRuleNode: function(e2, t2) {
        const n2 = [].concat(t2), r2 = Bm(e2, "css-atrule");
        return r2 && n2.includes(r2.name.toLowerCase());
      }, insideURLFunctionInImportAtRuleNode: function(e2) {
        const t2 = e2.getValue(), n2 = Bm(e2, "css-atrule");
        return n2 && n2.name === "import" && t2.groups[0].value === "url" && t2.groups.length === 2;
      }, isKeyframeAtRuleKeywords: function(e2, t2) {
        const n2 = Bm(e2, "css-atrule");
        return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t2.toLowerCase());
      }, isWideKeywords: function(e2) {
        return ["initial", "inherit", "unset", "revert"].includes(e2.toLowerCase());
      }, isSCSS: function(e2, t2) {
        return e2 === "less" || e2 === "scss" ? e2 === "scss" : /(\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
      }, isSCSSVariable: function(e2) {
        return !(!e2 || e2.type !== "word" || !e2.value.startsWith("$"));
      }, isLastNode: function(e2, t2) {
        const n2 = e2.getParentNode();
        if (!n2)
          return false;
        const {nodes: r2} = n2;
        return r2 && r2.indexOf(t2) === r2.length - 1;
      }, isLessParser: function(e2) {
        return e2.parser === "css" || e2.parser === "less";
      }, isSCSSControlDirectiveNode: function(e2) {
        return e2.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e2.name);
      }, isDetachedRulesetDeclarationNode: function(e2) {
        return !!e2.selector && (typeof e2.selector == "string" && /^@.+:.*$/.test(e2.selector) || e2.selector.value && /^@.+:.*$/.test(e2.selector.value));
      }, isRelationalOperatorNode: function(e2) {
        return e2.type === "value-word" && ["<", ">", "<=", ">="].includes(e2.value);
      }, isEqualityOperatorNode: function(e2) {
        return e2.type === "value-word" && ["==", "!="].includes(e2.value);
      }, isMultiplicationNode: Tm, isDivisionNode: km, isAdditionNode: Nm, isSubtractionNode: Om, isModuloNode: Pm, isMathOperatorNode: function(e2) {
        return Tm(e2) || km(e2) || Nm(e2) || Om(e2) || Pm(e2);
      }, isEachKeywordNode: function(e2) {
        return e2.type === "value-word" && e2.value === "in";
      }, isForKeywordNode: function(e2) {
        return e2.type === "value-word" && ["from", "through", "end"].includes(e2.value);
      }, isURLFunctionNode: function(e2) {
        return e2.type === "value-func" && e2.value.toLowerCase() === "url";
      }, isIfElseKeywordNode: function(e2) {
        return e2.type === "value-word" && ["and", "or", "not"].includes(e2.value);
      }, hasComposesNode: function(e2) {
        return e2.value && e2.value.type === "value-root" && e2.value.group && e2.value.group.type === "value-value" && e2.prop.toLowerCase() === "composes";
      }, hasParensAroundNode: function(e2) {
        return e2.value && e2.value.group && e2.value.group.group && e2.value.group.group.type === "value-paren_group" && e2.value.group.group.open !== null && e2.value.group.group.close !== null;
      }, hasEmptyRawBefore: function(e2) {
        return e2.raws && e2.raws.before === "";
      }, isSCSSNestedPropertyNode: function(e2) {
        return !!e2.selector && e2.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
      }, isDetachedRulesetCallNode: function(e2) {
        return e2.raws && e2.raws.params && /^\(\s*\)$/.test(e2.raws.params);
      }, isTemplatePlaceholderNode: function(e2) {
        return e2.name.startsWith("prettier-placeholder");
      }, isTemplatePropNode: function(e2) {
        return e2.prop.startsWith("@prettier-placeholder");
      }, isPostcssSimpleVarNode: function(e2, t2) {
        return e2.value === "$$" && e2.type === "value-func" && t2 && t2.type === "value-word" && !t2.raws.before;
      }, isKeyValuePairNode: _m, isKeyValuePairInParenGroupNode: Im, isSCSSMapItemNode: function(e2) {
        const t2 = e2.getValue();
        if (t2.groups.length === 0)
          return false;
        const n2 = e2.getParentNode(1);
        if (!(Im(t2) || n2 && Im(n2)))
          return false;
        const r2 = Bm(e2, "css-decl");
        return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!Im(n2) || n2.type === "value-func");
      }, isInlineValueCommentNode: function(e2) {
        return e2.type === "value-comment" && e2.inline;
      }, isHashNode: function(e2) {
        return e2.type === "value-word" && e2.value === "#";
      }, isLeftCurlyBraceNode: function(e2) {
        return e2.type === "value-word" && e2.value === "{";
      }, isRightCurlyBraceNode: function(e2) {
        return e2.type === "value-word" && e2.value === "}";
      }, isWordNode: function(e2) {
        return ["value-word", "value-atword"].includes(e2.type);
      }, isColonNode: function(e2) {
        return e2.type === "value-colon";
      }, isMediaAndSupportsKeywords: function(e2) {
        return e2.value && ["not", "and", "or"].includes(e2.value.toLowerCase());
      }, isColorAdjusterFuncNode: function(e2) {
        return e2.type === "value-func" && Sm.has(e2.value.toLowerCase());
      }, lastLineHasInlineComment: function(e2) {
        return /\/\//.test(e2.split(/[\n\r]/).pop());
      }, stringifyNode: function e2(t2) {
        if (t2.groups) {
          return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n3, r3, u2) => n3 + e2(r3) + (t2.groups[0].type === "comma_group" && u2 !== t2.groups.length - 1 ? "," : ""), "") + (t2.close && t2.close.value ? t2.close.value : "");
        }
        const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
        return n2 + r2 + (t2.type === "atword" ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e2(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
      }};
      const {printNumber: Mm, printString: Lm, hasIgnoreComment: Rm, hasNewline: qm, isFrontMatterNode: Vm, isNextLineEmpty: Wm} = Lt, {builders: {concat: $m, join: Um, line: zm, hardline: Jm, softline: Gm, group: Hm, fill: Xm, indent: Ym, dedent: Km, ifBreak: Qm, breakParent: Zm}, utils: {removeLines: eg}} = dn, {insertPragma: tg} = xm, {getAncestorNode: ng, getPropOfDeclNode: rg, maybeToLowerCase: ug, insideValueFunctionNode: og, insideICSSRuleNode: ag, insideAtRuleNode: ig, insideURLFunctionInImportAtRuleNode: sg, isKeyframeAtRuleKeywords: lg, isWideKeywords: cg, isSCSS: pg, isLastNode: dg, isLessParser: fg, isSCSSControlDirectiveNode: hg, isDetachedRulesetDeclarationNode: mg, isRelationalOperatorNode: gg, isEqualityOperatorNode: Dg, isMultiplicationNode: yg, isDivisionNode: Eg, isAdditionNode: Cg, isSubtractionNode: bg, isMathOperatorNode: Ag, isEachKeywordNode: vg, isForKeywordNode: Fg, isURLFunctionNode: xg, isIfElseKeywordNode: Sg, hasComposesNode: wg, hasParensAroundNode: Bg, hasEmptyRawBefore: Tg, isKeyValuePairNode: kg, isDetachedRulesetCallNode: Ng, isTemplatePlaceholderNode: Og, isTemplatePropNode: Pg, isPostcssSimpleVarNode: _g, isSCSSMapItemNode: Ig, isInlineValueCommentNode: jg, isHashNode: Mg, isLeftCurlyBraceNode: Lg, isRightCurlyBraceNode: Rg, isWordNode: qg, isColonNode: Vg, isMediaAndSupportsKeywords: Wg, isColorAdjusterFuncNode: $g, lastLineHasInlineComment: Ug} = jm;
      function zg(e2) {
        return e2.trailingComma === "es5" || e2.trailingComma === "all";
      }
      function Jg(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = [];
        let o2 = 0;
        return e2.map((e3) => {
          const a2 = r2.nodes[o2 - 1];
          if (a2 && a2.type === "css-comment" && a2.text.trim() === "prettier-ignore") {
            const n3 = e3.getValue();
            u2.push(t2.originalText.slice(t2.locStart(n3), t2.locEnd(n3)));
          } else
            u2.push(e3.call(n2));
          o2 !== r2.nodes.length - 1 && (r2.nodes[o2 + 1].type === "css-comment" && !qm(t2.originalText, t2.locStart(r2.nodes[o2 + 1]), {backwards: true}) && !Vm(r2.nodes[o2]) || r2.nodes[o2 + 1].type === "css-atrule" && r2.nodes[o2 + 1].name === "else" && r2.nodes[o2].type !== "css-comment" ? u2.push(" ") : (u2.push(t2.__isHTMLStyleAttribute ? zm : Jm), Wm(t2.originalText, e3.getValue(), t2.locEnd) && !Vm(r2.nodes[o2]) && u2.push(Jm))), o2++;
        }, "nodes"), $m(u2);
      }
      const Gg = /(["'])(?:(?!\1)[^\\]|\\[\S\s])*\1/g, Hg = new RegExp(Gg.source + "|" + "(".concat(/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source, ")?") + "(".concat(/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source, ")") + "(".concat(/[A-Za-z]+/g.source, ")?"), "g");
      function Xg(e2, t2) {
        return e2.replace(Gg, (e3) => Lm(e3, t2));
      }
      function Yg(e2, t2) {
        const n2 = t2.singleQuote ? "'" : '"';
        return e2.includes('"') || e2.includes("'") ? e2 : n2 + e2 + n2;
      }
      function Kg(e2) {
        return e2.replace(Hg, (e3, t2, n2, r2, u2) => !n2 && r2 ? Qg(r2) + ug(u2 || "") : e3);
      }
      function Qg(e2) {
        return Mm(e2).replace(/\.0(?=$|e)/, "");
      }
      var Zg = {print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2)
          return "";
        if (typeof r2 == "string")
          return r2;
        switch (r2.type) {
          case "front-matter":
            return $m([r2.raw, Jm]);
          case "css-root": {
            const u2 = Jg(e2, t2, n2), o2 = r2.raws.after.trim();
            return $m([u2, o2 ? " ".concat(o2) : "", u2.parts.length && !t2.__isHTMLStyleAttribute ? Jm : ""]);
          }
          case "css-comment": {
            const e3 = r2.inline || r2.raws.inline, n3 = t2.originalText.slice(t2.locStart(r2), t2.locEnd(r2));
            return e3 ? n3.trimEnd() : n3;
          }
          case "css-rule":
            return $m([e2.call(n2, "selector"), r2.important ? " !important" : "", r2.nodes ? $m([r2.selector && r2.selector.type === "selector-unknown" && Ug(r2.selector.value) ? zm : " ", "{", r2.nodes.length > 0 ? Ym($m([Jm, Jg(e2, t2, n2)])) : "", Jm, "}", mg(r2) ? ";" : ""]) : ";"]);
          case "css-decl": {
            const u2 = e2.getParentNode(), {between: o2} = r2.raws, a2 = o2.trim(), i2 = a2 === ":";
            let s2 = wg(r2) ? eg(e2.call(n2, "value")) : e2.call(n2, "value");
            return !i2 && Ug(a2) && (s2 = Ym($m([Jm, Km(s2)]))), $m([r2.raws.before.replace(/[\s;]/g, ""), ag(e2) ? r2.prop : ug(r2.prop), a2.startsWith("//") ? " " : "", a2, r2.extend ? "" : " ", fg(t2) && r2.extend && r2.selector ? $m(["extend(", e2.call(n2, "selector"), ")"]) : "", s2, r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "", r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "", r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "", r2.nodes ? $m([" {", Ym($m([Gm, Jg(e2, t2, n2)])), Gm, "}"]) : Pg(r2) && !u2.raws.semicolon && t2.originalText[t2.locEnd(r2) - 1] !== ";" ? "" : t2.__isHTMLStyleAttribute && dg(e2, r2) ? Qm(";", "") : ";"]);
          }
          case "css-atrule": {
            const u2 = e2.getParentNode(), o2 = Og(r2) && !u2.raws.semicolon && t2.originalText[t2.locEnd(r2) - 1] !== ";";
            if (fg(t2)) {
              if (r2.mixin)
                return $m([e2.call(n2, "selector"), r2.important ? " !important" : "", o2 ? "" : ";"]);
              if (r2.function)
                return $m([r2.name, $m([e2.call(n2, "params")]), o2 ? "" : ";"]);
              if (r2.variable)
                return $m(["@", r2.name, ": ", r2.value ? $m([e2.call(n2, "value")]) : "", r2.raws.between.trim() ? r2.raws.between.trim() + " " : "", r2.nodes ? $m(["{", Ym($m([r2.nodes.length > 0 ? Gm : "", Jg(e2, t2, n2)])), Gm, "}"]) : "", o2 ? "" : ";"]);
            }
            return $m(["@", Ng(r2) || r2.name.endsWith(":") ? r2.name : ug(r2.name), r2.params ? $m([Ng(r2) ? "" : Og(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? $m([Jm, Jm]) : /^\s*\n/.test(r2.raws.afterName) ? Jm : " " : " ", e2.call(n2, "params")]) : "", r2.selector ? Ym($m([" ", e2.call(n2, "selector")])) : "", r2.value ? Hm($m([" ", e2.call(n2, "value"), hg(r2) ? Bg(r2) ? " " : zm : ""])) : r2.name === "else" ? " " : "", r2.nodes ? $m([hg(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && Ug(r2.selector.value) || !r2.selector && typeof r2.params == "string" && Ug(r2.params) ? zm : " ", "{", Ym($m([r2.nodes.length > 0 ? Gm : "", Jg(e2, t2, n2)])), Gm, "}"]) : o2 ? "" : ";"]);
          }
          case "media-query-list": {
            const t3 = [];
            return e2.each((e3) => {
              const r3 = e3.getValue();
              r3.type === "media-query" && r3.value === "" || t3.push(e3.call(n2));
            }, "nodes"), Hm(Ym(Um(zm, t3)));
          }
          case "media-query":
            return $m([Um(" ", e2.map(n2, "nodes")), dg(e2, r2) ? "" : ","]);
          case "media-type":
            return Kg(Xg(r2.value, t2));
          case "media-feature-expression":
            return r2.nodes ? $m(["(", $m(e2.map(n2, "nodes")), ")"]) : r2.value;
          case "media-feature":
            return ug(Xg(r2.value.replace(/ +/g, " "), t2));
          case "media-colon":
            return $m([r2.value, " "]);
          case "media-value":
            return Kg(Xg(r2.value, t2));
          case "media-keyword":
            return Xg(r2.value, t2);
          case "media-url":
            return Xg(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), t2);
          case "media-unknown":
            return r2.value;
          case "selector-root":
            return Hm($m([ig(e2, "custom-selector") ? $m([ng(e2, "css-atrule").customSelector, zm]) : "", Um($m([",", ig(e2, ["extend", "custom-selector", "nest"]) ? zm : Jm]), e2.map(n2, "nodes"))]));
          case "selector-selector":
            return Hm(Ym($m(e2.map(n2, "nodes"))));
          case "selector-comment":
            return r2.value;
          case "selector-string":
            return Xg(r2.value, t2);
          case "selector-tag": {
            const t3 = e2.getParentNode(), n3 = t3 && t3.nodes.indexOf(r2), u2 = n3 && t3.nodes[n3 - 1];
            return $m([r2.namespace ? $m([r2.namespace === true ? "" : r2.namespace.trim(), "|"]) : "", u2.type === "selector-nesting" ? r2.value : Kg(lg(e2, r2.value) ? r2.value.toLowerCase() : r2.value)]);
          }
          case "selector-id":
            return $m(["#", r2.value]);
          case "selector-class":
            return $m([".", Kg(Xg(r2.value, t2))]);
          case "selector-attribute":
            return $m(["[", r2.namespace ? $m([r2.namespace === true ? "" : r2.namespace.trim(), "|"]) : "", r2.attribute.trim(), r2.operator ? r2.operator : "", r2.value ? Yg(Xg(r2.value.trim(), t2), t2) : "", r2.insensitive ? " i" : "", "]"]);
          case "selector-combinator": {
            if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
              const t3 = e2.getParentNode(), n4 = t3.type === "selector-selector" && t3.nodes[0] === r2 ? "" : zm;
              return $m([n4, r2.value, dg(e2, r2) ? "" : " "]);
            }
            const n3 = r2.value.trim().startsWith("(") ? zm : "", u2 = Kg(Xg(r2.value.trim(), t2)) || zm;
            return $m([n3, u2]);
          }
          case "selector-universal":
            return $m([r2.namespace ? $m([r2.namespace === true ? "" : r2.namespace.trim(), "|"]) : "", r2.value]);
          case "selector-pseudo":
            return $m([ug(r2.value), r2.nodes && r2.nodes.length > 0 ? $m(["(", Um(", ", e2.map(n2, "nodes")), ")"]) : ""]);
          case "selector-nesting":
            return r2.value;
          case "selector-unknown": {
            const n3 = ng(e2, "css-rule");
            if (n3 && n3.isSCSSNesterProperty)
              return Kg(Xg(ug(r2.value), t2));
            const u2 = e2.getParentNode();
            if (u2.raws && u2.raws.selector) {
              const e3 = t2.locStart(u2), n4 = e3 + u2.raws.selector.length;
              return t2.originalText.slice(e3, n4).trim();
            }
            const o2 = e2.getParentNode(1);
            if (u2.type === "value-paren_group" && o2 && o2.type === "value-func" && o2.value === "selector") {
              const e3 = t2.locStart(u2.open) + 1, n4 = t2.locEnd(u2.close) - 1, r3 = t2.originalText.slice(e3, n4).trim();
              return Ug(r3) ? $m([Zm, r3]) : r3;
            }
            return r2.value;
          }
          case "value-value":
          case "value-root":
            return e2.call(n2, "group");
          case "value-comment":
            return t2.originalText.slice(t2.locStart(r2), t2.locEnd(r2));
          case "value-comma_group": {
            const t3 = e2.getParentNode(), u2 = e2.getParentNode(1), o2 = rg(e2), a2 = o2 && t3.type === "value-value" && (o2 === "grid" || o2.startsWith("grid-template")), i2 = ng(e2, "css-atrule"), s2 = i2 && hg(i2), l2 = e2.map(n2, "groups"), c2 = [], p2 = og(e2, "url");
            let d2 = false, f2 = false;
            for (let n3 = 0; n3 < r2.groups.length; ++n3) {
              c2.push(l2[n3]);
              const o3 = r2.groups[n3 - 1], h2 = r2.groups[n3], m2 = r2.groups[n3 + 1], g2 = r2.groups[n3 + 2];
              if (p2) {
                (m2 && Cg(m2) || Cg(h2)) && c2.push(" ");
                continue;
              }
              if (!m2)
                continue;
              if (h2.type === "value-word" && h2.value.endsWith("-") && m2.type === "value-atword" && m2.value.startsWith("prettier-placeholder-"))
                continue;
              const D2 = h2.type === "value-string" && h2.value.startsWith("#{"), y2 = d2 && m2.type === "value-string" && m2.value.endsWith("}");
              if (D2 || y2) {
                d2 = !d2;
                continue;
              }
              if (d2)
                continue;
              if (Vg(h2) || Vg(m2))
                continue;
              if (h2.type === "value-atword" && h2.value === "")
                continue;
              if (h2.value === "~")
                continue;
              if (h2.value && h2.value.includes("\\") && m2 && m2.type !== "value-comment")
                continue;
              if (o3 && o3.value && o3.value.indexOf("\\") === o3.value.length - 1 && h2.type === "value-operator" && h2.value === "/")
                continue;
              if (h2.value === "\\")
                continue;
              if (_g(h2, m2))
                continue;
              if (Mg(h2) || Lg(h2) || Rg(m2) || Lg(m2) && Tg(m2) || Rg(h2) && Tg(m2))
                continue;
              if (h2.value === "--" && Mg(m2))
                continue;
              const E2 = Ag(h2), C2 = Ag(m2);
              if ((E2 && Mg(m2) || C2 && Rg(h2)) && Tg(m2))
                continue;
              if (og(e2, "calc") && (Cg(h2) || Cg(m2) || bg(h2) || bg(m2)) && Tg(m2))
                continue;
              const b2 = (Cg(h2) || bg(h2)) && n3 === 0 && (m2.type === "value-number" || m2.isHex) && u2 && $g(u2) && !Tg(m2), A2 = g2 && g2.type === "value-func" || g2 && qg(g2) || h2.type === "value-func" || qg(h2), v2 = m2.type === "value-func" || qg(m2) || o3 && o3.type === "value-func" || o3 && qg(o3);
              if (yg(m2) || yg(h2) || og(e2, "calc") || b2 || !(Eg(m2) && !A2 || Eg(h2) && !v2 || Cg(m2) && !A2 || Cg(h2) && !v2 || bg(m2) || bg(h2)) || !(Tg(m2) || E2 && (!o3 || o3 && Ag(o3))))
                if (jg(h2)) {
                  if (t3.type === "value-paren_group") {
                    c2.push(Km(Jm));
                    continue;
                  }
                  c2.push(Jm);
                } else
                  s2 && (Dg(m2) || gg(m2) || Sg(m2) || vg(h2) || Fg(h2)) || i2 && i2.name.toLowerCase() === "namespace" ? c2.push(" ") : a2 ? h2.source && m2.source && h2.source.start.line !== m2.source.start.line ? (c2.push(Jm), f2 = true) : c2.push(" ") : C2 ? c2.push(" ") : m2 && m2.value === "..." || c2.push(zm);
            }
            return f2 && c2.unshift(Jm), s2 ? Hm(Ym($m(c2))) : sg(e2) ? Hm(Xm(c2)) : Hm(Ym(Xm(c2)));
          }
          case "value-paren_group": {
            const u2 = e2.getParentNode();
            if (u2 && xg(u2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
              return $m([r2.open ? e2.call(n2, "open") : "", Um(",", e2.map(n2, "groups")), r2.close ? e2.call(n2, "close") : ""]);
            if (!r2.open) {
              const t3 = e2.map(n2, "groups"), r3 = [];
              for (let e3 = 0; e3 < t3.length; e3++)
                e3 !== 0 && r3.push($m([",", zm])), r3.push(t3[e3]);
              return Hm(Ym(Xm(r3)));
            }
            const o2 = Ig(e2), a2 = r2.groups[r2.groups.length - 1], i2 = a2 && a2.type === "value-comment";
            return Hm($m([r2.open ? e2.call(n2, "open") : "", Ym($m([Gm, Um($m([",", zm]), e2.map((e3) => {
              const t3 = e3.getValue(), r3 = n2(e3);
              return kg(t3) && t3.type === "value-comma_group" && t3.groups && t3.groups[2] && t3.groups[2].type === "value-paren_group" ? (r3.contents.contents.parts[1] = Hm(r3.contents.contents.parts[1]), Hm(Km(r3))) : r3;
            }, "groups"))])), Qm(!i2 && pg(t2.parser, t2.originalText) && o2 && zg(t2) ? "," : ""), Gm, r2.close ? e2.call(n2, "close") : ""]), {shouldBreak: o2});
          }
          case "value-func":
            return $m([r2.value, ig(e2, "supports") && Wg(r2) ? " " : "", e2.call(n2, "group")]);
          case "value-paren":
            return r2.value;
          case "value-number":
            return $m([Qg(r2.value), ug(r2.unit)]);
          case "value-operator":
            return r2.value;
          case "value-word":
            return r2.isColor && r2.isHex || cg(r2.value) ? r2.value.toLowerCase() : r2.value;
          case "value-colon": {
            const t3 = e2.getParentNode(), n3 = t3 && t3.groups.indexOf(r2), u2 = n3 && t3.groups[n3 - 1];
            return $m([r2.value, u2 && u2.value[u2.value.length - 1] === "\\" || og(e2, "url") ? "" : zm]);
          }
          case "value-comma":
            return $m([r2.value, " "]);
          case "value-string":
            return Lm(r2.raws.quote + r2.value + r2.raws.quote, t2);
          case "value-atword":
            return $m(["@", r2.value]);
          case "value-unicode-range":
          case "value-unknown":
            return r2.value;
          default:
            throw new Error("Unknown postcss type ".concat(JSON.stringify(r2.type)));
        }
      }, embed: vm, insertPragma: tg, hasPrettierIgnore: Rm, massageAstNode: hm}, eD = {singleQuote: Bh.singleQuote}, tD = [".css"], nD = {name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: tD, languageId: 50}, rD = Object.freeze({__proto__: null, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: tD, languageId: 50, default: nD}), uD = [".pcss", ".postcss"], oD = {name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: uD, aceMode: "text", languageId: 262764437}, aD = Object.freeze({__proto__: null, name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: uD, aceMode: "text", languageId: 262764437, default: oD}), iD = [".less"], sD = {name: "Less", type: "markup", group: "CSS", extensions: iD, tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198}, lD = Object.freeze({__proto__: null, name: "Less", type: "markup", group: "CSS", extensions: iD, tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198, default: sD}), cD = [".scss"], pD = {name: "SCSS", type: "markup", tmScope: "source.css.scss", group: "CSS", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: cD, languageId: 329}, dD = Object.freeze({__proto__: null, name: "SCSS", type: "markup", tmScope: "source.css.scss", group: "CSS", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: cD, languageId: 329, default: pD}), fD = Ue(rD), hD = Ue(aD), mD = Ue(lD), gD = Ue(dD);
      var DD = {languages: [As(fD, () => ({since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"]})), As(hD, () => ({since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"]})), As(mD, () => ({since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"]})), As(gD, () => ({since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"]}))], options: eD, printers: {postcss: Zg}, parsers: {get css() {
        return {}.parsers.css;
      }, get less() {
        return {}.parsers.less;
      }, get scss() {
        return {}.parsers.scss;
      }}}, yD = Ue(Object.freeze({__proto__: null, default: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]}));
      const ED = new Set(yD);
      function CD(e2) {
        return bD(e2, ["TextNode"]) && !/\S/.test(e2.chars);
      }
      function bD(e2, t2) {
        return e2 && t2.some((t3) => e2.type === t3);
      }
      function AD(e2, t2) {
        const n2 = e2.getValue(), r2 = e2.getParentNode(0) || {}, u2 = r2.children || r2.body || r2.parts || [], o2 = u2.indexOf(n2);
        return o2 !== -1 && u2[o2 + t2];
      }
      function vD(e2, t2 = 1) {
        return AD(e2, -t2);
      }
      function FD(e2) {
        return AD(e2, 1);
      }
      function xD(e2) {
        return bD(e2, ["MustacheCommentStatement"]) && typeof e2.value == "string" && e2.value.trim() === "prettier-ignore";
      }
      var SD = {getNextNode: FD, getPreviousNode: vD, hasPrettierIgnore: function(e2) {
        const t2 = e2.getValue(), n2 = vD(e2, 2);
        return xD(t2) || xD(n2);
      }, isNextNodeOfSomeType: function(e2, t2) {
        return bD(FD(e2), t2);
      }, isNodeOfSomeType: bD, isParentOfSomeType: function(e2, t2) {
        return bD(e2.getParentNode(0), t2);
      }, isPreviousNodeOfSomeType: function(e2, t2) {
        return bD(vD(e2), t2);
      }, isVoid: function(e2) {
        return function(e3) {
          return bD(e3, ["ElementNode"]) && typeof e3.tag == "string" && (function(e4) {
            return e4.toUpperCase() === e4;
          }(e3.tag[0]) || e3.tag.includes("."));
        }(e2) && (e2.children === 0 || e2.children.every((e3) => CD(e3))) || ED.has(e2.tag);
      }, isWhitespaceNode: CD};
      const {concat: wD, group: BD, hardline: TD, ifBreak: kD, indent: ND, join: OD, line: PD, softline: _D} = dn.builders, {getNextNode: ID, getPreviousNode: jD, hasPrettierIgnore: MD, isNextNodeOfSomeType: LD, isNodeOfSomeType: RD, isParentOfSomeType: qD, isPreviousNodeOfSomeType: VD, isVoid: WD, isWhitespaceNode: $D} = SD;
      function UD(e2, t2) {
        const n2 = e2.getValue();
        return wD(["<", n2.tag, zD(e2, t2), Dy(n2), GD(n2)]);
      }
      function zD(e2, t2) {
        const n2 = e2.getValue();
        return ND(wD([n2.attributes.length ? PD : "", OD(PD, e2.map(t2, "attributes")), n2.modifiers.length ? PD : "", OD(PD, e2.map(t2, "modifiers")), n2.comments.length ? PD : "", OD(PD, e2.map(t2, "comments"))]));
      }
      function JD(e2, t2, n2) {
        return wD(e2.map((e3, r2) => r2 === 0 ? wD([_D, n2(e3, t2, n2)]) : n2(e3, t2, n2), "children"));
      }
      function GD(e2) {
        return WD(e2) ? kD(wD([_D, "/>"]), wD([" />", _D])) : kD(wD([_D, ">"]), ">");
      }
      function HD(e2) {
        const t2 = e2.escaped === false ? "{{{" : "{{", n2 = e2.strip && e2.strip.open ? "~" : "";
        return wD([t2, n2]);
      }
      function XD(e2) {
        const t2 = e2.escaped === false ? "}}}" : "}}", n2 = e2.strip && e2.strip.close ? "~" : "";
        return wD([n2, t2]);
      }
      function YD(e2) {
        const t2 = HD(e2), n2 = e2.openStrip.open ? "~" : "";
        return wD([t2, n2, "#"]);
      }
      function KD(e2) {
        const t2 = XD(e2), n2 = e2.openStrip.close ? "~" : "";
        return wD([n2, t2]);
      }
      function QD(e2) {
        const t2 = HD(e2), n2 = e2.closeStrip.open ? "~" : "";
        return wD([t2, n2, "/"]);
      }
      function ZD(e2) {
        const t2 = XD(e2), n2 = e2.closeStrip.close ? "~" : "";
        return wD([n2, t2]);
      }
      function ey(e2) {
        const t2 = HD(e2), n2 = e2.inverseStrip.open ? "~" : "";
        return wD([t2, n2]);
      }
      function ty(e2) {
        const t2 = XD(e2), n2 = e2.inverseStrip.close ? "~" : "";
        return wD([n2, t2]);
      }
      function ny(e2, t2) {
        const n2 = e2.getValue();
        return BD(wD([YD(n2), hy(e2, t2), Dy(n2.program), _D, KD(n2)]));
      }
      function ry(e2) {
        return wD([TD, ey(e2), "else", ty(e2)]);
      }
      function uy(e2, t2) {
        const n2 = e2.getParentNode(1);
        return wD([ey(n2), "else ", hy(e2, t2), ty(n2)]);
      }
      function oy(e2, t2) {
        const n2 = e2.getValue();
        return wD([ay(n2) ? _D : TD, QD(n2), e2.call(t2, "path"), ZD(n2)]);
      }
      function ay(e2) {
        return RD(e2, ["BlockStatement"]) && e2.program.body.every((e3) => $D(e3));
      }
      function iy(e2) {
        return RD(e2, ["BlockStatement"]) && e2.inverse;
      }
      function sy(e2, t2) {
        if (ay(e2.getValue()))
          return "";
        const n2 = e2.call(t2, "program");
        return ND(wD([TD, n2]));
      }
      function ly(e2, t2) {
        const n2 = e2.getValue(), r2 = e2.call(t2, "inverse"), u2 = wD([TD, r2]);
        return function(e3) {
          return iy(e3) && e3.inverse.body.length === 1 && RD(e3.inverse.body[0], ["BlockStatement"]) && e3.inverse.body[0].path.parts[0] === "if";
        }(n2) ? u2 : iy(n2) ? wD([ry(n2), ND(u2)]) : "";
      }
      function cy(e2) {
        return (e2 = typeof e2 == "string" ? e2 : "").split("\n").length - 1;
      }
      function py(e2 = 0, t2 = 0) {
        return new Array(Math.min(e2, t2)).fill(TD);
      }
      function dy(e2, t2) {
        const n2 = {quote: '"', regex: /"/g}, r2 = {quote: "'", regex: /'/g}, u2 = t2.singleQuote ? r2 : n2, o2 = u2 === r2 ? n2 : r2;
        let a2 = false;
        if (e2.includes(u2.quote) || e2.includes(o2.quote)) {
          a2 = (e2.match(u2.regex) || []).length > (e2.match(o2.regex) || []).length;
        }
        const i2 = a2 ? o2 : u2, s2 = e2.replace(i2.regex, "\\".concat(i2.quote));
        return wD([i2.quote, s2, i2.quote]);
      }
      function fy(e2, t2) {
        const n2 = my(e2, t2), r2 = gy(e2, t2);
        return r2 ? ND(wD([n2, PD, BD(r2)])) : n2;
      }
      function hy(e2, t2) {
        const n2 = my(e2, t2), r2 = gy(e2, t2);
        return r2 ? ND(BD(wD([n2, PD, r2]))) : n2;
      }
      function my(e2, t2) {
        return e2.call(t2, "path");
      }
      function gy(e2, t2) {
        const n2 = e2.getValue(), r2 = [];
        if (n2.params.length) {
          const n3 = e2.map(t2, "params");
          r2.push(...n3);
        }
        if (n2.hash && n2.hash.pairs.length > 0) {
          const n3 = e2.call(t2, "hash");
          r2.push(n3);
        }
        return r2.length ? OD(PD, r2) : "";
      }
      function Dy(e2) {
        return e2 && e2.blockParams.length ? wD([" as |", e2.blockParams.join(" "), "|"]) : "";
      }
      function yy(e2, t2, n2) {
        let r2 = 0, u2 = 0;
        for (; ; ) {
          if (u2 === e2.length)
            return null;
          let o2 = e2.indexOf("\n", u2);
          if (o2 === -1 && (o2 = e2.length), r2 === t2)
            return u2 + n2 > o2 ? null : u2 + n2;
          if (o2 === -1)
            return null;
          r2 += 1, u2 = o2 + 1;
        }
      }
      var Ey = {print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2)
          return "";
        if (MD(e2)) {
          const e3 = yy(t2.originalText, r2.loc.start.line - 1, r2.loc.start.column), n3 = yy(t2.originalText, r2.loc.end.line - 1, r2.loc.end.column);
          return t2.originalText.slice(e3, n3);
        }
        switch (r2.type) {
          case "Block":
          case "Program":
          case "Template":
            return BD(wD(e2.map(n2, "body")));
          case "ElementNode": {
            const u2 = LD(e2, ["ElementNode"]) ? TD : "";
            if (WD(r2))
              return wD([BD(UD(e2, n2)), u2]);
            const o2 = r2.children.every((e3) => $D(e3));
            return wD([BD(UD(e2, n2)), BD(wD([o2 ? "" : ND(JD(e2, t2, n2)), r2.children.length ? TD : "", wD(["</", r2.tag, ">"])])), u2]);
          }
          case "BlockStatement": {
            const t3 = e2.getParentNode(1), u2 = t3 && t3.inverse && t3.inverse.body.length === 1 && t3.inverse.body[0] === r2 && t3.inverse.body[0].path.parts[0] === "if";
            return wD(u2 ? [uy(e2, n2), sy(e2, n2), ly(e2, n2)] : [ny(e2, n2), BD(wD([sy(e2, n2), ly(e2, n2), oy(e2, n2)]))]);
          }
          case "ElementModifierStatement":
            return BD(wD(["{{", hy(e2, n2), _D, "}}"]));
          case "MustacheStatement": {
            const t3 = qD(e2, ["AttrNode", "ConcatStatement"]), u2 = qD(e2, ["ElementNode"]) && r2.hash.pairs.length === 0 && function(e3) {
              return e3.params.length === 0;
            }(r2), o2 = t3 || u2;
            return BD(wD([HD(r2), o2 ? ND(_D) : "", hy(e2, n2), _D, XD(r2)]));
          }
          case "SubExpression":
            return BD(wD(["(", fy(e2, n2), _D, ")"]));
          case "AttrNode": {
            const u2 = r2.value.type === "TextNode";
            if (u2 && r2.value.chars === "" && r2.value.loc.start.column === r2.value.loc.end.column)
              return wD([r2.name]);
            const o2 = e2.call(n2, "value"), a2 = u2 ? dy(o2.parts.join(), t2) : o2;
            return wD([r2.name, "=", a2]);
          }
          case "ConcatStatement": {
            const r3 = t2.singleQuote ? "'" : '"';
            return wD([r3, ...e2.map((e3) => n2(e3), "parts"), r3]);
          }
          case "Hash":
            return wD([OD(PD, e2.map(n2, "pairs"))]);
          case "HashPair":
            return wD([r2.key, "=", e2.call(n2, "value")]);
          case "TextNode": {
            const t3 = 2, n3 = !jD(e2), u2 = !ID(e2), o2 = !/\S/.test(r2.chars), a2 = cy(r2.chars);
            let i2 = function(e3) {
              return cy(((e3 = typeof e3 == "string" ? e3 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
            }(r2.chars), s2 = function(e3) {
              return cy(((e3 = typeof e3 == "string" ? e3 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
            }(r2.chars);
            if ((n3 || u2) && o2 && qD(e2, ["Block", "ElementNode", "Template"]))
              return "";
            o2 && a2 ? (i2 = Math.min(a2, t3), s2 = 0) : (LD(e2, ["BlockStatement", "ElementNode"]) && (s2 = Math.max(s2, 1)), VD(e2, ["BlockStatement", "ElementNode"]) && (i2 = Math.max(i2, 1)));
            if (e2.stack.includes("attributes")) {
              if (!function(e3, t4) {
                return qD(e3, ["AttrNode"]) && e3.getParentNode().name.toLowerCase() === t4 || qD(e3, ["ConcatStatement"]) && e3.getParentNode(1).name.toLowerCase() === t4;
              }(e2, "class"))
                return wD([r2.chars]);
              let n4 = "", u3 = "";
              return qD(e2, ["ConcatStatement"]) && (VD(e2, ["MustacheStatement"]) && (n4 = " "), LD(e2, ["MustacheStatement"]) && (u3 = " ")), wD([...py(i2, t3), r2.chars.replace(/^\s+/g, n4).replace(/\s+$/, u3), ...py(s2, t3)]);
            }
            let l2 = "", c2 = "";
            s2 === 0 && LD(e2, ["MustacheStatement"]) && (c2 = " "), i2 === 0 && VD(e2, ["MustacheStatement"]) && (l2 = " "), n3 && (i2 = 0, l2 = ""), u2 && (s2 = 0, c2 = "");
            let p2 = r2.chars;
            return p2.startsWith("{{") && p2.includes("}}") && (p2 = "\\" + p2), wD([...py(i2, t3), p2.replace(/^\s+/g, l2).replace(/\s+$/, c2), ...py(s2, t3)]);
          }
          case "MustacheCommentStatement": {
            const e3 = r2.value.includes("}}") ? "--" : "";
            return wD(["{{!", e3, r2.value, e3, "}}"]);
          }
          case "PathExpression":
            return r2.original;
          case "BooleanLiteral":
            return String(r2.value);
          case "CommentStatement":
            return wD(["<!--", r2.value, "-->"]);
          case "StringLiteral":
            return dy(r2.value, t2);
          case "NumberLiteral":
            return String(r2.value);
          case "UndefinedLiteral":
            return "undefined";
          case "NullLiteral":
            return "null";
          default:
            throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
        }
      }, massageAstNode: function(e2, t2) {
        if (delete t2.loc, delete t2.selfClosing, e2.type === "TextNode") {
          const n2 = e2.chars.trim();
          if (!n2)
            return null;
          t2.chars = n2;
        }
      }}, Cy = ["hbs", "htmlbars"], by = [".handlebars", ".hbs"], Ay = {name: "Handlebars", type: "markup", group: "HTML", aliases: Cy, extensions: by, tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155};
      var vy = {languages: [As(Ue(Object.freeze({__proto__: null, name: "Handlebars", type: "markup", group: "HTML", aliases: Cy, extensions: by, tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155, default: Ay})), () => ({since: null, parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"]}))], printers: {glimmer: Ey}, parsers: {get glimmer() {
        return {}.parsers.glimmer;
      }}};
      var Fy = {hasPragma: function(e2) {
        return /^\s*#[^\S\n]*@(format|prettier)\s*(\n|$)/.test(e2);
      }, insertPragma: function(e2) {
        return "# @format\n\n" + e2;
      }};
      const {concat: xy, join: Sy, hardline: wy, line: By, softline: Ty, group: ky, indent: Ny, ifBreak: Oy} = dn.builders, {hasIgnoreComment: Py, isNextLineEmpty: _y} = Lt, {insertPragma: Iy} = Fy;
      function jy(e2, t2, n2) {
        if (n2.directives.length === 0)
          return "";
        const r2 = Sy(By, e2.map(t2, "directives"));
        return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? ky(xy([By, r2])) : xy([" ", ky(Ny(xy([Ty, r2])))]);
      }
      function My(e2, t2, n2) {
        const r2 = e2.getValue().length;
        return e2.map((e3, u2) => {
          const o2 = n2(e3);
          return _y(t2.originalText, e3.getValue(), t2.locEnd) && u2 < r2 - 1 ? xy([o2, wy]) : o2;
        });
      }
      function Ly(e2, t2, n2) {
        const r2 = e2.getNode(), u2 = [], {interfaces: o2} = r2, a2 = e2.map((e3) => n2(e3), "interfaces");
        for (let e3 = 0; e3 < o2.length; e3++) {
          const n3 = o2[e3];
          u2.push(a2[e3]);
          const r3 = o2[e3 + 1];
          if (r3) {
            const e4 = t2.originalText.slice(n3.loc.end, r3.loc.start), o3 = e4.includes("#"), a3 = e4.replace(/#.*/g, "").trim();
            u2.push(a3 === "," ? "," : " &"), u2.push(o3 ? By : " ");
          }
        }
        return u2;
      }
      var Ry = {print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2)
          return "";
        if (typeof r2 == "string")
          return r2;
        switch (r2.kind) {
          case "Document": {
            const u2 = [];
            return e2.map((e3, o2) => {
              u2.push(xy([e3.call(n2)])), o2 !== r2.definitions.length - 1 && (u2.push(wy), _y(t2.originalText, e3.getValue(), t2.locEnd) && u2.push(wy));
            }, "definitions"), xy([xy(u2), wy]);
          }
          case "OperationDefinition": {
            const u2 = t2.originalText[t2.locStart(r2)] !== "{", o2 = !!r2.name;
            return xy([u2 ? r2.operation : "", u2 && o2 ? xy([" ", e2.call(n2, "name")]) : "", r2.variableDefinitions && r2.variableDefinitions.length ? ky(xy(["(", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.map(n2, "variableDefinitions"))])), Ty, ")"])) : "", jy(e2, n2, r2), r2.selectionSet && (u2 || o2) ? " " : "", e2.call(n2, "selectionSet")]);
          }
          case "FragmentDefinition":
            return xy(["fragment ", e2.call(n2, "name"), r2.variableDefinitions && r2.variableDefinitions.length ? ky(xy(["(", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.map(n2, "variableDefinitions"))])), Ty, ")"])) : "", " on ", e2.call(n2, "typeCondition"), jy(e2, n2, r2), " ", e2.call(n2, "selectionSet")]);
          case "SelectionSet":
            return xy(["{", Ny(xy([wy, Sy(wy, e2.call((e3) => My(e3, t2, n2), "selections"))])), wy, "}"]);
          case "Field":
            return ky(xy([r2.alias ? xy([e2.call(n2, "alias"), ": "]) : "", e2.call(n2, "name"), r2.arguments.length > 0 ? ky(xy(["(", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.call((e3) => My(e3, t2, n2), "arguments"))])), Ty, ")"])) : "", jy(e2, n2, r2), r2.selectionSet ? " " : "", e2.call(n2, "selectionSet")]));
          case "Name":
            return r2.value;
          case "StringValue":
            return r2.block ? xy(['"""', wy, Sy(wy, r2.value.replace(/"""/g, "\\$&").split("\n")), wy, '"""']) : xy(['"', r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"']);
          case "IntValue":
          case "FloatValue":
          case "EnumValue":
            return r2.value;
          case "BooleanValue":
            return r2.value ? "true" : "false";
          case "NullValue":
            return "null";
          case "Variable":
            return xy(["$", e2.call(n2, "name")]);
          case "ListValue":
            return ky(xy(["[", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.map(n2, "values"))])), Ty, "]"]));
          case "ObjectValue":
            return ky(xy(["{", t2.bracketSpacing && r2.fields.length > 0 ? " " : "", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.map(n2, "fields"))])), Ty, Oy("", t2.bracketSpacing && r2.fields.length > 0 ? " " : ""), "}"]));
          case "ObjectField":
          case "Argument":
            return xy([e2.call(n2, "name"), ": ", e2.call(n2, "value")]);
          case "Directive":
            return xy(["@", e2.call(n2, "name"), r2.arguments.length > 0 ? ky(xy(["(", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.call((e3) => My(e3, t2, n2), "arguments"))])), Ty, ")"])) : ""]);
          case "NamedType":
            return e2.call(n2, "name");
          case "VariableDefinition":
            return xy([e2.call(n2, "variable"), ": ", e2.call(n2, "type"), r2.defaultValue ? xy([" = ", e2.call(n2, "defaultValue")]) : "", jy(e2, n2, r2)]);
          case "ObjectTypeExtension":
          case "ObjectTypeDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", r2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", e2.call(n2, "name"), r2.interfaces.length > 0 ? xy([" implements ", xy(Ly(e2, t2, n2))]) : "", jy(e2, n2, r2), r2.fields.length > 0 ? xy([" {", Ny(xy([wy, Sy(wy, e2.call((e3) => My(e3, t2, n2), "fields"))])), wy, "}"]) : ""]);
          case "FieldDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", e2.call(n2, "name"), r2.arguments.length > 0 ? ky(xy(["(", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.call((e3) => My(e3, t2, n2), "arguments"))])), Ty, ")"])) : "", ": ", e2.call(n2, "type"), jy(e2, n2, r2)]);
          case "DirectiveDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", "directive ", "@", e2.call(n2, "name"), r2.arguments.length > 0 ? ky(xy(["(", Ny(xy([Ty, Sy(xy([Oy("", ", "), Ty]), e2.call((e3) => My(e3, t2, n2), "arguments"))])), Ty, ")"])) : "", r2.repeatable ? " repeatable" : "", xy([" on ", Sy(" | ", e2.map(n2, "locations"))])]);
          case "EnumTypeExtension":
          case "EnumTypeDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", r2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", e2.call(n2, "name"), jy(e2, n2, r2), r2.values.length > 0 ? xy([" {", Ny(xy([wy, Sy(wy, e2.call((e3) => My(e3, t2, n2), "values"))])), wy, "}"]) : ""]);
          case "EnumValueDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", e2.call(n2, "name"), jy(e2, n2, r2)]);
          case "InputValueDefinition":
            return xy([e2.call(n2, "description"), r2.description ? r2.description.block ? wy : By : "", e2.call(n2, "name"), ": ", e2.call(n2, "type"), r2.defaultValue ? xy([" = ", e2.call(n2, "defaultValue")]) : "", jy(e2, n2, r2)]);
          case "InputObjectTypeExtension":
          case "InputObjectTypeDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", r2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", e2.call(n2, "name"), jy(e2, n2, r2), r2.fields.length > 0 ? xy([" {", Ny(xy([wy, Sy(wy, e2.call((e3) => My(e3, t2, n2), "fields"))])), wy, "}"]) : ""]);
          case "SchemaDefinition":
            return xy(["schema", jy(e2, n2, r2), " {", r2.operationTypes.length > 0 ? Ny(xy([wy, Sy(wy, e2.call((e3) => My(e3, t2, n2), "operationTypes"))])) : "", wy, "}"]);
          case "OperationTypeDefinition":
            return xy([e2.call(n2, "operation"), ": ", e2.call(n2, "type")]);
          case "InterfaceTypeExtension":
          case "InterfaceTypeDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", r2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", e2.call(n2, "name"), r2.interfaces.length > 0 ? xy([" implements ", xy(Ly(e2, t2, n2))]) : "", jy(e2, n2, r2), r2.fields.length > 0 ? xy([" {", Ny(xy([wy, Sy(wy, e2.call((e3) => My(e3, t2, n2), "fields"))])), wy, "}"]) : ""]);
          case "FragmentSpread":
            return xy(["...", e2.call(n2, "name"), jy(e2, n2, r2)]);
          case "InlineFragment":
            return xy(["...", r2.typeCondition ? xy([" on ", e2.call(n2, "typeCondition")]) : "", jy(e2, n2, r2), " ", e2.call(n2, "selectionSet")]);
          case "UnionTypeExtension":
          case "UnionTypeDefinition":
            return ky(xy([e2.call(n2, "description"), r2.description ? wy : "", ky(xy([r2.kind === "UnionTypeExtension" ? "extend " : "", "union ", e2.call(n2, "name"), jy(e2, n2, r2), r2.types.length > 0 ? xy([" =", Oy("", " "), Ny(xy([Oy(xy([By, "  "])), Sy(xy([By, "| "]), e2.map(n2, "types"))]))]) : ""]))]));
          case "ScalarTypeExtension":
          case "ScalarTypeDefinition":
            return xy([e2.call(n2, "description"), r2.description ? wy : "", r2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", e2.call(n2, "name"), jy(e2, n2, r2)]);
          case "NonNullType":
            return xy([e2.call(n2, "type"), "!"]);
          case "ListType":
            return xy(["[", e2.call(n2, "type"), "]"]);
          default:
            throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
        }
      }, massageAstNode: function(e2, t2) {
        delete t2.loc, delete t2.comments;
      }, hasPrettierIgnore: Py, insertPragma: Iy, printComment: function(e2) {
        const t2 = e2.getValue();
        if (t2.kind === "Comment")
          return "#" + t2.value.trimEnd();
        throw new Error("Not a comment: " + JSON.stringify(t2));
      }, canAttachComment: function(e2) {
        return e2.kind && e2.kind !== "Comment";
      }}, qy = {bracketSpacing: Bh.bracketSpacing}, Vy = [".graphql", ".gql", ".graphqls"], Wy = {name: "GraphQL", type: "data", extensions: Vy, tmScope: "source.graphql", aceMode: "text", languageId: 139};
      var $y = {languages: [As(Ue(Object.freeze({__proto__: null, name: "GraphQL", type: "data", extensions: Vy, tmScope: "source.graphql", aceMode: "text", languageId: 139, default: Wy})), () => ({since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"]}))], options: qy, printers: {graphql: Ry}, parsers: {get graphql() {
        return {}.parsers.graphql;
      }}};
      const {getLast: Uy} = Lt, {cjkPattern: zy, kPattern: Jy, punctuationPattern: Gy} = {cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u3000-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"}, Hy = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], Xy = Hy.concat(["tableCell", "paragraph", "heading"]), Yy = new RegExp(Jy), Ky = new RegExp(Gy);
      function Qy(e2, t2) {
        const [, n2, r2, u2] = t2.slice(e2.position.start.offset, e2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
        return {numberText: n2, marker: r2, leadingSpaces: u2};
      }
      var Zy = {mapAst: function(e2, t2) {
        return function e3(n2, r2, u2) {
          u2 = u2 || [];
          const o2 = Object.assign({}, t2(n2, r2, u2));
          return o2.children && (o2.children = o2.children.map((t3, n3) => e3(t3, n3, [o2].concat(u2)))), o2;
        }(e2, null, null);
      }, splitText: function(e2, t2) {
        const n2 = [];
        return (t2.proseWrap === "preserve" ? e2 : e2.replace(new RegExp("(".concat(zy, ")\n(").concat(zy, ")"), "g"), "$1$2")).split(/([\t\n ]+)/).forEach((e3, t3, u2) => {
          t3 % 2 != 1 ? (t3 !== 0 && t3 !== u2.length - 1 || e3 !== "") && e3.split(new RegExp("(".concat(zy, ")"))).forEach((e4, t4, n3) => {
            (t4 !== 0 && t4 !== n3.length - 1 || e4 !== "") && (t4 % 2 != 0 ? r2(Ky.test(e4) ? {type: "word", value: e4, kind: "cjk-punctuation", hasLeadingPunctuation: true, hasTrailingPunctuation: true} : {type: "word", value: e4, kind: Yy.test(e4) ? "k-letter" : "cj-letter", hasLeadingPunctuation: false, hasTrailingPunctuation: false}) : e4 !== "" && r2({type: "word", value: e4, kind: "non-cjk", hasLeadingPunctuation: Ky.test(e4[0]), hasTrailingPunctuation: Ky.test(Uy(e4))}));
          }) : n2.push({type: "whitespace", value: /\n/.test(e3) ? "\n" : " "});
        }), n2;
        function r2(e3) {
          const t3 = Uy(n2);
          var r3, u2;
          t3 && t3.type === "word" && (t3.kind === "non-cjk" && e3.kind === "cj-letter" && !t3.hasTrailingPunctuation || t3.kind === "cj-letter" && e3.kind === "non-cjk" && !e3.hasLeadingPunctuation ? n2.push({type: "whitespace", value: " "}) : (r3 = "non-cjk", u2 = "cjk-punctuation", t3.kind === r3 && e3.kind === u2 || t3.kind === u2 && e3.kind === r3 || [t3.value, e3.value].some((e4) => /\u3000/.test(e4)) || n2.push({type: "whitespace", value: ""}))), n2.push(e3);
        }
      }, punctuationPattern: Gy, getFencedCodeBlockValue: function(e2, t2) {
        const n2 = t2.trimEnd().slice(e2.position.start.offset, e2.position.end.offset), r2 = n2.match(/^\s*/)[0].length, u2 = new RegExp("^\\s{0,".concat(r2, "}")), o2 = n2.split("\n"), a2 = n2[r2], i2 = n2.slice(r2).match(new RegExp("^[".concat(a2, "]+")))[0], s2 = new RegExp("^\\s{0,3}".concat(i2)).test(o2[o2.length - 1].slice(l2(o2.length - 1)));
        return o2.slice(1, s2 ? -1 : void 0).map((e3, t3) => e3.slice(l2(t3 + 1)).replace(u2, "")).join("\n");
        function l2(t3) {
          return e2.position.indent[t3 - 1] - 1;
        }
      }, getOrderedListItemInfo: Qy, hasGitDiffFriendlyOrderedList: function(e2, t2) {
        if (!e2.ordered)
          return false;
        if (e2.children.length < 2)
          return false;
        const n2 = Number(Qy(e2.children[0], t2.originalText).numberText), r2 = Number(Qy(e2.children[1], t2.originalText).numberText);
        if (n2 === 0 && e2.children.length > 2) {
          const n3 = Number(Qy(e2.children[2], t2.originalText).numberText);
          return r2 === 1 && n3 === 1;
        }
        return r2 === 1;
      }, INLINE_NODE_TYPES: Hy, INLINE_NODE_WRAPPER_TYPES: Xy, isAutolink: function(e2, t2) {
        if (!e2 || e2.type !== "link" || e2.children.length !== 1)
          return false;
        const n2 = e2.children[0];
        return n2 && t2.locStart(e2) === t2.locStart(n2) && t2.locEnd(e2) === t2.locEnd(n2);
      }};
      const {getParserName: eE, getMaxContinuousCount: tE} = Lt, {builders: {hardline: nE, concat: rE, markAsRoot: uE}, utils: {replaceNewlinesWithLiterallines: oE}} = dn, {print: aE} = Em, {getFencedCodeBlockValue: iE} = Zy;
      var sE = function(e2, t2, n2, r2) {
        const u2 = e2.getValue();
        if (u2.type === "code" && u2.lang !== null) {
          const e3 = u2.lang.match(/^[\w-]+/), t3 = e3 ? e3[0] : "", o2 = eE(t3, r2);
          if (o2) {
            const e4 = r2.__inJsTemplate ? "~" : "`", t4 = e4.repeat(Math.max(3, tE(u2.value, e4) + 1)), a2 = n2(iE(u2, r2.originalText), {parser: o2}, {stripTrailingHardline: true});
            return uE(rE([t4, u2.lang, u2.meta ? " " + u2.meta : "", nE, oE(a2), nE, t4]));
          }
        }
        switch (u2.type) {
          case "front-matter":
            return aE(u2, n2);
          case "importExport":
            return rE([n2(u2.value, {parser: "babel"}, {stripTrailingHardline: true}), nE]);
          case "jsx":
            return n2("<$>".concat(u2.value, "</$>"), {parser: "__js_expression", rootMarker: "mdx"}, {stripTrailingHardline: true});
        }
        return null;
      };
      const {parse: lE} = Em, cE = ["format", "prettier"];
      function pE(e2) {
        const t2 = "@(".concat(cE.join("|"), ")"), n2 = new RegExp(["<!--\\s*".concat(t2, "\\s*-->"), "<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t2, "[^\\S\n]*($|\n)[\\s\\S]*\n.*-->")].join("|"), "m"), r2 = e2.match(n2);
        return r2 && r2.index === 0;
      }
      var dE = {startWithPragma: pE, hasPragma: (e2) => pE(lE(e2).content.trimStart()), insertPragma: (e2) => {
        const t2 = lE(e2), n2 = "<!-- @".concat(cE[0], " -->");
        return t2.frontMatter ? "".concat(t2.frontMatter.raw, "\n\n").concat(n2, "\n\n").concat(t2.content) : "".concat(n2, "\n\n").concat(t2.content);
      }};
      const {getOrderedListItemInfo: fE, mapAst: hE, splitText: mE} = Zy, gE = /^([\u0000-\uffff]|[\ud800-\udbff][\udc00-\udfff])$/;
      function DE(e2, t2, n2) {
        return hE(e2, (e3) => {
          if (!e3.children)
            return e3;
          const r2 = e3.children.reduce((e4, r3) => {
            const u2 = e4[e4.length - 1];
            return u2 && t2(u2, r3) ? e4.splice(-1, 1, n2(u2, r3)) : e4.push(r3), e4;
          }, []);
          return Object.assign({}, e3, {children: r2});
        });
      }
      var yE = function(e2, t2) {
        return e2 = function(e3) {
          return DE(e3, (e4, t3) => e4.type === "importExport" && t3.type === "importExport", (e4, t3) => ({type: "importExport", value: e4.value + "\n\n" + t3.value, position: {start: e4.position.start, end: t3.position.end}}));
        }(e2 = function(e3) {
          return hE(e3, (e4) => e4.type !== "import" && e4.type !== "export" ? e4 : Object.assign({}, e4, {type: "importExport"}));
        }(e2 = function(e3, t3) {
          return hE(e3, (e4, n2, [r2]) => {
            if (e4.type !== "text")
              return e4;
            let {value: u2} = e4;
            return r2.type === "paragraph" && (n2 === 0 && (u2 = u2.trimStart()), n2 === r2.children.length - 1 && (u2 = u2.trimEnd())), {type: "sentence", position: e4.position, children: mE(u2, t3)};
          });
        }(e2 = function(e3, t3) {
          return hE(e3, (e4, t4, n3) => {
            if (e4.type === "list" && e4.children.length !== 0) {
              for (let t5 = 0; t5 < n3.length; t5++) {
                const r3 = n3[t5];
                if (r3.type === "list" && !r3.isAligned)
                  return e4.isAligned = false, e4;
              }
              e4.isAligned = r2(e4);
            }
            return e4;
          });
          function n2(e4) {
            return e4.children.length === 0 ? -1 : e4.children[0].position.start.column - 1;
          }
          function r2(e4) {
            if (!e4.ordered)
              return true;
            const [r3, u2] = e4.children;
            if (fE(r3, t3.originalText).leadingSpaces.length > 1)
              return true;
            const o2 = n2(r3);
            if (o2 === -1)
              return false;
            if (e4.children.length === 1)
              return o2 % t3.tabWidth == 0;
            if (o2 !== n2(u2))
              return false;
            if (o2 % t3.tabWidth == 0)
              return true;
            return fE(u2, t3.originalText).leadingSpaces.length > 1;
          }
        }(e2 = function(e3, t3) {
          return hE(e3, (e4, n2, r2) => {
            if (e4.type === "code") {
              const n3 = /^\n?( {4,}|\t)/.test(t3.originalText.slice(e4.position.start.offset, e4.position.end.offset));
              if (e4.isIndented = n3, n3)
                for (let e5 = 0; e5 < r2.length; e5++) {
                  const t4 = r2[e5];
                  if (t4.hasIndentedCodeblock)
                    break;
                  t4.type === "list" && (t4.hasIndentedCodeblock = true);
                }
            }
            return e4;
          });
        }(e2 = function(e3) {
          return hE(e3, (e4) => e4.type !== "inlineCode" ? e4 : Object.assign({}, e4, {value: e4.value.replace(/\s+/g, " ")}));
        }(e2 = function(e3) {
          return DE(e3, (e4, t3) => e4.type === "text" && t3.type === "text", (e4, t3) => ({type: "text", value: e4.value + t3.value, position: {start: e4.position.start, end: t3.position.end}}));
        }(e2 = function(e3, t3) {
          return hE(e3, (e4) => e4.type !== "text" ? e4 : Object.assign({}, e4, {value: e4.value !== "*" && e4.value !== "_" && e4.value !== "$" && gE.test(e4.value) && e4.position.end.offset - e4.position.start.offset !== e4.value.length ? t3.originalText.slice(e4.position.start.offset, e4.position.end.offset) : e4.value}));
        }(e2, t2))), t2), t2), t2)));
      };
      const {getLast: EE, getMinNotPresentContinuousCount: CE, getMaxContinuousCount: bE, getStringWidth: AE} = Lt, {builders: {breakParent: vE, concat: FE, join: xE, line: SE, literalline: wE, markAsRoot: BE, hardline: TE, softline: kE, ifBreak: NE, fill: OE, align: PE, indent: _E, group: IE}, utils: {normalizeDoc: jE}, printer: {printDocToString: ME}} = dn, {replaceEndOfLineWith: LE, isFrontMatterNode: RE} = Lt, {getFencedCodeBlockValue: qE, hasGitDiffFriendlyOrderedList: VE, splitText: WE, punctuationPattern: $E, INLINE_NODE_TYPES: UE, INLINE_NODE_WRAPPER_TYPES: zE, isAutolink: JE} = Zy, GE = new Set(["importExport"]), HE = ["heading", "tableCell", "link"], XE = new Set(["listItem", "definition", "footnoteDefinition"]);
      function YE(e2, t2, n2, r2) {
        const u2 = e2.getValue(), o2 = u2.checked === null ? "" : u2.checked ? "[x] " : "[ ] ";
        return FE([o2, nC(e2, t2, n2, {processor: (e3, u3) => {
          if (u3 === 0 && e3.getValue().type !== "list")
            return PE(" ".repeat(o2.length), e3.call(n2));
          const a2 = " ".repeat((i2 = t2.tabWidth - r2.length, l2 = 3, i2 < (s2 = 0) ? s2 : i2 > l2 ? l2 : i2));
          var i2, s2, l2;
          return FE([a2, PE(a2, e3.call(n2))]);
        }})]);
      }
      function KE(e2, t2) {
        return function(e3, t3, n2) {
          n2 = n2 || (() => true);
          let r2 = -1;
          for (const u2 of t3.children)
            if (u2.type === e3.type && n2(u2) ? r2++ : r2 = -1, u2 === e3)
              return r2;
        }(e2, t2, (t3) => t3.ordered === e2.ordered);
      }
      function QE(e2, t2) {
        const n2 = [].concat(t2);
        let r2, u2 = -1;
        for (; r2 = e2.getParentNode(++u2); )
          if (n2.includes(r2.type))
            return u2;
        return -1;
      }
      function ZE(e2, t2) {
        const n2 = QE(e2, t2);
        return n2 === -1 ? null : e2.getParentNode(n2);
      }
      function eC(e2, t2, n2) {
        if (n2.proseWrap === "preserve" && t2 === "\n")
          return TE;
        const r2 = n2.proseWrap === "always" && !ZE(e2, HE);
        return t2 !== "" ? r2 ? SE : " " : r2 ? kE : "";
      }
      function tC(e2, t2, n2) {
        const r2 = [];
        let u2 = null;
        const {children: o2} = e2.getValue();
        return o2.forEach((e3, t3) => {
          switch (uC(e3)) {
            case "start":
              u2 === null && (u2 = {index: t3, offset: e3.position.end.offset});
              break;
            case "end":
              u2 !== null && (r2.push({start: u2, end: {index: t3, offset: e3.position.start.offset}}), u2 = null);
          }
        }), nC(e2, t2, n2, {processor: (e3, u3) => {
          if (r2.length !== 0) {
            const e4 = r2[0];
            if (u3 === e4.start.index)
              return FE([o2[e4.start.index].value, t2.originalText.slice(e4.start.offset, e4.end.offset), o2[e4.end.index].value]);
            if (e4.start.index < u3 && u3 < e4.end.index)
              return false;
            if (u3 === e4.end.index)
              return r2.shift(), false;
          }
          return e3.call(n2);
        }});
      }
      function nC(e2, t2, n2, r2) {
        const u2 = (r2 = r2 || {}).postprocessor || FE, o2 = r2.processor || ((e3) => e3.call(n2)), a2 = e2.getValue(), i2 = [];
        let s2;
        return e2.map((e3, n3) => {
          const r3 = e3.getValue(), u3 = o2(e3, n3);
          if (u3 !== false) {
            const e4 = {parts: i2, prevNode: s2, parentNode: a2, options: t2};
            (function(e5, t3) {
              const n4 = t3.parts.length === 0, r4 = UE.includes(e5.type), u4 = e5.type === "html" && zE.includes(t3.parentNode.type);
              return n4 || r4 || u4;
            })(r3, e4) || (i2.push(TE), s2 && GE.has(s2.type) || (function(e5, t3) {
              const n4 = (t3.prevNode && t3.prevNode.type) === e5.type && XE.has(e5.type), r4 = t3.parentNode.type === "listItem" && !t3.parentNode.loose, u4 = t3.prevNode && t3.prevNode.type === "listItem" && t3.prevNode.loose, o3 = uC(t3.prevNode) === "next", a3 = e5.type === "html" && t3.prevNode && t3.prevNode.type === "html" && t3.prevNode.position.end.line + 1 === e5.position.start.line, i3 = e5.type === "html" && t3.parentNode.type === "listItem" && t3.prevNode && t3.prevNode.type === "paragraph" && t3.prevNode.position.end.line + 1 === e5.position.start.line;
              return u4 || !(n4 || r4 || o3 || a3 || i3);
            }(r3, e4) || oC(r3, e4)) && i2.push(TE), oC(r3, e4) && i2.push(TE)), i2.push(u3), s2 = r3;
          }
        }, "children"), u2(i2);
      }
      function rC(e2) {
        let t2 = e2;
        for (; t2.children && t2.children.length !== 0; )
          t2 = t2.children[t2.children.length - 1];
        return t2;
      }
      function uC(e2) {
        if (e2.type !== "html")
          return false;
        const t2 = e2.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
        return t2 !== null && (t2[1] ? t2[1] : "next");
      }
      function oC(e2, t2) {
        const n2 = t2.prevNode && t2.prevNode.type === "list", r2 = e2.type === "code" && e2.isIndented;
        return n2 && r2;
      }
      function aC(e2, t2) {
        const n2 = [" "].concat(t2 || []);
        return new RegExp(n2.map((e3) => "\\".concat(e3)).join("|")).test(e2) ? "<".concat(e2, ">") : e2;
      }
      function iC(e2, t2, n2) {
        if (n2 == null && (n2 = true), !e2)
          return "";
        if (n2)
          return " " + iC(e2, t2, false);
        if ((e2 = e2.replace(/\\(["')])/g, "$1")).includes('"') && e2.includes("'") && !e2.includes(")"))
          return "(".concat(e2, ")");
        const r2 = e2.split("'").length - 1, u2 = e2.split('"').length - 1, o2 = r2 > u2 ? '"' : u2 > r2 || t2.singleQuote ? "'" : '"';
        return e2 = (e2 = e2.replace(/\\/, "\\\\")).replace(new RegExp("(".concat(o2, ")"), "g"), "\\$1"), "".concat(o2).concat(e2).concat(o2);
      }
      var sC = {preprocess: yE, print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (function(e3) {
          const t3 = ZE(e3, ["linkReference", "imageReference"]);
          return t3 && (t3.type !== "linkReference" || t3.referenceType !== "full");
        }(e2))
          return FE(WE(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset), t2).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : eC(e2, n3.value, t2)));
        switch (r2.type) {
          case "front-matter":
            return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
          case "root":
            return r2.children.length === 0 ? "" : FE([jE(tC(e2, t2, n2)), GE.has(rC(r2).type) ? "" : TE]);
          case "paragraph":
            return nC(e2, t2, n2, {postprocessor: OE});
          case "sentence":
            return nC(e2, t2, n2);
          case "word": {
            let n3 = r2.value.replace(/[$*]/g, "\\$&").replace(new RegExp(["(^|".concat($E, ")(_+)"), "(_+)(".concat($E, "|$)")].join("|"), "g"), (e3, t3, n4, r3, u3) => (n4 ? "".concat(t3).concat(n4) : "".concat(r3).concat(u3)).replace(/_/g, "\\_"));
            const u2 = (e3, t3, n4) => e3.type === "sentence" && n4 === 0, o2 = (e3, n4, r3) => JE(e3.children[r3 - 1], t2);
            return n3 !== r2.value && (e2.match(void 0, u2, o2) || e2.match(void 0, u2, (e3, t3, n4) => e3.type === "emphasis" && n4 === 0, o2)) && (n3 = n3.replace(/^(\\?[*_])+/, (e3) => e3.replace(/\\/g, ""))), n3;
          }
          case "whitespace": {
            const n3 = e2.getParentNode(), u2 = n3.children.indexOf(r2), o2 = n3.children[u2 + 1], a2 = o2 && /^>|^([*+-]|#{1,6}|\d+[).])$/.test(o2.value) ? "never" : t2.proseWrap;
            return eC(e2, r2.value, {proseWrap: a2});
          }
          case "emphasis": {
            let u2;
            if (JE(r2.children[0], t2))
              u2 = t2.originalText[r2.position.start.offset];
            else {
              const t3 = e2.getParentNode(), n3 = t3.children.indexOf(r2), o2 = t3.children[n3 - 1], a2 = t3.children[n3 + 1];
              u2 = o2 && o2.type === "sentence" && o2.children.length > 0 && EE(o2.children).type === "word" && !EE(o2.children).hasTrailingPunctuation || a2 && a2.type === "sentence" && a2.children.length > 0 && a2.children[0].type === "word" && !a2.children[0].hasLeadingPunctuation || ZE(e2, "emphasis") ? "*" : "_";
            }
            return FE([u2, nC(e2, t2, n2), u2]);
          }
          case "strong":
            return FE(["**", nC(e2, t2, n2), "**"]);
          case "delete":
            return FE(["~~", nC(e2, t2, n2), "~~"]);
          case "inlineCode": {
            const e3 = CE(r2.value, "`"), t3 = "`".repeat(e3 || 1), n3 = e3 && !/^\s/.test(r2.value) ? " " : "";
            return FE([t3, n3, r2.value, n3, t3]);
          }
          case "link":
            switch (t2.originalText[r2.position.start.offset]) {
              case "<": {
                const e3 = "mailto:", n3 = r2.url.startsWith(e3) && t2.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e3.length) !== e3 ? r2.url.slice(e3.length) : r2.url;
                return FE(["<", n3, ">"]);
              }
              case "[":
                return FE(["[", nC(e2, t2, n2), "](", aC(r2.url, ")"), iC(r2.title, t2), ")"]);
              default:
                return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
            }
          case "image":
            return FE(["![", r2.alt || "", "](", aC(r2.url, ")"), iC(r2.title, t2), ")"]);
          case "blockquote":
            return FE(["> ", PE("> ", nC(e2, t2, n2))]);
          case "heading":
            return FE(["#".repeat(r2.depth) + " ", nC(e2, t2, n2)]);
          case "code": {
            if (r2.isIndented) {
              const e4 = " ".repeat(4);
              return PE(e4, FE([e4, FE(LE(r2.value, TE))]));
            }
            const e3 = t2.__inJsTemplate ? "~" : "`", n3 = e3.repeat(Math.max(3, bE(r2.value, e3) + 1));
            return FE([n3, r2.lang || "", r2.meta ? " " + r2.meta : "", TE, FE(LE(qE(r2, t2.originalText), TE)), TE, n3]);
          }
          case "html": {
            const t3 = e2.getParentNode(), n3 = t3.type === "root" && EE(t3.children) === r2 ? r2.value.trimEnd() : r2.value, u2 = /^<!--[\S\s]*-->$/.test(n3);
            return FE(LE(n3, u2 ? TE : BE(wE)));
          }
          case "list": {
            const u2 = KE(r2, e2.getParentNode()), o2 = VE(r2, t2);
            return nC(e2, t2, n2, {processor: (e3, a2) => {
              const i2 = function() {
                const e4 = r2.ordered ? (a2 === 0 ? r2.start : o2 ? 1 : r2.start + a2) + (u2 % 2 == 0 ? ". " : ") ") : u2 % 2 == 0 ? "- " : "* ";
                return r2.isAligned || r2.hasIndentedCodeblock ? function(e5, t3) {
                  const n3 = r3();
                  return e5 + " ".repeat(n3 >= 4 ? 0 : n3);
                  function r3() {
                    const n4 = e5.length % t3.tabWidth;
                    return n4 === 0 ? 0 : t3.tabWidth - n4;
                  }
                }(e4, t2) : e4;
              }(), s2 = e3.getValue();
              return s2.children.length === 2 && s2.children[1].type === "html" && s2.children[0].position.start.column !== s2.children[1].position.start.column ? FE([i2, YE(e3, t2, n2, i2)]) : FE([i2, PE(" ".repeat(i2.length), YE(e3, t2, n2, i2))]);
            }});
          }
          case "thematicBreak": {
            const t3 = QE(e2, "list");
            if (t3 === -1)
              return "---";
            return KE(e2.getParentNode(t3), e2.getParentNode(t3 + 1)) % 2 == 0 ? "***" : "---";
          }
          case "linkReference":
            return FE(["[", nC(e2, t2, n2), "]", r2.referenceType === "full" ? FE(["[", r2.identifier, "]"]) : r2.referenceType === "collapsed" ? "[]" : ""]);
          case "imageReference":
            switch (r2.referenceType) {
              case "full":
                return FE(["![", r2.alt || "", "][", r2.identifier, "]"]);
              default:
                return FE(["![", r2.alt, "]", r2.referenceType === "collapsed" ? "[]" : ""]);
            }
          case "definition": {
            const e3 = t2.proseWrap === "always" ? SE : " ";
            return IE(FE([FE(["[", r2.identifier, "]:"]), _E(FE([e3, aC(r2.url), r2.title === null ? "" : FE([e3, iC(r2.title, t2, false)])]))]));
          }
          case "footnote":
            return FE(["[^", nC(e2, t2, n2), "]"]);
          case "footnoteReference":
            return FE(["[^", r2.identifier, "]"]);
          case "footnoteDefinition": {
            const u2 = e2.getParentNode().children[e2.getName() + 1], o2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t2.proseWrap === "never" || t2.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
            return FE(["[^", r2.identifier, "]: ", o2 ? nC(e2, t2, n2) : IE(FE([PE(" ".repeat(4), nC(e2, t2, n2, {processor: (e3, t3) => t3 === 0 ? IE(FE([kE, e3.call(n2)])) : e3.call(n2)})), u2 && u2.type === "footnoteDefinition" ? kE : ""]))]);
          }
          case "table":
            return function(e3, t3, n3) {
              const r3 = TE.parts[0], u2 = e3.getValue(), o2 = [];
              e3.map((e4) => {
                const r4 = [];
                e4.map((e5) => {
                  r4.push(ME(e5.call(n3), t3).formatted);
                }, "children"), o2.push(r4);
              }, "children");
              const a2 = o2.reduce((e4, t4) => e4.map((e5, n4) => Math.max(e5, AE(t4[n4]))), o2[0].map(() => 3)), i2 = xE(r3, [c2(o2[0]), l2(), xE(r3, o2.slice(1).map((e4) => c2(e4)))]);
              if (t3.proseWrap !== "never")
                return FE([vE, i2]);
              const s2 = xE(r3, [c2(o2[0], true), l2(true), xE(r3, o2.slice(1).map((e4) => c2(e4, true)))]);
              return FE([vE, IE(NE(s2, i2))]);
              function l2(e4) {
                return FE(["| ", xE(" | ", a2.map((t4, n4) => {
                  const r4 = e4 ? 3 : t4;
                  switch (u2.align[n4]) {
                    case "left":
                      return ":" + "-".repeat(r4 - 1);
                    case "right":
                      return "-".repeat(r4 - 1) + ":";
                    case "center":
                      return ":" + "-".repeat(r4 - 2) + ":";
                    default:
                      return "-".repeat(r4);
                  }
                })), " |"]);
              }
              function c2(e4, t4) {
                return FE(["| ", xE(" | ", t4 ? e4 : e4.map((e5, t5) => {
                  switch (u2.align[t5]) {
                    case "right":
                      return d2(e5, a2[t5]);
                    case "center":
                      return f2(e5, a2[t5]);
                    default:
                      return p2(e5, a2[t5]);
                  }
                })), " |"]);
              }
              function p2(e4, t4) {
                const n4 = t4 - AE(e4);
                return FE([e4, " ".repeat(n4)]);
              }
              function d2(e4, t4) {
                const n4 = t4 - AE(e4);
                return FE([" ".repeat(n4), e4]);
              }
              function f2(e4, t4) {
                const n4 = t4 - AE(e4), r4 = Math.floor(n4 / 2), u3 = n4 - r4;
                return FE([" ".repeat(r4), e4, " ".repeat(u3)]);
              }
            }(e2, t2, n2);
          case "tableCell":
            return nC(e2, t2, n2);
          case "break":
            return /\s/.test(t2.originalText[r2.position.start.offset]) ? FE(["  ", BE(wE)]) : FE(["\\", TE]);
          case "liquidNode":
            return FE(LE(r2.value, TE));
          case "importExport":
          case "jsx":
            return FE([r2.value, TE]);
          case "math":
            return FE(["$$", TE, r2.value ? FE([FE(LE(r2.value, TE)), TE]) : "", "$$"]);
          case "inlineMath":
            return t2.originalText.slice(t2.locStart(r2), t2.locEnd(r2));
          case "tableRow":
          case "listItem":
          default:
            throw new Error("Unknown markdown type ".concat(JSON.stringify(r2.type)));
        }
      }, embed: sE, massageAstNode: function(e2, t2, n2) {
        return delete t2.position, delete t2.raw, e2.type !== "front-matter" && e2.type !== "code" && e2.type !== "yaml" && e2.type !== "import" && e2.type !== "export" && e2.type !== "jsx" || delete t2.value, e2.type === "list" && delete t2.isAligned, e2.type !== "list" && e2.type !== "listItem" || (delete t2.spread, delete t2.loose), e2.type === "text" ? null : (e2.type === "inlineCode" && (t2.value = e2.value.replace(/[\t\n ]+/g, " ")), e2.type !== "definition" && e2.type !== "linkReference" || (t2.label = e2.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e2.type !== "definition" && e2.type !== "link" && e2.type !== "image" || !e2.title || (t2.title = e2.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e2 || RE(n2.children[0]) && n2.children[1] === e2) && e2.type === "html" && dE.startWithPragma(e2.value) ? null : void 0);
      }, hasPrettierIgnore: function(e2) {
        const t2 = +e2.getName();
        return t2 !== 0 && uC(e2.getParentNode().children[t2 - 1]) === "next";
      }, insertPragma: dE.insertPragma}, lC = {proseWrap: Bh.proseWrap, singleQuote: Bh.singleQuote}, cC = ["pandoc"], pC = [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".workbook"], dC = ["contents.lr"], fC = {name: "Markdown", type: "prose", aliases: cC, aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: pC, filenames: dC, tmScope: "source.gfm", languageId: 222}, hC = Ue(Object.freeze({__proto__: null, name: "Markdown", type: "prose", aliases: cC, aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: pC, filenames: dC, tmScope: "source.gfm", languageId: 222, default: fC}));
      var mC = {languages: [As(hC, (e2) => ({since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: e2.filenames.concat(["README"]), extensions: e2.extensions.filter((e3) => e3 !== ".mdx")})), As(hC, () => ({name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"]}))], options: lC, printers: {mdast: sC}, parsers: {get remark() {
        return {}.parsers.remark;
      }, get markdown() {
        return {}.parsers.remark;
      }, get mdx() {
        return {}.parsers.mdx;
      }}};
      const {isFrontMatterNode: gC} = Lt;
      var DC = Object.freeze({__proto__: null, default: ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]}), yC = ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], EC = ["title"], CC = ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], bC = ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], AC = ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], vC = ["href", "target"], FC = ["color", "face", "size"], xC = ["dir"], SC = ["cite"], wC = ["alink", "background", "bgcolor", "link", "text", "vlink"], BC = ["clear"], TC = ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], kC = ["height", "width"], NC = ["align"], OC = ["align", "char", "charoff", "span", "valign", "width"], PC = ["align", "char", "charoff", "span", "valign", "width"], _C = ["value"], IC = ["cite", "datetime"], jC = ["open"], MC = ["title"], LC = ["open"], RC = ["compact"], qC = ["align"], VC = ["compact"], WC = ["height", "src", "type", "width"], $C = ["disabled", "form", "name"], UC = ["color", "face", "size"], zC = ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], JC = ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], GC = ["cols", "rows"], HC = ["align"], XC = ["align"], YC = ["align"], KC = ["align"], QC = ["align"], ZC = ["align"], eb = ["profile"], tb = ["align", "noshade", "size", "width"], nb = ["manifest", "version"], rb = ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], ub = ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], ob = ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ab = ["cite", "datetime"], ib = ["prompt"], sb = ["accesskey", "for", "form"], lb = ["accesskey", "align"], cb2 = ["type", "value"], pb = ["as", "charset", "color", "crossorigin", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], db = ["name"], fb = ["compact"], hb = ["charset", "content", "http-equiv", "name", "scheme"], mb = ["high", "low", "max", "min", "optimum", "value"], gb = ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], Db = ["compact", "reversed", "start", "type"], yb = ["disabled", "label"], Eb = ["disabled", "label", "selected", "value"], Cb = ["for", "form", "name"], bb = ["align"], Ab = ["name", "type", "value", "valuetype"], vb = ["width"], Fb = ["max", "value"], xb = ["cite"], Sb = ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], wb = ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], Bb = ["name"], Tb = ["media", "sizes", "src", "srcset", "type"], kb = ["media", "nonce", "title", "type"], Nb = ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], Ob = ["align", "char", "charoff", "valign"], Pb = ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], _b = ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], Ib = ["align", "char", "charoff", "valign"], jb = ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], Mb = ["align", "char", "charoff", "valign"], Lb = ["datetime"], Rb = ["align", "bgcolor", "char", "charoff", "valign"], qb = ["default", "kind", "label", "src", "srclang"], Vb = ["compact", "type"], Wb = ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"], $b = {"*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: yC, abbr: EC, applet: CC, area: bC, audio: AC, base: vC, basefont: FC, bdo: xC, blockquote: SC, body: wC, br: BC, button: TC, canvas: kC, caption: NC, col: OC, colgroup: PC, data: _C, del: IC, details: jC, dfn: MC, dialog: LC, dir: RC, div: qC, dl: VC, embed: WC, fieldset: $C, font: UC, form: zC, frame: JC, frameset: GC, h1: HC, h2: XC, h3: YC, h4: KC, h5: QC, h6: ZC, head: eb, hr: tb, html: nb, iframe: rb, img: ub, input: ob, ins: ab, isindex: ib, label: sb, legend: lb, li: cb2, link: pb, map: db, menu: fb, meta: hb, meter: mb, object: gb, ol: Db, optgroup: yb, option: Eb, output: Cb, p: bb, param: Ab, pre: vb, progress: Fb, q: xb, script: Sb, select: wb, slot: Bb, source: Tb, style: kb, table: Nb, tbody: Ob, td: Pb, textarea: _b, tfoot: Ib, th: jb, thead: Mb, time: Lb, tr: Rb, track: qb, ul: Vb, video: Wb}, Ub = Object.freeze({__proto__: null, a: yC, abbr: EC, applet: CC, area: bC, audio: AC, base: vC, basefont: FC, bdo: xC, blockquote: SC, body: wC, br: BC, button: TC, canvas: kC, caption: NC, col: OC, colgroup: PC, data: _C, del: IC, details: jC, dfn: MC, dialog: LC, dir: RC, div: qC, dl: VC, embed: WC, fieldset: $C, font: UC, form: zC, frame: JC, frameset: GC, h1: HC, h2: XC, h3: YC, h4: KC, h5: QC, h6: ZC, head: eb, hr: tb, html: nb, iframe: rb, img: ub, input: ob, ins: ab, isindex: ib, label: sb, legend: lb, li: cb2, link: pb, map: db, menu: fb, meta: hb, meter: mb, object: gb, ol: Db, optgroup: yb, option: Eb, output: Cb, p: bb, param: Ab, pre: vb, progress: Fb, q: xb, script: Sb, select: wb, slot: Bb, source: Tb, style: kb, table: Nb, tbody: Ob, td: Pb, textarea: _b, tfoot: Ib, th: jb, thead: Mb, time: Lb, tr: Rb, track: qb, ul: Vb, video: Wb, default: $b}), zb = Ue(DC), Jb = Ue(Ub);
      const {getParserName: Gb, isFrontMatterNode: Hb} = Lt, {CSS_DISPLAY_TAGS: Xb, CSS_DISPLAY_DEFAULT: Yb, CSS_WHITE_SPACE_TAGS: Kb, CSS_WHITE_SPACE_DEFAULT: Qb} = {CSS_DISPLAY_TAGS: {area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block"}, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: {listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap"}, CSS_WHITE_SPACE_DEFAULT: "normal"}, Zb = uA(zb), eA = function(e2, t2) {
        const n2 = Object.create(null);
        for (const r2 of Object.keys(e2))
          n2[r2] = t2(e2[r2], r2);
        return n2;
      }(Jb, uA), tA = new Set(["	", "\n", "\f", "\r", " "]), nA = (e2) => e2.replace(/[\t\n\f\r ]+$/, ""), rA = (e2) => e2.match(/^[\t\n\f\r ]*/)[0];
      function uA(e2) {
        const t2 = Object.create(null);
        for (const n2 of e2)
          t2[n2] = true;
        return t2;
      }
      function oA(e2, t2) {
        return !(e2.type !== "ieConditionalComment" || !e2.lastChild || e2.lastChild.isSelfClosing || e2.lastChild.endSourceSpan) || (e2.type === "ieConditionalComment" && !e2.complete || (!(!DA(e2) || !e2.children.some((e3) => e3.type !== "text" && e3.type !== "interpolation")) || !(!vA(e2, t2) || iA(e2) || e2.type === "interpolation")));
      }
      function aA(e2) {
        if (e2.type === "attribute")
          return false;
        if (!e2.parent)
          return false;
        if (typeof e2.index != "number" || e2.index === 0)
          return false;
        return function(e3) {
          return e3.type === "comment" && e3.value.trim() === "prettier-ignore";
        }(e2.parent.children[e2.index - 1]);
      }
      function iA(e2) {
        return e2.type === "element" && (e2.fullName === "script" || e2.fullName === "style" || e2.fullName === "svg:style" || yA(e2) && (e2.name === "script" || e2.name === "style"));
      }
      function sA(e2) {
        return EA(e2).startsWith("pre");
      }
      function lA(e2) {
        return e2.type === "element" && e2.children.length !== 0 && (["html", "head", "ul", "ol", "select"].includes(e2.name) || e2.cssDisplay.startsWith("table") && e2.cssDisplay !== "table-cell");
      }
      function cA(e2) {
        return hA(e2) || e2.type === "element" && e2.fullName === "br" || pA(e2);
      }
      function pA(e2) {
        return dA(e2) && fA(e2);
      }
      function dA(e2) {
        return e2.hasLeadingSpaces && (e2.prev ? e2.prev.sourceSpan.end.line < e2.sourceSpan.start.line : e2.parent.type === "root" || e2.parent.startSourceSpan.end.line < e2.sourceSpan.start.line);
      }
      function fA(e2) {
        return e2.hasTrailingSpaces && (e2.next ? e2.next.sourceSpan.start.line > e2.sourceSpan.end.line : e2.parent.type === "root" || e2.parent.endSourceSpan && e2.parent.endSourceSpan.start.line > e2.sourceSpan.end.line);
      }
      function hA(e2) {
        switch (e2.type) {
          case "ieConditionalComment":
          case "comment":
          case "directive":
            return true;
          case "element":
            return ["script", "select"].includes(e2.name);
        }
        return false;
      }
      function mA(e2) {
        const {type: t2, lang: n2} = e2.attrMap;
        return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || n2 === "jsx" ? "babel" : t2 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
      }
      function gA(e2) {
        return e2 === "block" || e2 === "list-item" || e2.startsWith("table");
      }
      function DA(e2) {
        return EA(e2).startsWith("pre");
      }
      function yA(e2) {
        return e2.type === "element" && !e2.hasExplicitNamespace && !["html", "svg"].includes(e2.namespace);
      }
      function EA(e2) {
        return e2.type === "element" && (!e2.namespace || yA(e2)) && Kb[e2.name] || Qb;
      }
      const CA = new Set(["template", "style", "script"]);
      function bA(e2, t2) {
        return AA(e2, t2) && !CA.has(e2.fullName);
      }
      function AA(e2, t2) {
        return t2.parser === "vue" && e2.type === "element" && e2.parent.type === "root" && e2.fullName.toLowerCase() !== "html";
      }
      function vA(e2, t2) {
        return AA(e2, t2) && (bA(e2, t2) || e2.attrMap.lang && e2.attrMap.lang !== "html");
      }
      var FA = {HTML_ELEMENT_ATTRIBUTES: eA, HTML_TAGS: Zb, htmlTrim: (e2) => ((e3) => e3.replace(/^[\t\n\f\r ]+/, ""))(nA(e2)), htmlTrimPreserveIndentation: (e2) => ((e3) => e3.replace(/^[\t\f\r ]*?\n/g, ""))(nA(e2)), splitByHtmlWhitespace: (e2) => e2.split(/[\t\n\f\r ]+/), hasHtmlWhitespace: (e2) => /[\t\n\f\r ]/.test(e2), getLeadingAndTrailingHtmlWhitespace: (e2) => {
        const [, t2, n2, r2] = e2.match(/^([\t\n\f\r ]*)([\S\s]*?)([\t\n\f\r ]*)$/);
        return {leadingWhitespace: t2, trailingWhitespace: r2, text: n2};
      }, canHaveInterpolation: function(e2) {
        return e2.children && !iA(e2);
      }, countChars: function(e2, t2) {
        let n2 = 0;
        for (let r2 = 0; r2 < e2.length; r2++)
          e2[r2] === t2 && n2++;
        return n2;
      }, countParents: function(e2, t2) {
        let n2 = 0;
        for (let r2 = e2.stack.length - 1; r2 >= 0; r2--) {
          const u2 = e2.stack[r2];
          u2 && typeof u2 == "object" && !Array.isArray(u2) && t2(u2) && n2++;
        }
        return n2;
      }, dedentString: function(e2, t2 = function(e3) {
        let t3 = 1 / 0;
        for (const n2 of e3.split("\n")) {
          if (n2.length === 0)
            continue;
          if (!tA.has(n2[0]))
            return 0;
          const e4 = rA(n2).length;
          n2.length !== e4 && e4 < t3 && (t3 = e4);
        }
        return t3 === 1 / 0 ? 0 : t3;
      }(e2)) {
        return t2 === 0 ? e2 : e2.split("\n").map((e3) => e3.slice(t2)).join("\n");
      }, forceBreakChildren: lA, forceBreakContent: function(e2) {
        return lA(e2) || e2.type === "element" && e2.children.length !== 0 && (["body", "script", "style"].includes(e2.name) || e2.children.some((e3) => function(e4) {
          return e4.children && e4.children.some((e5) => e5.type !== "text");
        }(e3))) || e2.firstChild && e2.firstChild === e2.lastChild && e2.firstChild.type !== "text" && dA(e2.firstChild) && (!e2.lastChild.isTrailingSpaceSensitive || fA(e2.lastChild));
      }, forceNextEmptyLine: function(e2) {
        return Hb(e2) || e2.next && e2.sourceSpan.end && e2.sourceSpan.end.line + 1 < e2.next.sourceSpan.start.line;
      }, getLastDescendant: function e2(t2) {
        return t2.lastChild ? e2(t2.lastChild) : t2;
      }, getNodeCssStyleDisplay: function(e2, t2) {
        if (e2.prev && e2.prev.type === "comment") {
          const t3 = e2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
          if (t3)
            return t3[1];
        }
        let n2 = false;
        if (e2.type === "element" && e2.namespace === "svg") {
          if (!function(e3, t3) {
            let n3 = e3;
            for (; n3; ) {
              if (t3(n3))
                return true;
              n3 = n3.parent;
            }
            return false;
          }(e2, (e3) => e3.fullName === "svg:foreignObject"))
            return e2.name === "svg" ? "inline-block" : "block";
          n2 = true;
        }
        switch (t2.htmlWhitespaceSensitivity) {
          case "strict":
            return "inline";
          case "ignore":
            return "block";
          default:
            return t2.parser === "vue" && e2.parent && e2.parent.type === "root" ? "block" : e2.type === "element" && (!e2.namespace || n2 || yA(e2)) && Xb[e2.name] || Yb;
        }
      }, getNodeCssStyleWhiteSpace: EA, getPrettierIgnoreAttributeCommentData: function(e2) {
        const t2 = e2.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);
        return !!t2 && (!t2[1] || t2[1].split(/\s+/));
      }, hasPrettierIgnore: aA, inferScriptParser: function(e2, t2) {
        return e2.name !== "script" || e2.attrMap.src ? e2.name === "style" ? function(e3) {
          const {lang: t3} = e3.attrMap;
          return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
        }(e2) : t2 && vA(e2, t2) ? mA(e2) || !("src" in e2.attrMap) && Gb(e2.attrMap.lang, t2) : void 0 : e2.attrMap.lang || e2.attrMap.type ? mA(e2) : "babel";
      }, isVueCustomBlock: bA, isVueNonHtmlBlock: vA, isDanglingSpaceSensitiveNode: function(e2) {
        return !(t2 = e2.cssDisplay, gA(t2) || t2 === "inline-block" || iA(e2));
        var t2;
      }, isIndentationSensitiveNode: sA, isLeadingSpaceSensitiveNode: function(e2, t2) {
        const n2 = function() {
          if (Hb(e2))
            return false;
          if ((e2.type === "text" || e2.type === "interpolation") && e2.prev && (e2.prev.type === "text" || e2.prev.type === "interpolation"))
            return true;
          if (!e2.parent || e2.parent.cssDisplay === "none")
            return false;
          if (DA(e2.parent))
            return true;
          if (!e2.prev && (e2.parent.type === "root" || DA(e2) && e2.parent || iA(e2.parent) || bA(e2.parent, t2) || (n3 = e2.parent.cssDisplay, gA(n3) || n3 === "inline-block")))
            return false;
          var n3;
          if (e2.prev && !function(e3) {
            return !gA(e3);
          }(e2.prev.cssDisplay))
            return false;
          return true;
        }();
        return n2 && !e2.prev && e2.parent && e2.parent.tagDefinition && e2.parent.tagDefinition.ignoreFirstLf ? e2.type === "interpolation" : n2;
      }, isPreLikeNode: DA, isScriptLikeTag: iA, isTextLikeNode: function(e2) {
        return e2.type === "text" || e2.type === "comment";
      }, isTrailingSpaceSensitiveNode: function(e2, t2) {
        return !Hb(e2) && (!(e2.type !== "text" && e2.type !== "interpolation" || !e2.next || e2.next.type !== "text" && e2.next.type !== "interpolation") || !(!e2.parent || e2.parent.cssDisplay === "none") && (!!DA(e2.parent) || !(!e2.next && (e2.parent.type === "root" || DA(e2) && e2.parent || iA(e2.parent) || bA(e2.parent, t2) || (n2 = e2.parent.cssDisplay, gA(n2) || n2 === "inline-block"))) && !(e2.next && !function(e3) {
          return !gA(e3);
        }(e2.next.cssDisplay))));
        var n2;
      }, isWhitespaceSensitiveNode: function(e2) {
        return iA(e2) || e2.type === "interpolation" || sA(e2);
      }, isUnknownNamespace: yA, preferHardlineAsLeadingSpaces: function(e2) {
        return hA(e2) || e2.prev && cA(e2.prev) || pA(e2);
      }, preferHardlineAsTrailingSpaces: cA, shouldNotPrintClosingTag: function(e2, t2) {
        return !e2.isSelfClosing && !e2.endSourceSpan && (aA(e2) || oA(e2.parent, t2));
      }, shouldPreserveContent: oA, unescapeQuoteEntities: function(e2) {
        return e2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
      }};
      const {htmlTrim: xA, getLeadingAndTrailingHtmlWhitespace: SA, hasHtmlWhitespace: wA, canHaveInterpolation: BA, getNodeCssStyleDisplay: TA, isDanglingSpaceSensitiveNode: kA, isIndentationSensitiveNode: NA, isLeadingSpaceSensitiveNode: OA, isTrailingSpaceSensitiveNode: PA, isWhitespaceSensitiveNode: _A} = FA, IA = [function(e2) {
        return e2.map((e3) => {
          if (e3.type === "element" && e3.tagDefinition.ignoreFirstLf && e3.children.length !== 0 && e3.children[0].type === "text" && e3.children[0].value[0] === "\n") {
            const [t2, ...n2] = e3.children;
            return e3.clone({children: t2.value.length === 1 ? n2 : [t2.clone({value: t2.value.slice(1)}), ...n2]});
          }
          return e3;
        });
      }, function(e2) {
        const t2 = (e3) => e3.type === "element" && e3.prev && e3.prev.type === "ieConditionalStartComment" && e3.prev.sourceSpan.end.offset === e3.startSourceSpan.start.offset && e3.firstChild && e3.firstChild.type === "ieConditionalEndComment" && e3.firstChild.sourceSpan.start.offset === e3.startSourceSpan.end.offset;
        return e2.map((e3) => {
          if (e3.children) {
            const n2 = e3.children.map(t2);
            if (n2.some(Boolean)) {
              const t3 = [];
              for (let r2 = 0; r2 < e3.children.length; r2++) {
                const u2 = e3.children[r2];
                if (!n2[r2 + 1])
                  if (n2[r2]) {
                    const e4 = u2.prev, n3 = u2.firstChild, r3 = u2.sourceSpan.constructor, o2 = new r3(e4.sourceSpan.start, n3.sourceSpan.end), a2 = new r3(o2.start, u2.sourceSpan.end);
                    t3.push(u2.clone({condition: e4.condition, sourceSpan: a2, startSourceSpan: o2, children: u2.children.slice(1)}));
                  } else
                    t3.push(u2);
              }
              return e3.clone({children: t3});
            }
          }
          return e3;
        });
      }, function(e2) {
        return function(e3, t2, n2) {
          return e3.map((e4) => {
            if (e4.children) {
              const r2 = e4.children.map(t2);
              if (r2.some(Boolean)) {
                const t3 = [];
                for (let u2 = 0; u2 < e4.children.length; u2++) {
                  const o2 = e4.children[u2];
                  if (o2.type !== "text" && !r2[u2]) {
                    t3.push(o2);
                    continue;
                  }
                  const a2 = o2.type === "text" ? o2 : o2.clone({type: "text", value: n2(o2)});
                  if (t3.length === 0 || t3[t3.length - 1].type !== "text") {
                    t3.push(a2);
                    continue;
                  }
                  const i2 = t3.pop(), s2 = i2.sourceSpan.constructor;
                  t3.push(i2.clone({value: i2.value + a2.value, sourceSpan: new s2(i2.sourceSpan.start, a2.sourceSpan.end)}));
                }
                return e4.clone({children: t3});
              }
            }
            return e4;
          });
        }(e2, (e3) => e3.type === "cdata", (e3) => "<![CDATA[".concat(e3.value, "]]>"));
      }, function(e2, t2) {
        if (t2.parser === "html")
          return e2;
        const n2 = /{{([\S\s]+?)}}/g;
        return e2.map((e3) => {
          if (!BA(e3))
            return e3;
          const t3 = [];
          for (const r2 of e3.children) {
            if (r2.type !== "text") {
              t3.push(r2);
              continue;
            }
            const e4 = r2.sourceSpan.constructor;
            let u2 = r2.sourceSpan.start, o2 = null;
            const a2 = r2.value.split(n2);
            for (let n3 = 0; n3 < a2.length; n3++, u2 = o2) {
              const r3 = a2[n3];
              n3 % 2 != 0 ? (o2 = u2.moveBy(r3.length + 4), t3.push({type: "interpolation", sourceSpan: new e4(u2, o2), children: r3.length === 0 ? [] : [{type: "text", value: r3, sourceSpan: new e4(u2.moveBy(2), o2.moveBy(-2))}]})) : (o2 = u2.moveBy(r3.length), r3.length !== 0 && t3.push({type: "text", value: r3, sourceSpan: new e4(u2, o2)}));
            }
          }
          return e3.clone({children: t3});
        });
      }, function(e2) {
        return e2.map((e3) => {
          if (!e3.children)
            return e3;
          if (e3.children.length === 0 || e3.children.length === 1 && e3.children[0].type === "text" && xA(e3.children[0].value).length === 0)
            return e3.clone({children: [], hasDanglingSpaces: e3.children.length !== 0});
          const t2 = _A(e3), n2 = NA(e3);
          return e3.clone({isWhitespaceSensitive: t2, isIndentationSensitive: n2, children: e3.children.reduce((e4, n3) => {
            if (n3.type !== "text" || t2)
              return e4.concat(n3);
            const r2 = [], {leadingWhitespace: u2, text: o2, trailingWhitespace: a2} = SA(n3.value);
            u2 && r2.push({type: "whitespace"});
            const i2 = n3.sourceSpan.constructor;
            return o2 && r2.push({type: "text", value: o2, sourceSpan: new i2(n3.sourceSpan.start.moveBy(u2.length), n3.sourceSpan.end.moveBy(-a2.length))}), a2 && r2.push({type: "whitespace"}), e4.concat(r2);
          }, []).reduce((e4, t3, n3, r2) => {
            if (t3.type === "whitespace")
              return e4;
            const u2 = n3 !== 0 && r2[n3 - 1].type === "whitespace", o2 = n3 !== r2.length - 1 && r2[n3 + 1].type === "whitespace";
            return e4.concat(Object.assign({}, t3, {hasLeadingSpaces: u2, hasTrailingSpaces: o2}));
          }, [])});
        });
      }, function(e2, t2) {
        return e2.map((e3) => Object.assign(e3, {cssDisplay: TA(e3, t2)}));
      }, function(e2) {
        return e2.map((e3) => Object.assign(e3, {isSelfClosing: !e3.children || e3.type === "element" && (e3.tagDefinition.isVoid || e3.startSourceSpan === e3.endSourceSpan)}));
      }, function(e2, t2) {
        return e2.map((e3) => e3.type !== "element" ? e3 : Object.assign(e3, {hasHtmComponentClosingTag: e3.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t2.originalText.slice(e3.endSourceSpan.start.offset, e3.endSourceSpan.end.offset))}));
      }, function(e2, t2) {
        return e2.map((e3) => e3.children ? e3.children.length === 0 ? e3.clone({isDanglingSpaceSensitive: kA(e3)}) : e3.clone({children: e3.children.map((e4) => Object.assign({}, e4, {isLeadingSpaceSensitive: OA(e4, t2), isTrailingSpaceSensitive: PA(e4, t2)})).map((e4, t3, n2) => Object.assign({}, e4, {isLeadingSpaceSensitive: (t3 === 0 || n2[t3 - 1].isTrailingSpaceSensitive) && e4.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t3 === n2.length - 1 || n2[t3 + 1].isLeadingSpaceSensitive) && e4.isTrailingSpaceSensitive}))}) : e3);
      }, function(e2) {
        const t2 = (e3) => e3.type === "element" && e3.attrs.length === 0 && e3.children.length === 1 && e3.firstChild.type === "text" && !wA(e3.children[0].value) && !e3.firstChild.hasLeadingSpaces && !e3.firstChild.hasTrailingSpaces && e3.isLeadingSpaceSensitive && !e3.hasLeadingSpaces && e3.isTrailingSpaceSensitive && !e3.hasTrailingSpaces && e3.prev && e3.prev.type === "text" && e3.next && e3.next.type === "text";
        return e2.map((e3) => {
          if (e3.children) {
            const n2 = e3.children.map(t2);
            if (n2.some(Boolean)) {
              const t3 = [];
              for (let r2 = 0; r2 < e3.children.length; r2++) {
                const u2 = e3.children[r2];
                if (n2[r2]) {
                  const n3 = t3.pop(), o2 = e3.children[++r2], a2 = e3.sourceSpan.constructor, {isTrailingSpaceSensitive: i2, hasTrailingSpaces: s2} = o2;
                  t3.push(n3.clone({value: n3.value + "<".concat(u2.rawName, ">") + u2.firstChild.value + "</".concat(u2.rawName, ">") + o2.value, sourceSpan: new a2(n3.sourceSpan.start, o2.sourceSpan.end), isTrailingSpaceSensitive: i2, hasTrailingSpaces: s2}));
                } else
                  t3.push(u2);
              }
              return e3.clone({children: t3});
            }
          }
          return e3;
        });
      }];
      var jA = function(e2, t2) {
        for (const n2 of IA)
          e2 = n2(e2, t2);
        return e2;
      };
      var MA = {hasPragma: function(e2) {
        return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e2);
      }, insertPragma: function(e2) {
        return "<!-- @format -->\n\n" + e2.replace(/^\s*\n/, "");
      }};
      const {builders: {concat: LA, group: RA}} = dn;
      var qA = {isVueEventBindingExpression: function(e2) {
        const t2 = e2.trim();
        return /^([\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t2) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t2);
      }, printVueFor: function(e2, t2) {
        const {left: n2, operator: r2, right: u2} = function(e3) {
          const t3 = /([^]*?)\s+(in|of)\s+([^]*)/, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, u3 = e3.match(t3);
          if (!u3)
            return;
          const o2 = {};
          o2.for = u3[3].trim();
          const a2 = u3[1].trim().replace(r3, ""), i2 = a2.match(n3);
          i2 ? (o2.alias = a2.replace(n3, ""), o2.iterator1 = i2[1].trim(), i2[2] && (o2.iterator2 = i2[2].trim())) : o2.alias = a2;
          return {left: "".concat([o2.alias, o2.iterator1, o2.iterator2].filter(Boolean).join(",")), operator: u3[2], right: o2.for};
        }(e2);
        return LA([RA(t2("function _(".concat(n2, ") {}"), {parser: "babel", __isVueForBindingLeft: true})), " ", r2, " ", t2(u2, {parser: "__js_expression"}, {stripTrailingHardline: true})]);
      }, printVueSlotScope: function(e2, t2) {
        return t2("function _(".concat(e2, ") {}"), {parser: "babel", __isVueSlotScope: true}, {stripTrailingHardline: true});
      }}, VA = $e(function(e2) {
        !function(t2, n2) {
          e2.exports ? e2.exports = n2() : t2.parseSrcset = n2();
        }(We, function() {
          return function(e3, t2) {
            var n2 = t2 && t2.logger || console;
            function r2(e4) {
              return e4 === " " || e4 === "	" || e4 === "\n" || e4 === "\f" || e4 === "\r";
            }
            function u2(t3) {
              var n3, r3 = t3.exec(e3.substring(D2));
              if (r3)
                return n3 = r3[0], D2 += n3.length, n3;
            }
            for (var o2, a2, i2, s2, l2, c2 = e3.length, p2 = /^[ \t\n\r\u000c]+/, d2 = /^[, \t\n\r\u000c]+/, f2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, m2 = /^\d+$/, g2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, D2 = 0, y2 = []; ; ) {
              if (u2(d2), D2 >= c2)
                return y2;
              o2 = u2(f2), a2 = [], o2.slice(-1) === "," ? (o2 = o2.replace(h2, ""), C2()) : E2();
            }
            function E2() {
              for (u2(p2), i2 = "", s2 = "in descriptor"; ; ) {
                if (l2 = e3.charAt(D2), s2 === "in descriptor")
                  if (r2(l2))
                    i2 && (a2.push(i2), i2 = "", s2 = "after descriptor");
                  else {
                    if (l2 === ",")
                      return D2 += 1, i2 && a2.push(i2), void C2();
                    if (l2 === "(")
                      i2 += l2, s2 = "in parens";
                    else {
                      if (l2 === "")
                        return i2 && a2.push(i2), void C2();
                      i2 += l2;
                    }
                  }
                else if (s2 === "in parens")
                  if (l2 === ")")
                    i2 += l2, s2 = "in descriptor";
                  else {
                    if (l2 === "")
                      return a2.push(i2), void C2();
                    i2 += l2;
                  }
                else if (s2 === "after descriptor")
                  if (r2(l2))
                    ;
                  else {
                    if (l2 === "")
                      return void C2();
                    s2 = "in descriptor", D2 -= 1;
                  }
                D2 += 1;
              }
            }
            function C2() {
              var t3, r3, u3, i3, s3, l3, c3, p3, d3, f3 = false, h3 = {};
              for (i3 = 0; i3 < a2.length; i3++)
                l3 = (s3 = a2[i3])[s3.length - 1], c3 = s3.substring(0, s3.length - 1), p3 = parseInt(c3, 10), d3 = parseFloat(c3), m2.test(c3) && l3 === "w" ? ((t3 || r3) && (f3 = true), p3 === 0 ? f3 = true : t3 = p3) : g2.test(c3) && l3 === "x" ? ((t3 || r3 || u3) && (f3 = true), d3 < 0 ? f3 = true : r3 = d3) : m2.test(c3) && l3 === "h" ? ((u3 || r3) && (f3 = true), p3 === 0 ? f3 = true : u3 = p3) : f3 = true;
              f3 ? n2 && n2.error && n2.error("Invalid srcset descriptor found in '" + e3 + "' at '" + s3 + "'.") : (h3.url = o2, t3 && (h3.w = t3), r3 && (h3.d = r3), u3 && (h3.h = u3), y2.push(h3));
            }
          };
        });
      });
      const {builders: {concat: WA, ifBreak: $A, join: UA, line: zA}} = dn;
      var JA = {printImgSrcset: function(e2) {
        const t2 = VA(e2, {logger: {error(e3) {
          throw new Error(e3);
        }}}), n2 = t2.some(({w: e3}) => e3), r2 = t2.some(({h: e3}) => e3);
        if (n2 + r2 + t2.some(({d: e3}) => e3) > 1)
          throw new Error("Mixed descriptor in srcset is not supported");
        const u2 = n2 ? "w" : r2 ? "h" : "d", o2 = n2 ? "w" : r2 ? "h" : "x", a2 = (e3) => Math.max(...e3), i2 = t2.map((e3) => e3.url), s2 = a2(i2.map((e3) => e3.length)), l2 = t2.map((e3) => e3[u2]).map((e3) => e3 ? e3.toString() : ""), c2 = l2.map((e3) => {
          const t3 = e3.indexOf(".");
          return t3 === -1 ? e3.length : t3;
        }), p2 = a2(c2);
        return UA(WA([",", zA]), i2.map((e3, t3) => {
          const n3 = [e3], r3 = l2[t3];
          if (r3) {
            const u3 = s2 - e3.length + 1, a3 = p2 - c2[t3], i3 = " ".repeat(u3 + a3);
            n3.push($A(i3, " "), r3 + o2);
          }
          return WA(n3);
        }));
      }, printClassNames: function(e2) {
        return e2.trim().split(/\s+/).join(" ");
      }};
      const {builders: GA, utils: {mapDoc: HA, normalizeParts: XA}} = dn, {replaceEndOfLineWith: YA} = Lt, {print: KA} = Em, {breakParent: QA, dedentToRoot: ZA, fill: ev, group: tv, hardline: nv, ifBreak: rv, indent: uv, join: ov, line: av, literalline: iv, softline: sv} = GA, {htmlTrimPreserveIndentation: lv, splitByHtmlWhitespace: cv, countChars: pv, countParents: dv, dedentString: fv, forceBreakChildren: hv, forceBreakContent: mv, forceNextEmptyLine: gv, getLastDescendant: Dv, getPrettierIgnoreAttributeCommentData: yv, hasPrettierIgnore: Ev, inferScriptParser: Cv, isVueCustomBlock: bv, isVueNonHtmlBlock: Av, isScriptLikeTag: vv, isTextLikeNode: Fv, preferHardlineAsLeadingSpaces: xv, shouldNotPrintClosingTag: Sv, shouldPreserveContent: wv, unescapeQuoteEntities: Bv, isPreLikeNode: Tv} = FA, {insertPragma: kv} = MA, {printVueFor: Nv, printVueSlotScope: Ov, isVueEventBindingExpression: Pv} = qA, {printImgSrcset: _v, printClassNames: Iv} = JA;
      function jv(e2) {
        const t2 = XA(e2);
        return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : GA.concat(t2);
      }
      function Mv(e2, t2, n2) {
        const r2 = e2.getValue();
        if (hv(r2))
          return jv([QA, jv(e2.map((e3) => {
            const t3 = e3.getValue(), n3 = t3.prev ? a2(t3.prev, t3) : "";
            return jv([n3 ? jv([n3, gv(t3.prev) ? nv : ""]) : "", o2(e3)]);
          }, "children"))]);
        const u2 = r2.children.map(() => Symbol(""));
        return jv(e2.map((e3, t3) => {
          const n3 = e3.getValue();
          if (Fv(n3)) {
            if (n3.prev && Fv(n3.prev)) {
              const t4 = a2(n3.prev, n3);
              if (t4)
                return gv(n3.prev) ? jv([nv, nv, o2(e3)]) : jv([t4, o2(e3)]);
            }
            return o2(e3);
          }
          const r3 = [], i2 = [], s2 = [], l2 = [], c2 = n3.prev ? a2(n3.prev, n3) : "", p2 = n3.next ? a2(n3, n3.next) : "";
          return c2 && (gv(n3.prev) ? r3.push(nv, nv) : c2 === nv ? r3.push(nv) : Fv(n3.prev) ? i2.push(c2) : i2.push(rv("", sv, {groupId: u2[t3 - 1]}))), p2 && (gv(n3) ? Fv(n3.next) && l2.push(nv, nv) : p2 === nv ? Fv(n3.next) && l2.push(nv) : s2.push(p2)), jv([].concat(r3, tv(jv([jv(i2), tv(jv([o2(e3), jv(s2)]), {id: u2[t3]})])), l2));
        }, "children"));
        function o2(e3) {
          const r3 = e3.getValue();
          return Ev(r3) ? jv([].concat(Kv(r3, t2), YA(t2.originalText.slice(t2.locStart(r3) + (r3.prev && Jv(r3.prev) ? eF(r3).length : 0), t2.locEnd(r3) - (r3.next && Hv(r3.next) ? rF(r3, t2).length : 0)), iv), Zv(r3, t2))) : n2(e3);
        }
        function a2(e3, t3) {
          return Fv(e3) && Fv(t3) ? e3.isTrailingSpaceSensitive ? e3.hasTrailingSpaces ? xv(t3) ? nv : av : "" : xv(t3) ? nv : sv : Jv(e3) && (Ev(t3) || t3.firstChild || t3.isSelfClosing || t3.type === "element" && t3.attrs.length !== 0) || e3.type === "element" && e3.isSelfClosing && Hv(t3) ? "" : !t3.isLeadingSpaceSensitive || xv(t3) || Hv(t3) && e3.lastChild && Yv(e3.lastChild) && e3.lastChild.lastChild && Yv(e3.lastChild.lastChild) ? nv : t3.hasLeadingSpaces ? av : sv;
        }
      }
      function Lv(e2, t2) {
        let n2 = e2.startSourceSpan.end.offset;
        e2.firstChild && Gv(e2.firstChild) && (n2 -= tF(e2).length);
        let r2 = e2.endSourceSpan.start.offset;
        return e2.lastChild && Yv(e2.lastChild) ? r2 += nF(e2, t2).length : Xv(e2) && (r2 -= rF(e2.lastChild, t2).length), t2.originalText.slice(n2, r2);
      }
      function Rv(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2.attrs || r2.attrs.length === 0)
          return r2.isSelfClosing ? " " : "";
        const u2 = r2.prev && r2.prev.type === "comment" && yv(r2.prev.value), o2 = typeof u2 == "boolean" ? () => u2 : Array.isArray(u2) ? (e3) => u2.includes(e3.rawName) : () => false, a2 = e2.map((e3) => {
          const r3 = e3.getValue();
          return o2(r3) ? jv(YA(t2.originalText.slice(t2.locStart(r3), t2.locEnd(r3)), iv)) : n2(e3);
        }, "attrs"), i2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, s2 = [uv(jv([i2 ? " " : av, ov(av, a2)]))];
        return r2.firstChild && Gv(r2.firstChild) || r2.isSelfClosing && Xv(r2.parent) || i2 ? s2.push(r2.isSelfClosing ? " " : "") : s2.push(r2.isSelfClosing ? av : sv), jv(s2);
      }
      function qv(e2, t2, n2) {
        const r2 = e2.getValue();
        return jv([Vv(r2, t2), Rv(e2, t2, n2), r2.isSelfClosing ? "" : Wv(r2)]);
      }
      function Vv(e2, t2) {
        return e2.prev && Jv(e2.prev) ? "" : jv([Kv(e2, t2), eF(e2)]);
      }
      function Wv(e2) {
        return e2.firstChild && Gv(e2.firstChild) ? "" : tF(e2);
      }
      function $v(e2, t2) {
        return jv([e2.isSelfClosing ? "" : Uv(e2, t2), zv(e2, t2)]);
      }
      function Uv(e2, t2) {
        return e2.lastChild && Yv(e2.lastChild) ? "" : jv([Qv(e2, t2), nF(e2, t2)]);
      }
      function zv(e2, t2) {
        return (e2.next ? Hv(e2.next) : Xv(e2.parent)) ? "" : jv([rF(e2, t2), Zv(e2, t2)]);
      }
      function Jv(e2) {
        return e2.next && !Fv(e2.next) && Fv(e2) && e2.isTrailingSpaceSensitive && !e2.hasTrailingSpaces;
      }
      function Gv(e2) {
        return !e2.prev && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
      }
      function Hv(e2) {
        return e2.prev && e2.prev.type !== "docType" && !Fv(e2.prev) && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
      }
      function Xv(e2) {
        return e2.lastChild && e2.lastChild.isTrailingSpaceSensitive && !e2.lastChild.hasTrailingSpaces && !Fv(Dv(e2.lastChild)) && !Tv(e2);
      }
      function Yv(e2) {
        return !e2.next && !e2.hasTrailingSpaces && e2.isTrailingSpaceSensitive && Fv(Dv(e2));
      }
      function Kv(e2, t2) {
        return Gv(e2) ? tF(e2.parent) : Hv(e2) ? rF(e2.prev, t2) : "";
      }
      function Qv(e2, t2) {
        return Xv(e2) ? rF(e2.lastChild, t2) : "";
      }
      function Zv(e2, t2) {
        return Yv(e2) ? nF(e2.parent, t2) : Jv(e2) ? eF(e2.next) : "";
      }
      function eF(e2) {
        switch (e2.type) {
          case "ieConditionalComment":
          case "ieConditionalStartComment":
            return "<!--[if ".concat(e2.condition);
          case "ieConditionalEndComment":
            return "<!--<!";
          case "interpolation":
            return "{{";
          case "docType":
            return "<!DOCTYPE";
          case "element":
            if (e2.condition)
              return "<!--[if ".concat(e2.condition, "]><!--><").concat(e2.rawName);
          default:
            return "<".concat(e2.rawName);
        }
      }
      function tF(e2) {
        switch (e2.isSelfClosing, e2.type) {
          case "ieConditionalComment":
            return "]>";
          case "element":
            if (e2.condition)
              return "><!--<![endif]-->";
          default:
            return ">";
        }
      }
      function nF(e2, t2) {
        if (e2.isSelfClosing, Sv(e2, t2))
          return "";
        switch (e2.type) {
          case "ieConditionalComment":
            return "<!";
          case "element":
            if (e2.hasHtmComponentClosingTag)
              return "<//";
          default:
            return "</".concat(e2.rawName);
        }
      }
      function rF(e2, t2) {
        if (Sv(e2, t2))
          return "";
        switch (e2.type) {
          case "ieConditionalComment":
          case "ieConditionalEndComment":
            return "[endif]-->";
          case "ieConditionalStartComment":
            return "]><!-->";
          case "interpolation":
            return "}}";
          case "element":
            if (e2.isSelfClosing)
              return "/>";
          default:
            return ">";
        }
      }
      function uF(e2, t2 = e2.value) {
        return e2.parent.isWhitespaceSensitive ? e2.parent.isIndentationSensitive ? YA(t2, iv) : YA(fv(lv(t2)), nv) : ov(av, cv(t2)).parts;
      }
      var oF = {preprocess: jA, print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        switch (r2.type) {
          case "front-matter":
            return jv(YA(r2.raw, iv));
          case "root":
            return t2.__onHtmlRoot && t2.__onHtmlRoot(r2), GA.concat([tv(Mv(e2, t2, n2)), nv]);
          case "element":
          case "ieConditionalComment": {
            if (wv(r2, t2))
              return jv([].concat(Kv(r2, t2), tv(qv(e2, t2, n2)), YA(Lv(r2, t2), iv), $v(r2, t2), Zv(r2, t2)));
            const o2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, a2 = Symbol("element-attr-group-id");
            return jv([tv(jv([tv(qv(e2, t2, n2), {id: a2}), r2.children.length === 0 ? r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? av : "" : jv([mv(r2) ? QA : "", (u2 = jv([o2 ? rv(sv, "", {groupId: a2}) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? av : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? ZA(sv) : sv, Mv(e2, t2, n2)]), o2 ? rv(uv(u2), u2, {groupId: a2}) : !vv(r2) && !bv(r2, t2) || r2.parent.type !== "root" || t2.parser !== "vue" || t2.vueIndentScriptAndStyle ? uv(u2) : u2), (r2.next ? Hv(r2.next) : Xv(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : o2 ? rv(sv, "", {groupId: a2}) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? av : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(t2.tabWidth * dv(e2, (e3) => e3.parent && e3.parent.type !== "root"), "}$")).test(r2.lastChild.value) ? "" : sv])])), $v(r2, t2)]);
          }
          case "ieConditionalStartComment":
          case "ieConditionalEndComment":
            return jv([Vv(r2), zv(r2)]);
          case "interpolation":
            return jv([Vv(r2, t2), jv(e2.map(n2, "children")), zv(r2, t2)]);
          case "text":
            if (r2.parent.type === "interpolation") {
              const e3 = /\n[^\S\n]*?$/, t3 = e3.test(r2.value), n3 = t3 ? r2.value.replace(e3, "") : r2.value;
              return jv([jv(YA(n3, iv)), t3 ? nv : ""]);
            }
            return ev(XA([].concat(Kv(r2, t2), uF(r2), Zv(r2, t2))));
          case "docType":
            return jv([tv(jv([Vv(r2, t2), " ", r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")])), zv(r2, t2)]);
          case "comment":
            return jv([Kv(r2, t2), jv(YA(t2.originalText.slice(t2.locStart(r2), t2.locEnd(r2)), iv)), Zv(r2, t2)]);
          case "attribute": {
            if (r2.value === null)
              return r2.rawName;
            const e3 = Bv(r2.value), t3 = pv(e3, "'") < pv(e3, '"') ? "'" : '"';
            return jv([r2.rawName, jv(["=", t3, jv(YA(t3 === '"' ? e3.replace(/"/g, "&quot;") : e3.replace(/'/g, "&apos;"), iv)), t3])]);
          }
          default:
            throw new Error("Unexpected node type ".concat(r2.type));
        }
        var u2;
      }, insertPragma: kv, massageAstNode: function(e2, t2) {
        return delete t2.sourceSpan, delete t2.startSourceSpan, delete t2.endSourceSpan, delete t2.nameSpan, delete t2.valueSpan, e2.type === "text" || e2.type === "comment" || gC(e2) || e2.type === "yaml" || e2.type === "toml" ? null : (e2.type === "attribute" && delete t2.value, void (e2.type === "docType" && delete t2.value));
      }, embed: function(e2, t2, n2, r2) {
        const u2 = e2.getValue();
        switch (u2.type) {
          case "element":
            if (vv(u2) || u2.type === "interpolation")
              return;
            if (!u2.isSelfClosing && Av(u2, r2)) {
              const o2 = Cv(u2, r2);
              if (!o2)
                return;
              const a2 = Lv(u2, r2);
              let i2 = /^\s*$/.test(a2), s2 = "";
              return i2 || (s2 = n2(lv(a2), {parser: o2}, {stripTrailingHardline: true}), i2 = s2 === ""), jv([Kv(u2, r2), tv(qv(e2, r2, t2)), i2 ? "" : nv, s2, i2 ? "" : nv, $v(u2, r2), Zv(u2, r2)]);
            }
            break;
          case "text":
            if (vv(u2.parent)) {
              const e3 = Cv(u2.parent);
              if (e3) {
                const t3 = e3 === "markdown" ? fv(u2.value.replace(/^[^\S\n]*?\n/, "")) : u2.value, o2 = {parser: e3};
                if (r2.parser === "html" && e3 === "babel") {
                  let e4 = "script";
                  const {attrMap: t4} = u2.parent;
                  t4 && (t4.type === "module" || t4.type === "text/babel" && t4["data-type"] === "module") && (e4 = "module"), o2.__babelSourceType = e4;
                }
                return GA.concat([jv([QA, Kv(u2, r2), n2(t3, o2, {stripTrailingHardline: true}), Zv(u2, r2)])]);
              }
            } else if (u2.parent.type === "interpolation")
              return jv([uv(jv([av, n2(u2.value, Object.assign({__isInHtmlInterpolation: true}, r2.parser === "angular" ? {parser: "__ng_interpolation", trailingComma: "none"} : r2.parser === "vue" ? {parser: "__vue_expression"} : {parser: "__js_expression"}), {stripTrailingHardline: true})])), u2.parent.next && Hv(u2.parent.next) ? " " : av]);
            break;
          case "attribute": {
            if (!u2.value)
              break;
            if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(u2.valueSpan.start.offset, u2.valueSpan.end.offset)))
              return jv([u2.rawName, "=", u2.value]);
            if (r2.parser === "lwc") {
              if (/^{[\S\s]*}$/.test(r2.originalText.slice(u2.valueSpan.start.offset, u2.valueSpan.end.offset)))
                return jv([u2.rawName, "=", u2.value]);
            }
            const e3 = function(e4, t3, n3) {
              const r3 = (t4) => new RegExp(t4.join("|")).test(e4.fullName), u3 = () => Bv(e4.value);
              let o2 = false;
              const a2 = (e5, t4) => {
                const n4 = e5.type === "NGRoot" ? e5.node.type === "NGMicrosyntax" && e5.node.body.length === 1 && e5.node.body[0].type === "NGMicrosyntaxExpression" ? e5.node.body[0].expression : e5.node : e5.type === "JsExpressionRoot" ? e5.node : e5;
                !n4 || n4.type !== "ObjectExpression" && n4.type !== "ArrayExpression" && (t4.parser !== "__vue_expression" || n4.type !== "TemplateLiteral" && n4.type !== "StringLiteral") || (o2 = true);
              }, i2 = (e5) => tv(e5), s2 = (e5, t4 = true) => tv(jv([uv(jv([sv, e5])), t4 ? sv : ""])), l2 = (e5) => o2 ? i2(e5) : s2(e5), c2 = (e5, n4) => t3(e5, Object.assign({__onHtmlBindingRoot: a2}, n4), {stripTrailingHardline: true});
              if (e4.fullName === "srcset" && (e4.parent.fullName === "img" || e4.parent.fullName === "source"))
                return s2(_v(u3()));
              if (e4.fullName === "class" && !n3.parentParser) {
                const e5 = u3();
                if (!e5.includes("{{"))
                  return Iv(e5);
              }
              if (e4.fullName === "style" && !n3.parentParser) {
                const e5 = u3();
                if (!e5.includes("{{"))
                  return s2(c2(e5, {parser: "css", __isHTMLStyleAttribute: true}));
              }
              if (n3.parser === "vue") {
                if (e4.fullName === "v-for")
                  return Nv(u3(), c2);
                if (e4.fullName === "slot-scope")
                  return Ov(u3(), c2);
                const t4 = ["^:", "^v-bind:"], n4 = ["^v-", "^#"];
                if (r3(["^@", "^v-on:"])) {
                  const e5 = u3();
                  return l2(c2(e5, {parser: Pv(e5) ? "__js_expression" : "__vue_event_binding"}));
                }
                if (r3(t4))
                  return l2(c2(u3(), {parser: "__vue_expression"}));
                if (r3(n4))
                  return l2(c2(u3(), {parser: "__js_expression"}));
              }
              if (n3.parser === "angular") {
                const t4 = (e5, t5) => c2(e5, Object.assign({}, t5, {trailingComma: "none"})), n4 = ["^\\*"], o3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], a3 = ["^i18n(-.+)?$"];
                if (r3(["^\\(.+\\)$", "^on-"]))
                  return l2(t4(u3(), {parser: "__ng_action"}));
                if (r3(o3))
                  return l2(t4(u3(), {parser: "__ng_binding"}));
                if (r3(a3)) {
                  const t5 = u3().trim();
                  return s2(ev(uF(e4, t5)), !t5.includes("@@"));
                }
                if (r3(n4))
                  return l2(t4(u3(), {parser: "__ng_directive"}));
                const i3 = /{{([\S\s]+?)}}/g, p2 = u3();
                if (i3.test(p2)) {
                  const e5 = [];
                  return p2.split(i3).forEach((n5, r4) => {
                    if (r4 % 2 == 0)
                      e5.push(jv(YA(n5, iv)));
                    else
                      try {
                        e5.push(tv(jv(["{{", uv(jv([av, t4(n5, {parser: "__ng_interpolation", __isInHtmlInterpolation: true})])), av, "}}"])));
                      } catch (t5) {
                        e5.push("{{", jv(YA(n5, iv)), "}}");
                      }
                  }), tv(jv(e5));
                }
              }
              return null;
            }(u2, (e4, t3) => n2(e4, Object.assign({__isInHtmlAttribute: true}, t3), {stripTrailingHardline: true}), r2);
            if (e3)
              return jv([u2.rawName, '="', tv(HA(e3, (e4) => typeof e4 == "string" ? e4.replace(/"/g, "&quot;") : e4)), '"']);
            break;
          }
          case "front-matter":
            return KA(u2, n2);
        }
      }};
      var aF = {htmlWhitespaceSensitivity: {since: "1.15.0", category: "HTML", type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{value: "css", description: "Respect the default value of CSS display property."}, {value: "strict", description: "Whitespaces are considered sensitive."}, {value: "ignore", description: "Whitespaces are considered insensitive."}]}, vueIndentScriptAndStyle: {since: "1.19.0", category: "HTML", type: "boolean", default: false, description: "Indent script and style tags in Vue files."}}, iF = ["xhtml"], sF = [".html", ".htm", ".html.hl", ".inc", ".st", ".xht", ".xhtml"], lF = {name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: iF, extensions: sF, languageId: 146}, cF = Object.freeze({__proto__: null, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: iF, extensions: sF, languageId: 146, default: lF}), pF = [".vue"], dF = {name: "Vue", type: "markup", color: "#2c3e50", extensions: pF, tmScope: "text.html.vue", aceMode: "html", languageId: 391}, fF = Object.freeze({__proto__: null, name: "Vue", type: "markup", color: "#2c3e50", extensions: pF, tmScope: "text.html.vue", aceMode: "html", languageId: 391, default: dF}), hF = Ue(cF), mF = Ue(fF);
      var gF = {languages: [As(hF, () => ({name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: []})), As(hF, (e2) => ({since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: e2.extensions.concat([".mjml"])})), As(hF, () => ({name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: []})), As(mF, () => ({since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"]}))], printers: {html: oF}, options: aF, parsers: {get html() {
        return {}.parsers.html;
      }, get vue() {
        return {}.parsers.vue;
      }, get angular() {
        return {}.parsers.angular;
      }, get lwc() {
        return {}.parsers.lwc;
      }}};
      var DF = {isPragma: function(e2) {
        return /^\s*@(prettier|format)\s*$/.test(e2);
      }, hasPragma: function(e2) {
        return /^\s*#[^\S\n]*@(prettier|format)\s*?(\n|$)/.test(e2);
      }, insertPragma: function(e2) {
        return "# @format\n\n".concat(e2);
      }};
      const {getLast: yF} = Lt;
      function EF(e2, t2) {
        return e2 && typeof e2.type == "string" && (!t2 || t2.includes(e2.type));
      }
      function CF(e2) {
        return e2.value.trim() === "prettier-ignore";
      }
      function bF(e2) {
        return e2 && e2.leadingComments && e2.leadingComments.length !== 0;
      }
      function AF(e2) {
        return e2 && e2.middleComments && e2.middleComments.length !== 0;
      }
      function vF(e2) {
        return e2 && e2.indicatorComment;
      }
      function FF(e2) {
        return e2 && e2.trailingComment;
      }
      function xF(e2) {
        return e2 && e2.endComments && e2.endComments.length !== 0;
      }
      function SF(e2) {
        const t2 = [];
        let n2;
        for (const r2 of e2.split(/( +)/g))
          r2 !== " " ? n2 === " " ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : n2 === void 0 && t2.unshift(""), n2 = r2;
        return n2 === " " && t2.push((t2.pop() || "") + " "), t2[0] === "" && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
      }
      var wF = {getLast: yF, getAncestorCount: function(e2, t2) {
        let n2 = 0;
        const r2 = e2.stack.length - 1;
        for (let u2 = 0; u2 < r2; u2++) {
          const r3 = e2.stack[u2];
          EF(r3) && t2(r3) && n2++;
        }
        return n2;
      }, isNode: EF, isEmptyNode: function(e2) {
        return !(e2.children && e2.children.length !== 0 || function(e3) {
          return bF(e3) || AF(e3) || vF(e3) || FF(e3) || xF(e3);
        }(e2));
      }, mapNode: function e2(t2, n2, r2) {
        return n2("children" in t2 ? Object.assign({}, t2, {children: t2.children.map((r3) => e2(r3, n2, t2))}) : t2, r2);
      }, defineShortcut: function(e2, t2, n2) {
        Object.defineProperty(e2, t2, {get: n2, enumerable: false});
      }, isNextLineEmpty: function(e2, t2) {
        let n2 = 0;
        const r2 = t2.length;
        for (let u2 = e2.position.end.offset - 1; u2 < r2; u2++) {
          const e3 = t2[u2];
          if (e3 === "\n" && n2++, n2 === 1 && /\S/.test(e3))
            return false;
          if (n2 === 2)
            return true;
        }
        return false;
      }, isLastDescendantNode: function(e2) {
        switch (e2.getValue().type) {
          case "tag":
          case "anchor":
          case "comment":
            return false;
        }
        const t2 = e2.stack.length;
        for (let n2 = 1; n2 < t2; n2++) {
          const t3 = e2.stack[n2], r2 = e2.stack[n2 - 1];
          if (Array.isArray(r2) && typeof t3 == "number" && t3 !== r2.length - 1)
            return false;
        }
        return true;
      }, getBlockValueLineContents: function(e2, {parentIndent: t2, isLastDescendant: n2, options: r2}) {
        const u2 = e2.position.start.line === e2.position.end.line ? "" : r2.originalText.slice(e2.position.start.offset, e2.position.end.offset).match(/^[^\n]*?\n([\S\s]*)$/)[1], o2 = e2.indent === null ? (a2 = u2.match(/^( *)\S/m)) ? a2[1].length : 1 / 0 : e2.indent - 1 + t2;
        var a2;
        const i2 = u2.split("\n").map((e3) => e3.slice(o2));
        return r2.proseWrap === "preserve" || e2.type === "blockLiteral" ? s2(i2.map((e3) => e3.length === 0 ? [] : [e3])) : s2(i2.map((e3) => e3.length === 0 ? [] : SF(e3)).reduce((e3, t3, n3) => n3 === 0 || i2[n3 - 1].length === 0 || t3.length === 0 || /^\s/.test(t3[0]) || /^\s|\s$/.test(yF(e3)) ? e3.concat([t3]) : e3.concat([e3.pop().concat(t3)]), []).map((e3) => e3.reduce((e4, t3) => e4.length !== 0 && /\s$/.test(yF(e4)) ? e4.concat(e4.pop() + " " + t3) : e4.concat(t3), [])).map((e3) => r2.proseWrap === "never" ? [e3.join(" ")] : e3));
        function s2(t3) {
          if (e2.chomping === "keep")
            return yF(t3).length === 0 ? t3.slice(0, -1) : t3;
          let r3 = 0;
          for (let e3 = t3.length - 1; e3 >= 0 && t3[e3].length === 0; e3--)
            r3++;
          return r3 === 0 ? t3 : r3 >= 2 && !n2 ? t3.slice(0, -(r3 - 1)) : t3.slice(0, -r3);
        }
      }, getFlowScalarLineContents: function(e2, t2, n2) {
        const r2 = t2.split("\n").map((e3, t3, n3) => t3 === 0 && t3 === n3.length - 1 ? e3 : t3 !== 0 && t3 !== n3.length - 1 ? e3.trim() : t3 === 0 ? e3.trimEnd() : e3.trimStart());
        return n2.proseWrap === "preserve" ? r2.map((e3) => e3.length === 0 ? [] : [e3]) : r2.map((e3) => e3.length === 0 ? [] : SF(e3)).reduce((t3, n3, u2) => u2 === 0 || r2[u2 - 1].length === 0 || n3.length === 0 || e2 === "quoteDouble" && yF(yF(t3)).endsWith("\\") ? t3.concat([n3]) : t3.concat([t3.pop().concat(n3)]), []).map((e3) => n2.proseWrap === "never" ? [e3.join(" ")] : e3);
      }, getLastDescendantNode: function e2(t2) {
        return "children" in t2 && t2.children.length !== 0 ? e2(yF(t2.children)) : t2;
      }, hasPrettierIgnore: function(e2) {
        const t2 = e2.getValue();
        if (t2.type === "documentBody") {
          const t3 = e2.getParentNode();
          return xF(t3.head) && CF(yF(t3.head.endComments));
        }
        return bF(t2) && CF(yF(t2.leadingComments));
      }, hasLeadingComments: bF, hasMiddleComments: AF, hasIndicatorComment: vF, hasTrailingComment: FF, hasEndComments: xF};
      const BF = dn.builders, {conditionalGroup: TF, breakParent: kF, concat: NF, dedent: OF, dedentToRoot: PF, fill: _F, group: IF, hardline: jF, ifBreak: MF, join: LF, line: RF, lineSuffix: qF, literalline: VF, markAsRoot: WF, softline: $F} = BF, {replaceEndOfLineWith: UF, isPreviousLineEmpty: zF} = Lt, {insertPragma: JF, isPragma: GF} = DF, {getAncestorCount: HF, getBlockValueLineContents: XF, getFlowScalarLineContents: YF, getLast: KF, getLastDescendantNode: QF, hasLeadingComments: ZF, hasMiddleComments: ex, hasIndicatorComment: tx, hasTrailingComment: nx, hasEndComments: rx, hasPrettierIgnore: ux, isLastDescendantNode: ox, isNextLineEmpty: ax, isNode: ix, isEmptyNode: sx, defineShortcut: lx, mapNode: cx} = wF;
      function px(e2) {
        switch (e2.type) {
          case "document":
            lx(e2, "head", () => e2.children[0]), lx(e2, "body", () => e2.children[1]);
            break;
          case "documentBody":
          case "sequenceItem":
          case "flowSequenceItem":
          case "mappingKey":
          case "mappingValue":
            lx(e2, "content", () => e2.children[0]);
            break;
          case "mappingItem":
          case "flowMappingItem":
            lx(e2, "key", () => e2.children[0]), lx(e2, "value", () => e2.children[1]);
        }
        return e2;
      }
      function dx(e2, t2, n2, r2, u2) {
        switch (e2.type) {
          case "root":
            return NF([LF(jF, n2.map((t3, r3) => {
              const o3 = e2.children[r3], a3 = e2.children[r3 + 1];
              return NF([u2(t3), gx(o3, a3) ? NF([jF, "...", nx(o3) ? NF([" ", n2.call(u2, "trailingComment")]) : ""]) : !a3 || nx(a3.head) ? "" : NF([jF, "---"])]);
            }, "children")), e2.children.length === 0 || (a2 = QF(e2), ix(a2, ["blockLiteral", "blockFolded"]) && a2.chomping === "keep") ? "" : jF]);
          case "document": {
            const o3 = t2.children[n2.getName() + 1];
            return LF(jF, [Dx(e2, o3, t2, r2) === "head" ? LF(jF, [e2.head.children.length === 0 && e2.head.endComments.length === 0 ? "" : n2.call(u2, "head"), NF(["---", nx(e2.head) ? NF([" ", n2.call(u2, "head", "trailingComment")]) : ""])].filter(Boolean)) : "", mx(e2) ? n2.call(u2, "body") : ""].filter(Boolean));
          }
          case "documentHead":
            return LF(jF, [].concat(n2.map(u2, "children"), n2.map(u2, "endComments")));
          case "documentBody": {
            const t3 = LF(jF, n2.map(u2, "children")).parts, r3 = LF(jF, n2.map(u2, "endComments")).parts, o3 = t3.length === 0 || r3.length === 0 ? "" : ((e3) => ix(e3, ["blockFolded", "blockLiteral"]) ? e3.chomping === "keep" ? "" : NF([jF, jF]) : jF)(QF(e2));
            return NF([].concat(t3, o3, r3));
          }
          case "directive":
            return NF(["%", LF(" ", [e2.name].concat(e2.parameters))]);
          case "comment":
            return NF(["#", e2.value]);
          case "alias":
            return NF(["*", e2.value]);
          case "tag":
            return r2.originalText.slice(e2.position.start.offset, e2.position.end.offset);
          case "anchor":
            return NF(["&", e2.value]);
          case "plain":
            return Ax(e2.type, r2.originalText.slice(e2.position.start.offset, e2.position.end.offset), r2);
          case "quoteDouble":
          case "quoteSingle": {
            const t3 = "'", n3 = '"', u3 = r2.originalText.slice(e2.position.start.offset + 1, e2.position.end.offset - 1);
            if (e2.type === "quoteSingle" && u3.includes("\\") || e2.type === "quoteDouble" && /\\[^"]/.test(u3)) {
              const o4 = e2.type === "quoteDouble" ? n3 : t3;
              return NF([o4, Ax(e2.type, u3, r2), o4]);
            }
            if (u3.includes(n3))
              return NF([t3, Ax(e2.type, e2.type === "quoteDouble" ? u3.replace(/\\"/g, n3).replace(/'/g, t3.repeat(2)) : u3, r2), t3]);
            if (u3.includes(t3))
              return NF([n3, Ax(e2.type, e2.type === "quoteSingle" ? u3.replace(/''/g, t3) : u3, r2), n3]);
            const o3 = r2.singleQuote ? t3 : n3;
            return NF([o3, Ax(e2.type, u3, r2), o3]);
          }
          case "blockFolded":
          case "blockLiteral": {
            const t3 = HF(n2, (e3) => ix(e3, ["sequence", "mapping"])), o3 = ox(n2);
            return NF([e2.type === "blockFolded" ? ">" : "|", e2.indent === null ? "" : e2.indent.toString(), e2.chomping === "clip" ? "" : e2.chomping === "keep" ? "+" : "-", tx(e2) ? NF([" ", n2.call(u2, "indicatorComment")]) : "", (e2.indent === null ? OF : PF)(fx(e2.indent === null ? r2.tabWidth : e2.indent - 1 + t3, NF(XF(e2, {parentIndent: t3, isLastDescendant: o3, options: r2}).reduce((t4, n3, r3, u3) => t4.concat(r3 === 0 ? jF : "", _F(LF(RF, n3).parts), r3 !== u3.length - 1 ? n3.length === 0 ? jF : WF(VF) : e2.chomping === "keep" && o3 ? n3.length === 0 ? PF(jF) : PF(VF) : ""), []))))]);
          }
          case "sequence":
            return LF(jF, n2.map(u2, "children"));
          case "sequenceItem":
            return NF(["- ", fx(2, e2.content ? n2.call(u2, "content") : "")]);
          case "mappingKey":
          case "mappingValue":
            return e2.content ? n2.call(u2, "content") : "";
          case "mapping":
            return LF(jF, n2.map(u2, "children"));
          case "mappingItem":
          case "flowMappingItem": {
            const o3 = sx(e2.key), a3 = sx(e2.value);
            if (o3 && a3)
              return NF([": "]);
            const s2 = n2.call(u2, "key"), l2 = n2.call(u2, "value");
            if (a3)
              return e2.type === "flowMappingItem" && t2.type === "flowMapping" ? s2 : e2.type !== "mappingItem" || !yx(e2.key.content, r2) || nx(e2.key.content) || t2.tag && t2.tag.value === "tag:yaml.org,2002:set" ? NF(["? ", fx(2, s2)]) : NF([s2, Ex(e2) ? " " : "", ":"]);
            if (o3)
              return NF([": ", fx(2, l2)]);
            const c2 = Symbol("mappingKey");
            return ZF(e2.value) || !hx(e2.key.content) ? NF(["? ", fx(2, s2), jF, LF("", n2.map(u2, "value", "leadingComments").map((e3) => NF([e3, jF]))), ": ", fx(2, l2)]) : !function(e3) {
              if (!e3)
                return true;
              switch (e3.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                  return e3.position.start.line === e3.position.end.line;
                case "alias":
                  return true;
                default:
                  return false;
              }
            }(e2.key.content) || ZF(e2.key.content) || ex(e2.key.content) || nx(e2.key.content) || rx(e2.key) || ZF(e2.value.content) || ex(e2.value.content) || rx(e2.value) || !yx(e2.value.content, r2) ? TF([NF([IF(NF([MF("? "), IF(fx(2, s2), {id: c2})])), MF(NF([jF, ": ", fx(2, l2)]), i2(NF([Ex(e2) ? " " : "", ":", ZF(e2.value.content) || rx(e2.value) && e2.value.content && !ix(e2.value.content, ["mapping", "sequence"]) || t2.type === "mapping" && nx(e2.key.content) && hx(e2.value.content) || ix(e2.value.content, ["mapping", "sequence"]) && e2.value.content.tag === null && e2.value.content.anchor === null ? jF : e2.value.content ? RF : "", l2])), {groupId: c2})])]) : NF([s2, Ex(e2) ? " " : "", ": ", l2]);
          }
          case "flowMapping":
          case "flowSequence": {
            const t3 = e2.type === "flowMapping" ? "{" : "[", a3 = e2.type === "flowMapping" ? "}" : "]", s2 = e2.type === "flowMapping" && e2.children.length !== 0 && r2.bracketSpacing ? RF : $F, l2 = e2.children.length !== 0 && ((o2 = KF(e2.children)).type === "flowMappingItem" && sx(o2.key) && sx(o2.value));
            return NF([t3, i2(NF([s2, NF(n2.map((t4, n3) => NF([u2(t4), n3 === e2.children.length - 1 ? "" : NF([",", RF, e2.children[n3].position.start.line !== e2.children[n3 + 1].position.start.line ? bx(t4, r2.originalText) : ""])]), "children")), MF(",", "")])), l2 ? "" : s2, a3]);
          }
          case "flowSequenceItem":
            return n2.call(u2, "content");
          default:
            throw new Error("Unexpected node type ".concat(e2.type));
        }
        var o2, a2;
        function i2(e3) {
          return BF.align(" ".repeat(r2.tabWidth), e3);
        }
      }
      function fx(e2, t2) {
        return typeof e2 == "number" && e2 > 0 ? BF.align(" ".repeat(e2), t2) : BF.align(e2, t2);
      }
      function hx(e2) {
        if (!e2)
          return true;
        switch (e2.type) {
          case "plain":
          case "quoteDouble":
          case "quoteSingle":
          case "alias":
          case "flowMapping":
          case "flowSequence":
            return true;
          default:
            return false;
        }
      }
      function mx(e2) {
        return e2.body.children.length !== 0 || rx(e2.body);
      }
      function gx(e2, t2) {
        return nx(e2) || t2 && (t2.head.children.length !== 0 || rx(t2.head));
      }
      function Dx(e2, t2, n2, r2) {
        return n2.children[0] === e2 && /---(\s|$)/.test(r2.originalText.slice(r2.locStart(e2), r2.locStart(e2) + 4)) || e2.head.children.length !== 0 || rx(e2.head) || nx(e2.head) ? "head" : !gx(e2, t2) && (!!t2 && "root");
      }
      function yx(e2, t2) {
        if (!e2)
          return true;
        switch (e2.type) {
          case "plain":
          case "quoteSingle":
          case "quoteDouble":
            break;
          case "alias":
            return true;
          default:
            return false;
        }
        if (t2.proseWrap === "preserve")
          return e2.position.start.line === e2.position.end.line;
        if (/\\$/m.test(t2.originalText.slice(e2.position.start.offset, e2.position.end.offset)))
          return false;
        switch (t2.proseWrap) {
          case "never":
            return !e2.value.includes("\n");
          case "always":
            return !/[\n ]/.test(e2.value);
          default:
            return false;
        }
      }
      function Ex(e2) {
        return e2.key.content && e2.key.content.type === "alias";
      }
      function Cx(e2) {
        return rx(e2) && !ix(e2, ["documentHead", "documentBody"]);
      }
      function bx(e2, t2) {
        const n2 = e2.getValue(), r2 = e2.stack[0];
        return r2.isNextEmptyLinePrintedChecklist = r2.isNextEmptyLinePrintedChecklist || [], r2.isNextEmptyLinePrintedChecklist[n2.position.end.line] || !ax(n2, t2) || (r2.isNextEmptyLinePrintedChecklist[n2.position.end.line] = true, Cx(e2.getParentNode())) ? "" : $F;
      }
      function Ax(e2, t2, n2) {
        const r2 = YF(e2, t2, n2);
        return LF(jF, r2.map((e3) => _F(LF(RF, e3).parts)));
      }
      var vx = {preprocess: function(e2) {
        return cx(e2, px);
      }, print: function(e2, t2, n2) {
        const r2 = e2.getValue(), u2 = e2.getParentNode(), o2 = r2.tag ? e2.call(n2, "tag") : "", a2 = r2.anchor ? e2.call(n2, "anchor") : "", i2 = ix(r2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !ox(e2) ? bx(e2, t2.originalText) : "";
        return NF([r2.type !== "mappingValue" && ZF(r2) ? NF([LF(jF, e2.map(n2, "leadingComments")), jF]) : "", o2, o2 && a2 ? " " : "", a2, o2 || a2 ? ix(r2, ["sequence", "mapping"]) && !ex(r2) ? jF : " " : "", ex(r2) ? NF([r2.middleComments.length === 1 ? "" : jF, LF(jF, e2.map(n2, "middleComments")), jF]) : "", ux(e2) ? NF(UF(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), VF)) : IF(dx(r2, u2, e2, t2, n2)), nx(r2) && !ix(r2, ["document", "documentHead"]) ? qF(NF([r2.type !== "mappingValue" || r2.content ? " " : "", u2.type === "mappingKey" && e2.getParentNode(2).type === "mapping" && hx(r2) ? "" : kF, e2.call(n2, "trailingComment")])) : "", Cx(r2) ? fx(r2.type === "sequenceItem" ? 2 : 0, NF([jF, LF(jF, e2.map((e3) => NF([zF(t2.originalText, e3.getValue(), t2.locStart) ? jF : "", n2(e3)]), "endComments"))])) : "", i2]);
      }, massageAstNode: function(e2, t2) {
        if (ix(t2))
          switch (delete t2.position, t2.type) {
            case "comment":
              if (GF(t2.value))
                return null;
              break;
            case "quoteDouble":
            case "quoteSingle":
              t2.type = "quote";
          }
      }, insertPragma: JF}, Fx = {bracketSpacing: Bh.bracketSpacing, singleQuote: Bh.singleQuote, proseWrap: Bh.proseWrap}, xx = ["yml"], Sx = [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], wx = [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], Bx = {name: "YAML", type: "data", tmScope: "source.yaml", aliases: xx, extensions: Sx, filenames: wx, aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407};
      var Tx = [dm, DD, vy, $y, mC, gF, {languages: [As(Ue(Object.freeze({__proto__: null, name: "YAML", type: "data", tmScope: "source.yaml", aliases: xx, extensions: Sx, filenames: wx, aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407, default: Bx})), (e2) => ({since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: e2.filenames.filter((e3) => e3 !== "yarn.lock")}))], printers: {yaml: vx}, options: Fx, parsers: {get yaml() {
        return {}.parsers.yaml;
      }}}];
      const {version: kx} = ht, {getSupportInfo: Nx} = yt, Ox = Tx.map((t2) => e(t2, ["parsers"]));
      function Px(e2, t2 = 1) {
        return (...n2) => {
          const r2 = n2[t2] || {}, u2 = r2.plugins || [];
          return n2[t2] = Object.assign({}, r2, {plugins: [...Ox, ...Array.isArray(u2) ? u2 : Object.values(u2)]}), e2(...n2);
        };
      }
      const _x = Px(Ki.formatWithCursor);
      return {formatWithCursor: _x, format: (e2, t2) => _x(e2, t2).formatted, check(e2, t2) {
        const {formatted: n2} = _x(e2, t2);
        return n2 === e2;
      }, doc: dn, getSupportInfo: Px(Nx, 0), version: kx, util: bs, __debug: {parse: Px(Ki.parse), formatAST: Px(Ki.formatAST), formatDoc: Px(Ki.formatDoc), printToDoc: Px(Ki.printToDoc), printDocToString: Px(Ki.printDocToString)}};
    });
  });

  // node_modules/prettier/parser-babel.js
  var require_parser_babel = __commonJS((exports, module) => {
    !function(t, e) {
      typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : ((t = typeof globalThis != "undefined" ? globalThis : t || self).prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.babel = e());
    }(exports, function() {
      "use strict";
      var t = function(t2, e2) {
        const s2 = new SyntaxError(t2 + " (" + e2.start.line + ":" + e2.start.column + ")");
        return s2.loc = e2, s2;
      };
      function e(t2, e2, s2) {
        return t2(s2 = {path: e2, exports: {}, require: function(t3, e3) {
          return function() {
            throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
          }(e3 == null && s2.path);
        }}, s2.exports), s2.exports;
      }
      function s(t2) {
        return t2 && t2.default || t2;
      }
      var i = Object.freeze({__proto__: null, default: {EOL: "\n"}});
      const r = (t2) => {
        if (typeof t2 != "string")
          throw new TypeError("Expected a string");
        const e2 = t2.match(/(?:\r?\n)/g) || [];
        if (e2.length === 0)
          return;
        const s2 = e2.filter((t3) => t3 === "\r\n").length;
        return s2 > e2.length - s2 ? "\r\n" : "\n";
      };
      var a = r;
      a.graceful = (t2) => typeof t2 == "string" && r(t2) || "\n";
      var n = s(i), o = e(function(t2, e2) {
        function s2() {
          const t3 = n;
          return s2 = function() {
            return t3;
          }, t3;
        }
        function i2() {
          const t3 = (e3 = a) && e3.__esModule ? e3 : {default: e3};
          var e3;
          return i2 = function() {
            return t3;
          }, t3;
        }
        Object.defineProperty(e2, "__esModule", {value: true}), e2.extract = function(t3) {
          const e3 = t3.match(h2);
          return e3 ? e3[0].trimLeft() : "";
        }, e2.strip = function(t3) {
          const e3 = t3.match(h2);
          return e3 && e3[0] ? t3.substring(e3[0].length) : t3;
        }, e2.parse = function(t3) {
          return f2(t3).pragmas;
        }, e2.parseWithComments = f2, e2.print = function({comments: t3 = "", pragmas: e3 = {}}) {
          const r3 = (0, i2().default)(t3) || s2().EOL, a2 = Object.keys(e3), n2 = a2.map((t4) => D2(t4, e3[t4])).reduce((t4, e4) => t4.concat(e4), []).map((t4) => " * " + t4 + r3).join("");
          if (!t3) {
            if (a2.length === 0)
              return "";
            if (a2.length === 1 && !Array.isArray(e3[a2[0]])) {
              const t4 = e3[a2[0]];
              return "".concat("/**", " ").concat(D2(a2[0], t4)[0]).concat(" */");
            }
          }
          const o3 = t3.split(r3).map((t4) => "".concat(" *", " ").concat(t4)).join(r3) + r3;
          return "/**" + r3 + (t3 ? o3 : "") + (t3 && a2.length ? " *" + r3 : "") + n2 + " */";
        };
        const r2 = /\*\/$/, o2 = /^\/\*\*/, h2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, c2 = /(^|\s+)\/\/([^\r\n]*)/g, p2 = /^(\r?\n)+/, u2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, d2 = /(\r?\n|^) *\* ?/g, m2 = [];
        function f2(t3) {
          const e3 = (0, i2().default)(t3) || s2().EOL;
          t3 = t3.replace(o2, "").replace(r2, "").replace(d2, "$1");
          let a2 = "";
          for (; a2 !== t3; )
            a2 = t3, t3 = t3.replace(u2, "".concat(e3, "$1 $2").concat(e3));
          t3 = t3.replace(p2, "").trimRight();
          const n2 = Object.create(null), h3 = t3.replace(l2, "").replace(p2, "").trimRight();
          let f3;
          for (; f3 = l2.exec(t3); ) {
            const t4 = f3[2].replace(c2, "");
            typeof n2[f3[1]] == "string" || Array.isArray(n2[f3[1]]) ? n2[f3[1]] = m2.concat(n2[f3[1]], t4) : n2[f3[1]] = t4;
          }
          return {comments: h3, pragmas: n2};
        }
        function D2(t3, e3) {
          return m2.concat(e3).map((e4) => "@".concat(t3, " ").concat(e4).trim());
        }
      }), h = (t2) => typeof t2 == "string" ? t2.replace((({onlyFirst: t3 = false} = {}) => {
        const e2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(e2, t3 ? void 0 : "g");
      })(), "") : t2;
      const c = (t2) => !Number.isNaN(t2) && (t2 >= 4352 && (t2 <= 4447 || t2 === 9001 || t2 === 9002 || 11904 <= t2 && t2 <= 12871 && t2 !== 12351 || 12880 <= t2 && t2 <= 19903 || 19968 <= t2 && t2 <= 42182 || 43360 <= t2 && t2 <= 43388 || 44032 <= t2 && t2 <= 55203 || 63744 <= t2 && t2 <= 64255 || 65040 <= t2 && t2 <= 65049 || 65072 <= t2 && t2 <= 65131 || 65281 <= t2 && t2 <= 65376 || 65504 <= t2 && t2 <= 65510 || 110592 <= t2 && t2 <= 110593 || 127488 <= t2 && t2 <= 127569 || 131072 <= t2 && t2 <= 262141));
      var p = c, u = c;
      p.default = u;
      const l = (t2) => {
        if (typeof (t2 = t2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) != "string" || t2.length === 0)
          return 0;
        t2 = h(t2);
        let e2 = 0;
        for (let s2 = 0; s2 < t2.length; s2++) {
          const i2 = t2.codePointAt(s2);
          i2 <= 31 || i2 >= 127 && i2 <= 159 || (i2 >= 768 && i2 <= 879 || (i2 > 65535 && s2++, e2 += p(i2) ? 2 : 1));
        }
        return e2;
      };
      var d = l, m = l;
      d.default = m;
      var f = (t2) => {
        if (typeof t2 != "string")
          throw new TypeError("Expected a string");
        return t2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      };
      function D(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, {raw: {value: Object.freeze(e2)}}));
      }
      var y = typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
      function x() {
        throw new Error("setTimeout has not been defined");
      }
      function g() {
        throw new Error("clearTimeout has not been defined");
      }
      var E = x, P = g;
      function b(t2) {
        if (E === setTimeout)
          return setTimeout(t2, 0);
        if ((E === x || !E) && setTimeout)
          return E = setTimeout, setTimeout(t2, 0);
        try {
          return E(t2, 0);
        } catch (e2) {
          try {
            return E.call(null, t2, 0);
          } catch (e3) {
            return E.call(this, t2, 0);
          }
        }
      }
      typeof y.setTimeout == "function" && (E = setTimeout), typeof y.clearTimeout == "function" && (P = clearTimeout);
      var C, T = [], A = false, w = -1;
      function N() {
        A && C && (A = false, C.length ? T = C.concat(T) : w = -1, T.length && S());
      }
      function S() {
        if (!A) {
          var t2 = b(N);
          A = true;
          for (var e2 = T.length; e2; ) {
            for (C = T, T = []; ++w < e2; )
              C && C[w].run();
            w = -1, e2 = T.length;
          }
          C = null, A = false, function(t3) {
            if (P === clearTimeout)
              return clearTimeout(t3);
            if ((P === g || !P) && clearTimeout)
              return P = clearTimeout, clearTimeout(t3);
            try {
              P(t3);
            } catch (e3) {
              try {
                return P.call(null, t3);
              } catch (e4) {
                return P.call(this, t3);
              }
            }
          }(t2);
        }
      }
      function I(t2, e2) {
        this.fun = t2, this.array = e2;
      }
      I.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      function F() {
      }
      var v = F, k = F, L = F, O = F, R = F, M = F, B = F;
      var _ = y.performance || {}, j = _.now || _.mozNow || _.msNow || _.oNow || _.webkitNow || function() {
        return new Date().getTime();
      };
      var U = new Date();
      var q = {nextTick: function(t2) {
        var e2 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var s2 = 1; s2 < arguments.length; s2++)
            e2[s2 - 1] = arguments[s2];
        T.push(new I(t2, e2)), T.length !== 1 || A || b(S);
      }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: v, addListener: k, once: L, off: O, removeListener: R, removeAllListeners: M, emit: B, binding: function(t2) {
        throw new Error("process.binding is not supported");
      }, cwd: function() {
        return "/";
      }, chdir: function(t2) {
        throw new Error("process.chdir is not supported");
      }, umask: function() {
        return 0;
      }, hrtime: function(t2) {
        var e2 = 1e-3 * j.call(_), s2 = Math.floor(e2), i2 = Math.floor(e2 % 1 * 1e9);
        return t2 && (s2 -= t2[0], (i2 -= t2[1]) < 0 && (s2--, i2 += 1e9)), [s2, i2];
      }, platform: "browser", release: {}, config: {}, uptime: function() {
        return (new Date() - U) / 1e3;
      }};
      var V = typeof q == "object" && q.env && q.env.NODE_DEBUG && /\bsemver\b/i.test(q.env.NODE_DEBUG) ? (...t2) => console.error("SEMVER", ...t2) : () => {
      };
      var z = {SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16}, H = e(function(t2, e2) {
        const {MAX_SAFE_COMPONENT_LENGTH: s2} = z, i2 = (e2 = t2.exports = {}).re = [], r2 = e2.src = [], a2 = e2.t = {};
        let n2 = 0;
        const o2 = (t3, e3, s3) => {
          const o3 = n2++;
          V(o3, e3), a2[t3] = o3, r2[o3] = e3, i2[o3] = new RegExp(e3, s3 ? "g" : void 0);
        };
        o2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o2("MAINVERSION", "(".concat(r2[a2.NUMERICIDENTIFIER], ")\\.") + "(".concat(r2[a2.NUMERICIDENTIFIER], ")\\.") + "(".concat(r2[a2.NUMERICIDENTIFIER], ")")), o2("MAINVERSIONLOOSE", "(".concat(r2[a2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(r2[a2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(r2[a2.NUMERICIDENTIFIERLOOSE], ")")), o2("PRERELEASEIDENTIFIER", "(?:".concat(r2[a2.NUMERICIDENTIFIER], "|").concat(r2[a2.NONNUMERICIDENTIFIER], ")")), o2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r2[a2.NUMERICIDENTIFIERLOOSE], "|").concat(r2[a2.NONNUMERICIDENTIFIER], ")")), o2("PRERELEASE", "(?:-(".concat(r2[a2.PRERELEASEIDENTIFIER], "(?:\\.").concat(r2[a2.PRERELEASEIDENTIFIER], ")*))")), o2("PRERELEASELOOSE", "(?:-?(".concat(r2[a2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r2[a2.PRERELEASEIDENTIFIERLOOSE], ")*))")), o2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o2("BUILD", "(?:\\+(".concat(r2[a2.BUILDIDENTIFIER], "(?:\\.").concat(r2[a2.BUILDIDENTIFIER], ")*))")), o2("FULLPLAIN", "v?".concat(r2[a2.MAINVERSION]).concat(r2[a2.PRERELEASE], "?").concat(r2[a2.BUILD], "?")), o2("FULL", "^".concat(r2[a2.FULLPLAIN], "$")), o2("LOOSEPLAIN", "[v=\\s]*".concat(r2[a2.MAINVERSIONLOOSE]).concat(r2[a2.PRERELEASELOOSE], "?").concat(r2[a2.BUILD], "?")), o2("LOOSE", "^".concat(r2[a2.LOOSEPLAIN], "$")), o2("GTLT", "((?:<|>)?=?)"), o2("XRANGEIDENTIFIERLOOSE", "".concat(r2[a2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o2("XRANGEIDENTIFIER", "".concat(r2[a2.NUMERICIDENTIFIER], "|x|X|\\*")), o2("XRANGEPLAIN", "[v=\\s]*(".concat(r2[a2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(r2[a2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(r2[a2.XRANGEIDENTIFIER], ")") + "(?:".concat(r2[a2.PRERELEASE], ")?").concat(r2[a2.BUILD], "?") + ")?)?"), o2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(r2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(r2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(r2[a2.PRERELEASELOOSE], ")?").concat(r2[a2.BUILD], "?") + ")?)?"), o2("XRANGE", "^".concat(r2[a2.GTLT], "\\s*").concat(r2[a2.XRANGEPLAIN], "$")), o2("XRANGELOOSE", "^".concat(r2[a2.GTLT], "\\s*").concat(r2[a2.XRANGEPLAINLOOSE], "$")), o2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(s2, "})") + "(?:\\.(\\d{1,".concat(s2, "}))?") + "(?:\\.(\\d{1,".concat(s2, "}))?") + "(?:$|[^\\d])"), o2("COERCERTL", r2[a2.COERCE], true), o2("LONETILDE", "(?:~>?)"), o2("TILDETRIM", "(\\s*)".concat(r2[a2.LONETILDE], "\\s+"), true), e2.tildeTrimReplace = "$1~", o2("TILDE", "^".concat(r2[a2.LONETILDE]).concat(r2[a2.XRANGEPLAIN], "$")), o2("TILDELOOSE", "^".concat(r2[a2.LONETILDE]).concat(r2[a2.XRANGEPLAINLOOSE], "$")), o2("LONECARET", "(?:\\^)"), o2("CARETTRIM", "(\\s*)".concat(r2[a2.LONECARET], "\\s+"), true), e2.caretTrimReplace = "$1^", o2("CARET", "^".concat(r2[a2.LONECARET]).concat(r2[a2.XRANGEPLAIN], "$")), o2("CARETLOOSE", "^".concat(r2[a2.LONECARET]).concat(r2[a2.XRANGEPLAINLOOSE], "$")), o2("COMPARATORLOOSE", "^".concat(r2[a2.GTLT], "\\s*(").concat(r2[a2.LOOSEPLAIN], ")$|^$")), o2("COMPARATOR", "^".concat(r2[a2.GTLT], "\\s*(").concat(r2[a2.FULLPLAIN], ")$|^$")), o2("COMPARATORTRIM", "(\\s*)".concat(r2[a2.GTLT], "\\s*(").concat(r2[a2.LOOSEPLAIN], "|").concat(r2[a2.XRANGEPLAIN], ")"), true), e2.comparatorTrimReplace = "$1$2$3", o2("HYPHENRANGE", "^\\s*(".concat(r2[a2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(r2[a2.XRANGEPLAIN], ")") + "\\s*$"), o2("HYPHENRANGELOOSE", "^\\s*(".concat(r2[a2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(r2[a2.XRANGEPLAINLOOSE], ")") + "\\s*$"), o2("STAR", "(<|>)?=?\\s*\\*"), o2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      });
      const G = /^[0-9]+$/, W = (t2, e2) => {
        const s2 = G.test(t2), i2 = G.test(e2);
        return s2 && i2 && (t2 = +t2, e2 = +e2), t2 === e2 ? 0 : s2 && !i2 ? -1 : i2 && !s2 ? 1 : t2 < e2 ? -1 : 1;
      };
      var X = {compareIdentifiers: W, rcompareIdentifiers: (t2, e2) => W(e2, t2)};
      const {MAX_LENGTH: K, MAX_SAFE_INTEGER: $} = z, {re: J, t: Y} = H, {compareIdentifiers: Q} = X;
      class Z {
        constructor(t2, e2) {
          if (e2 && typeof e2 == "object" || (e2 = {loose: !!e2, includePrerelease: false}), t2 instanceof Z) {
            if (t2.loose === !!e2.loose && t2.includePrerelease === !!e2.includePrerelease)
              return t2;
            t2 = t2.version;
          } else if (typeof t2 != "string")
            throw new TypeError("Invalid Version: ".concat(t2));
          if (t2.length > K)
            throw new TypeError("version is longer than ".concat(K, " characters"));
          V("SemVer", t2, e2), this.options = e2, this.loose = !!e2.loose, this.includePrerelease = !!e2.includePrerelease;
          const s2 = t2.trim().match(e2.loose ? J[Y.LOOSE] : J[Y.FULL]);
          if (!s2)
            throw new TypeError("Invalid Version: ".concat(t2));
          if (this.raw = t2, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > $ || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > $ || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > $ || this.patch < 0)
            throw new TypeError("Invalid patch version");
          s2[4] ? this.prerelease = s2[4].split(".").map((t3) => {
            if (/^[0-9]+$/.test(t3)) {
              const e3 = +t3;
              if (e3 >= 0 && e3 < $)
                return e3;
            }
            return t3;
          }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
        }
        format() {
          return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
        }
        toString() {
          return this.version;
        }
        compare(t2) {
          if (V("SemVer.compare", this.version, this.options, t2), !(t2 instanceof Z)) {
            if (typeof t2 == "string" && t2 === this.version)
              return 0;
            t2 = new Z(t2, this.options);
          }
          return t2.version === this.version ? 0 : this.compareMain(t2) || this.comparePre(t2);
        }
        compareMain(t2) {
          return t2 instanceof Z || (t2 = new Z(t2, this.options)), Q(this.major, t2.major) || Q(this.minor, t2.minor) || Q(this.patch, t2.patch);
        }
        comparePre(t2) {
          if (t2 instanceof Z || (t2 = new Z(t2, this.options)), this.prerelease.length && !t2.prerelease.length)
            return -1;
          if (!this.prerelease.length && t2.prerelease.length)
            return 1;
          if (!this.prerelease.length && !t2.prerelease.length)
            return 0;
          let e2 = 0;
          do {
            const s2 = this.prerelease[e2], i2 = t2.prerelease[e2];
            if (V("prerelease compare", e2, s2, i2), s2 === void 0 && i2 === void 0)
              return 0;
            if (i2 === void 0)
              return 1;
            if (s2 === void 0)
              return -1;
            if (s2 !== i2)
              return Q(s2, i2);
          } while (++e2);
        }
        compareBuild(t2) {
          t2 instanceof Z || (t2 = new Z(t2, this.options));
          let e2 = 0;
          do {
            const s2 = this.build[e2], i2 = t2.build[e2];
            if (V("prerelease compare", e2, s2, i2), s2 === void 0 && i2 === void 0)
              return 0;
            if (i2 === void 0)
              return 1;
            if (s2 === void 0)
              return -1;
            if (s2 !== i2)
              return Q(s2, i2);
          } while (++e2);
        }
        inc(t2, e2) {
          switch (t2) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e2);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e2);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", e2), this.inc("pre", e2);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", e2), this.inc("pre", e2);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0)
                this.prerelease = [0];
              else {
                let t3 = this.prerelease.length;
                for (; --t3 >= 0; )
                  typeof this.prerelease[t3] == "number" && (this.prerelease[t3]++, t3 = -2);
                t3 === -1 && this.prerelease.push(0);
              }
              e2 && (this.prerelease[0] === e2 ? isNaN(this.prerelease[1]) && (this.prerelease = [e2, 0]) : this.prerelease = [e2, 0]);
              break;
            default:
              throw new Error("invalid increment argument: ".concat(t2));
          }
          return this.format(), this.raw = this.version, this;
        }
      }
      var tt = Z;
      var et = (t2, e2, s2) => new tt(t2, s2).compare(new tt(e2, s2));
      var st = (t2, e2, s2) => et(t2, e2, s2) < 0;
      var it = (t2, e2, s2) => et(t2, e2, s2) >= 0, rt = "Prettier is an opinionated code formatter", at = "./bin/prettier.js", nt = {node: ">=10.13.0"}, ot = ["index.js", "standalone.js", "src", "bin"], ht = {"@angular/compiler": "10.0.12", "@babel/code-frame": "7.10.4", "@babel/parser": "7.11.2", "@glimmer/syntax": "0.59.0", "@iarna/toml": "2.2.5", "@typescript-eslint/typescript-estree": "3.10.0", "angular-estree-parser": "2.2.0", "angular-html-parser": "1.7.1", camelcase: "6.0.0", chalk: "4.1.0", "ci-info": "watson/ci-info#f43f6a1cefff47fb361c88cf4b943fdbcaafe540", "cjk-regex": "2.0.0", cosmiconfig: "7.0.0", dashify: "2.0.0", diff: "4.0.2", editorconfig: "0.15.3", "editorconfig-to-prettier": "0.1.1", "escape-string-regexp": "4.0.0", esutils: "2.0.3", "fast-glob": "3.2.4", "fast-json-stable-stringify": "2.1.0", "find-parent-dir": "0.3.0", "flow-parser": "0.132.0", "get-stream": "6.0.0", globby: "11.0.1", graphql: "15.3.0", "html-element-attributes": "2.2.1", "html-styles": "1.0.0", "html-tag-names": "1.1.5", "html-void-elements": "1.0.5", ignore: "4.0.6", "jest-docblock": "26.0.0", json5: "2.1.3", leven: "3.1.0", "lines-and-columns": "1.1.6", "linguist-languages": "7.10.0", lodash: "4.17.20", mem: "6.1.0", minimatch: "3.0.4", minimist: "1.2.5", "n-readlines": "1.0.0", outdent: "0.7.1", "parse-srcset": "ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee", "please-upgrade-node": "3.2.0", "postcss-less": "3.1.4", "postcss-media-query-parser": "0.2.3", "postcss-scss": "2.1.1", "postcss-selector-parser": "2.2.3", "postcss-values-parser": "2.0.1", "regexp-util": "1.2.2", "remark-footnotes": "2.0.0", "remark-math": "1.0.6", "remark-parse": "8.0.3", resolve: "1.17.0", semver: "7.3.2", "string-width": "4.2.0", typescript: "4.0.2", "unicode-regex": "3.0.0", unified: "9.2.0", vnopts: "1.0.2", "yaml-unist-parser": "1.3.1"}, ct = {"@babel/core": "7.11.4", "@babel/preset-env": "7.11.0", "@babel/types": "7.11.0", "@glimmer/reference": "0.59.0", "@rollup/plugin-alias": "3.1.1", "@rollup/plugin-babel": "5.2.0", "@rollup/plugin-commonjs": "14.0.0", "@rollup/plugin-json": "4.1.0", "@rollup/plugin-node-resolve": "9.0.0", "@rollup/plugin-replace": "2.3.3", "@types/estree": "0.0.45", "@types/node": "14.6.0", "@typescript-eslint/types": "3.10.0", "babel-loader": "8.1.0", benchmark: "2.1.4", "builtin-modules": "3.1.0", "cross-env": "7.0.2", cspell: "4.1.0", eslint: "7.7.0", "eslint-config-prettier": "6.11.0", "eslint-formatter-friendly": "7.0.0", "eslint-plugin-import": "2.22.0", "eslint-plugin-jest": "23.20.0", "eslint-plugin-prettier-internal-rules": "file:scripts/tools/eslint-plugin-prettier-internal-rules", "eslint-plugin-react": "7.20.6", "eslint-plugin-unicorn": "21.0.0", execa: "4.0.3", jest: "26.4.2", "jest-snapshot-serializer-ansi": "1.0.0", "jest-snapshot-serializer-raw": "1.1.0", "jest-watch-typeahead": "0.6.0", "npm-run-all": "4.1.5", prettier: "2.1.1", rimraf: "3.0.2", rollup: "2.26.5", "rollup-plugin-node-globals": "1.4.0", "rollup-plugin-terser": "7.0.0", shelljs: "0.8.4", "snapshot-diff": "0.8.1", "strip-ansi": "6.0.0", "synchronous-promise": "2.0.13", tempy: "0.6.0", "terser-webpack-plugin": "4.1.0", webpack: "4.44.1"}, pt = {prepublishOnly: 'echo "Error: must publish from dist/" && exit 1', "prepare-release": "yarn && yarn build && yarn test:dist", test: "jest", "test:dev-package": "cross-env INSTALL_PACKAGE=1 jest", "test:dist": "cross-env NODE_ENV=production jest", "test:dist-standalone": "cross-env NODE_ENV=production TEST_STANDALONE=1 jest", "test:integration": "jest tests_integration", "perf:repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", "perf:repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", "perf:benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", lint: "run-p lint:*", "lint:typecheck": "tsc", "lint:eslint": "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly", "lint:changelog": "node ./scripts/lint-changelog.js", "lint:prettier": 'prettier . "!test*" --check', "lint:dist": 'eslint --no-eslintrc --no-ignore --env=es6,browser --parser-options=ecmaVersion:2016 "dist/!(bin-prettier|index|third-party).js"', "lint:spellcheck": 'cspell "**/*" ".github/**/*"', "lint:deps": "node ./scripts/check-deps.js", fix: "run-s fix:eslint fix:prettier", "fix:eslint": "yarn lint:eslint --fix", "fix:prettier": "yarn lint:prettier --write", build: "node ./scripts/build/build.js", "build-docs": "node ./scripts/build-docs.js"}, ut = {name: "prettier", version: "2.1.2", description: rt, bin: at, repository: "prettier/prettier", homepage: "https://prettier.io", author: "James Long", license: "MIT", main: "./index.js", browser: "./standalone.js", unpkg: "./standalone.js", engines: nt, files: ot, dependencies: ht, devDependencies: ct, scripts: pt}, lt = Object.freeze({__proto__: null, name: "prettier", version: "2.1.2", description: rt, bin: at, repository: "prettier/prettier", homepage: "https://prettier.io", author: "James Long", license: "MIT", main: "./index.js", browser: "./standalone.js", unpkg: "./standalone.js", engines: nt, files: ot, dependencies: ht, devDependencies: ct, scripts: pt, default: ut}), dt = e(function(t2, e2) {
        function s2() {
          for (var t3 = [], e3 = 0; e3 < arguments.length; e3++)
            t3[e3] = arguments[e3];
        }
        function i2() {
          return typeof WeakMap != "undefined" ? new WeakMap() : {add: s2, delete: s2, get: s2, set: s2, has: function(t3) {
            return false;
          }};
        }
        Object.defineProperty(e2, "__esModule", {value: true});
        var r2 = Object.prototype.hasOwnProperty, a2 = function(t3, e3) {
          return r2.call(t3, e3);
        };
        function n2(t3, e3) {
          for (var s3 in e3)
            a2(e3, s3) && (t3[s3] = e3[s3]);
          return t3;
        }
        var o2 = /^[ \t]*(?:\r\n|\r|\n)/, h2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, p2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, u2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function l2(t3, e3, s3) {
          var i3 = 0, r3 = t3[0].match(p2);
          r3 && (i3 = r3[1].length);
          var a3 = new RegExp("(\\r\\n|\\r|\\n).{0," + i3 + "}", "g");
          e3 && (t3 = t3.slice(1));
          var n3 = s3.newline, c3 = s3.trimLeadingNewline, u3 = s3.trimTrailingNewline, l3 = typeof n3 == "string", d3 = t3.length;
          return t3.map(function(t4, e4) {
            return t4 = t4.replace(a3, "$1"), e4 === 0 && c3 && (t4 = t4.replace(o2, "")), e4 === d3 - 1 && u3 && (t4 = t4.replace(h2, "")), l3 && (t4 = t4.replace(/\r\n|\n|\r/g, function(t5) {
              return n3;
            })), t4;
          });
        }
        function d2(t3, e3) {
          for (var s3 = "", i3 = 0, r3 = t3.length; i3 < r3; i3++)
            s3 += t3[i3], i3 < r3 - 1 && (s3 += e3[i3]);
          return s3;
        }
        function m2(t3) {
          return a2(t3, "raw") && a2(t3, "length");
        }
        var f2 = function t3(e3) {
          var s3 = i2(), r3 = i2();
          return n2(function i3(a3) {
            for (var o3 = [], h3 = 1; h3 < arguments.length; h3++)
              o3[h3 - 1] = arguments[h3];
            if (m2(a3)) {
              var p3 = a3, D2 = (o3[0] === i3 || o3[0] === f2) && u2.test(p3[0]) && c2.test(p3[1]), y2 = D2 ? r3 : s3, x2 = y2.get(p3);
              if (x2 || (x2 = l2(p3, D2, e3), y2.set(p3, x2)), o3.length === 0)
                return x2[0];
              var g2 = d2(x2, D2 ? o3.slice(1) : o3);
              return g2;
            }
            return t3(n2(n2({}, e3), a3 || {}));
          }, {string: function(t4) {
            return l2([t4], false, e3)[0];
          }});
        }({trimLeadingNewline: true, trimTrailingNewline: true});
        e2.outdent = f2, e2.default = f2;
        try {
          t2.exports = f2, Object.defineProperty(f2, "__esModule", {value: true}), f2.default = f2, f2.outdent = f2;
        } catch (t3) {
        }
      });
      function mt() {
        const t2 = D(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]);
        return mt = function() {
          return t2;
        }, t2;
      }
      function ft() {
        const t2 = D(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]);
        return ft = function() {
          return t2;
        }, t2;
      }
      function Dt() {
        const t2 = D(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]);
        return Dt = function() {
          return t2;
        }, t2;
      }
      function yt() {
        const t2 = D(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]);
        return yt = function() {
          return t2;
        }, t2;
      }
      function xt() {
        const t2 = D(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]);
        return xt = function() {
          return t2;
        }, t2;
      }
      function gt() {
        const t2 = D(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]);
        return gt = function() {
          return t2;
        }, t2;
      }
      const {outdent: Et} = dt;
      var Pt = {CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: {cursorOffset: {since: "1.4.0", category: "Special", type: "int", default: -1, range: {start: -1, end: 1 / 0, step: 1}, description: Et(gt()), cliCategory: "Editor"}, endOfLine: {since: "1.15.0", category: "Global", type: "choice", default: [{since: "1.15.0", value: "auto"}, {since: "2.0.0", value: "lf"}], description: "Which end of line characters to apply.", choices: [{value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"}, {value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"}, {value: "cr", description: "Carriage Return character only (\\r), used very rarely"}, {value: "auto", description: Et(xt())}]}, filepath: {since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from."}, insertPragma: {since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other"}, parser: {since: "0.0.10", category: "Global", type: "choice", default: [{since: "0.0.10", value: "babylon"}, {since: "1.13.0", value: void 0}], description: "Which parser to use.", exception: (t2) => typeof t2 == "string" || typeof t2 == "function", choices: [{value: "flow", description: "Flow"}, {value: "babel", since: "1.16.0", description: "JavaScript"}, {value: "babel-flow", since: "1.16.0", description: "Flow"}, {value: "babel-ts", since: "2.0.0", description: "TypeScript"}, {value: "typescript", since: "1.4.0", description: "TypeScript"}, {value: "css", since: "1.7.1", description: "CSS"}, {value: "less", since: "1.7.1", description: "Less"}, {value: "scss", since: "1.7.1", description: "SCSS"}, {value: "json", since: "1.5.0", description: "JSON"}, {value: "json5", since: "1.13.0", description: "JSON5"}, {value: "json-stringify", since: "1.13.0", description: "JSON.stringify"}, {value: "graphql", since: "1.5.0", description: "GraphQL"}, {value: "markdown", since: "1.8.0", description: "Markdown"}, {value: "mdx", since: "1.15.0", description: "MDX"}, {value: "vue", since: "1.10.0", description: "Vue"}, {value: "yaml", since: "1.14.0", description: "YAML"}, {value: "glimmer", since: null, description: "Handlebars"}, {value: "html", since: "1.15.0", description: "HTML"}, {value: "angular", since: "1.15.0", description: "Angular"}, {value: "lwc", since: "1.17.0", description: "Lightning Web Components"}]}, plugins: {since: "1.10.0", type: "path", array: true, default: [{value: []}], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t2) => typeof t2 == "string" || typeof t2 == "object", cliName: "plugin", cliCategory: "Config"}, pluginSearchDirs: {since: "1.13.0", type: "path", array: true, default: [{value: []}], category: "Global", description: Et(yt()), exception: (t2) => typeof t2 == "string" || typeof t2 == "object", cliName: "plugin-search-dir", cliCategory: "Config"}, printWidth: {since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: {start: 0, end: 1 / 0, step: 1}}, rangeEnd: {since: "1.4.0", category: "Special", type: "int", default: 1 / 0, range: {start: 0, end: 1 / 0, step: 1}, description: Et(Dt()), cliCategory: "Editor"}, rangeStart: {since: "1.4.0", category: "Special", type: "int", default: 0, range: {start: 0, end: 1 / 0, step: 1}, description: Et(ft()), cliCategory: "Editor"}, requirePragma: {since: "1.7.0", category: "Special", type: "boolean", default: false, description: Et(mt()), cliCategory: "Other"}, tabWidth: {type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: {start: 0, end: 1 / 0, step: 1}}, useTabs: {since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces."}, embeddedLanguageFormatting: {since: "2.1.0", category: "Global", type: "choice", default: [{since: "2.1.0", value: "auto"}], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{value: "auto", description: "Format embedded code if Prettier can automatically identify it."}, {value: "off", description: "Never automatically format embedded code."}]}}}, bt = s(lt);
      const Ct = {compare: et, lt: st, gte: it}, Tt = bt.version, At = Pt.options;
      var wt = {getSupportInfo: function({plugins: t2 = [], showUnreleased: e2 = false, showDeprecated: s2 = false, showInternal: i2 = false} = {}) {
        const r2 = Tt.split("-", 1)[0], a2 = t2.reduce((t3, e3) => t3.concat(e3.languages || []), []).filter(c2), n2 = (o2 = Object.assign({}, ...t2.map(({options: t3}) => t3), At), h2 = "name", Object.entries(o2).map(([t3, e3]) => Object.assign({[h2]: t3}, e3))).filter((t3) => c2(t3) && p2(t3)).sort((t3, e3) => t3.name === e3.name ? 0 : t3.name < e3.name ? -1 : 1).map(function(t3) {
          if (i2)
            return t3;
          return function(t4, e3) {
            if (t4 == null)
              return {};
            var s3, i3, r3 = {}, a3 = Object.keys(t4);
            for (i3 = 0; i3 < a3.length; i3++)
              s3 = a3[i3], e3.indexOf(s3) >= 0 || (r3[s3] = t4[s3]);
            return r3;
          }(t3, ["cliName", "cliCategory", "cliDescription"]);
        }).map((e3) => {
          e3 = Object.assign({}, e3), Array.isArray(e3.default) && (e3.default = e3.default.length === 1 ? e3.default[0].value : e3.default.filter(c2).sort((t3, e4) => Ct.compare(e4.since, t3.since))[0].value), Array.isArray(e3.choices) && (e3.choices = e3.choices.filter((t3) => c2(t3) && p2(t3)), e3.name === "parser" && function(t3, e4, s4) {
            const i3 = new Set(t3.choices.map((t4) => t4.value));
            for (const r3 of e4)
              if (r3.parsers) {
                for (const e5 of r3.parsers)
                  if (!i3.has(e5)) {
                    i3.add(e5);
                    const a3 = s4.find((t4) => t4.parsers && t4.parsers[e5]);
                    let n3 = r3.name;
                    a3 && a3.name && (n3 += " (plugin: ".concat(a3.name, ")")), t3.choices.push({value: e5, description: n3});
                  }
              }
          }(e3, a2, t2));
          const s3 = t2.filter((t3) => t3.defaultOptions && t3.defaultOptions[e3.name] !== void 0).reduce((t3, s4) => (t3[s4.name] = s4.defaultOptions[e3.name], t3), {});
          return Object.assign({}, e3, {pluginDefaults: s3});
        });
        var o2, h2;
        return {languages: a2, options: n2};
        function c2(t3) {
          return e2 || !("since" in t3) || t3.since && Ct.gte(r2, t3.since);
        }
        function p2(t3) {
          return s2 || !("deprecated" in t3) || t3.deprecated && Ct.lt(r2, t3.deprecated);
        }
      }};
      const Nt = /[^\x20-\x7F]/;
      function St(t2) {
        return (e2, s2, i2) => {
          const r2 = i2 && i2.backwards;
          if (s2 === false)
            return false;
          const {length: a2} = e2;
          let n2 = s2;
          for (; n2 >= 0 && n2 < a2; ) {
            const s3 = e2.charAt(n2);
            if (t2 instanceof RegExp) {
              if (!t2.test(s3))
                return n2;
            } else if (!t2.includes(s3))
              return n2;
            r2 ? n2-- : n2++;
          }
          return (n2 === -1 || n2 === a2) && n2;
        };
      }
      const It = St(/\s/), Ft = St(" 	"), vt = St(",; 	"), kt = St(/[^\n\r]/);
      function Lt(t2, e2) {
        if (e2 === false)
          return false;
        if (t2.charAt(e2) === "/" && t2.charAt(e2 + 1) === "*") {
          for (let s2 = e2 + 2; s2 < t2.length; ++s2)
            if (t2.charAt(s2) === "*" && t2.charAt(s2 + 1) === "/")
              return s2 + 2;
        }
        return e2;
      }
      function Ot(t2, e2) {
        return e2 !== false && (t2.charAt(e2) === "/" && t2.charAt(e2 + 1) === "/" ? kt(t2, e2) : e2);
      }
      function Rt(t2, e2, s2) {
        const i2 = s2 && s2.backwards;
        if (e2 === false)
          return false;
        const r2 = t2.charAt(e2);
        if (i2) {
          if (t2.charAt(e2 - 1) === "\r" && r2 === "\n")
            return e2 - 2;
          if (r2 === "\n" || r2 === "\r" || r2 === "\u2028" || r2 === "\u2029")
            return e2 - 1;
        } else {
          if (r2 === "\r" && t2.charAt(e2 + 1) === "\n")
            return e2 + 2;
          if (r2 === "\n" || r2 === "\r" || r2 === "\u2028" || r2 === "\u2029")
            return e2 + 1;
        }
        return e2;
      }
      function Mt(t2, e2, s2) {
        const i2 = Ft(t2, (s2 = s2 || {}).backwards ? e2 - 1 : e2, s2);
        return i2 !== Rt(t2, i2, s2);
      }
      function Bt(t2, e2) {
        let s2 = null, i2 = e2;
        for (; i2 !== s2; )
          s2 = i2, i2 = vt(t2, i2), i2 = Lt(t2, i2), i2 = Ft(t2, i2);
        return i2 = Ot(t2, i2), i2 = Rt(t2, i2), i2 !== false && Mt(t2, i2);
      }
      function _t(t2, e2) {
        let s2 = null, i2 = e2;
        for (; i2 !== s2; )
          s2 = i2, i2 = Ft(t2, i2), i2 = Lt(t2, i2), i2 = Ot(t2, i2), i2 = Rt(t2, i2);
        return i2;
      }
      function jt(t2, e2, s2) {
        return _t(t2, s2(e2));
      }
      function Ut(t2, e2, s2) {
        let i2 = 0;
        for (let r2 = s2 = s2 || 0; r2 < t2.length; ++r2)
          t2[r2] === "	" ? i2 = i2 + e2 - i2 % e2 : i2++;
        return i2;
      }
      function qt(t2, e2) {
        const s2 = t2.slice(1, -1), i2 = {quote: '"', regex: /"/g}, r2 = {quote: "'", regex: /'/g}, a2 = e2 === "'" ? r2 : i2, n2 = a2 === r2 ? i2 : r2;
        let o2 = a2.quote;
        if (s2.includes(a2.quote) || s2.includes(n2.quote)) {
          o2 = (s2.match(a2.regex) || []).length > (s2.match(n2.regex) || []).length ? n2.quote : a2.quote;
        }
        return o2;
      }
      function Vt(t2, e2, s2) {
        const i2 = e2 === '"' ? "'" : '"', r2 = t2.replace(/\\([\S\s])|(["'])/g, (t3, r3, a2) => r3 === i2 ? r3 : a2 === e2 ? "\\" + a2 : a2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(r3) ? r3 : "\\" + r3));
        return e2 + r2 + e2;
      }
      function zt(t2) {
        return t2 && (t2.comments && t2.comments.length > 0 && t2.comments.some((t3) => Ht(t3) && !t3.unignore) || t2.prettierIgnore);
      }
      function Ht(t2) {
        return t2.value.trim() === "prettier-ignore";
      }
      function Gt(t2, e2) {
        (t2.comments || (t2.comments = [])).push(e2), e2.printed = false, t2.type === "JSXText" && (e2.printed = true);
      }
      var Wt = {replaceEndOfLineWith: function(t2, e2) {
        const s2 = [];
        for (const i2 of t2.split("\n"))
          s2.length !== 0 && s2.push(e2), s2.push(i2);
        return s2;
      }, getStringWidth: function(t2) {
        return t2 ? Nt.test(t2) ? d(t2) : t2.length : 0;
      }, getMaxContinuousCount: function(t2, e2) {
        const s2 = t2.match(new RegExp("(".concat(f(e2), ")+"), "g"));
        return s2 === null ? 0 : s2.reduce((t3, s3) => Math.max(t3, s3.length / e2.length), 0);
      }, getMinNotPresentContinuousCount: function(t2, e2) {
        const s2 = t2.match(new RegExp("(".concat(f(e2), ")+"), "g"));
        if (s2 === null)
          return 0;
        const i2 = new Map();
        let r2 = 0;
        for (const t3 of s2) {
          const s3 = t3.length / e2.length;
          i2.set(s3, true), s3 > r2 && (r2 = s3);
        }
        for (let t3 = 1; t3 < r2; t3++)
          if (!i2.get(t3))
            return t3;
        return r2 + 1;
      }, getParserName: function(t2, e2) {
        const s2 = wt.getSupportInfo({plugins: e2.plugins}).languages.find((e3) => e3.name.toLowerCase() === t2 || e3.aliases && e3.aliases.includes(t2) || e3.extensions && e3.extensions.some((e4) => e4 === ".".concat(t2)));
        return s2 ? s2.parsers[0] : null;
      }, getPenultimate: (t2) => t2[t2.length - 2], getLast: (t2) => t2[t2.length - 1], getNextNonSpaceNonCommentCharacterIndexWithStartIndex: _t, getNextNonSpaceNonCommentCharacterIndex: jt, getNextNonSpaceNonCommentCharacter: function(t2, e2, s2) {
        return t2.charAt(jt(t2, e2, s2));
      }, skip: St, skipWhitespace: It, skipSpaces: Ft, skipToLineEnd: vt, skipEverythingButNewLine: kt, skipInlineComment: Lt, skipTrailingComment: Ot, skipNewline: Rt, isNextLineEmptyAfterIndex: Bt, isNextLineEmpty: function(t2, e2, s2) {
        return Bt(t2, s2(e2));
      }, isPreviousLineEmpty: function(t2, e2, s2) {
        let i2 = s2(e2) - 1;
        return i2 = Ft(t2, i2, {backwards: true}), i2 = Rt(t2, i2, {backwards: true}), i2 = Ft(t2, i2, {backwards: true}), i2 !== Rt(t2, i2, {backwards: true});
      }, hasNewline: Mt, hasNewlineInRange: function(t2, e2, s2) {
        for (let i2 = e2; i2 < s2; ++i2)
          if (t2.charAt(i2) === "\n")
            return true;
        return false;
      }, hasSpaces: function(t2, e2, s2) {
        return Ft(t2, (s2 = s2 || {}).backwards ? e2 - 1 : e2, s2) !== e2;
      }, getAlignmentSize: Ut, getIndentSize: function(t2, e2) {
        const s2 = t2.lastIndexOf("\n");
        return s2 === -1 ? 0 : Ut(t2.slice(s2 + 1).match(/^[\t ]*/)[0], e2);
      }, getPreferredQuote: qt, printString: function(t2, e2, s2) {
        const i2 = t2.slice(1, -1), r2 = !i2.includes('"') && !i2.includes("'"), a2 = e2.parser === "json" ? '"' : e2.__isInHtmlAttribute ? "'" : qt(t2, e2.singleQuote ? "'" : '"');
        return s2 ? r2 ? a2 + i2 + a2 : t2 : Vt(i2, a2, !(e2.parser === "css" || e2.parser === "less" || e2.parser === "scss" || e2.embeddedInHtml));
      }, printNumber: function(t2) {
        return t2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
      }, hasIgnoreComment: function(t2) {
        return zt(t2.getValue());
      }, hasNodeIgnoreComment: zt, isNodeIgnoreComment: Ht, makeString: Vt, addLeadingComment: function(t2, e2) {
        e2.leading = true, e2.trailing = false, Gt(t2, e2);
      }, addDanglingComment: function(t2, e2, s2) {
        e2.leading = false, e2.trailing = false, s2 && (e2.marker = s2), Gt(t2, e2);
      }, addTrailingComment: function(t2, e2) {
        e2.leading = false, e2.trailing = true, Gt(t2, e2);
      }, isWithinParentArrayProperty: function(t2, e2) {
        const s2 = t2.getValue(), i2 = t2.getParentNode();
        if (i2 == null)
          return false;
        if (!Array.isArray(i2[e2]))
          return false;
        const r2 = t2.getName();
        return i2[e2][r2] === s2;
      }, isFrontMatterNode: function(t2) {
        return t2 && t2.type === "front-matter";
      }, getShebang: function(t2) {
        if (!t2.startsWith("#!"))
          return "";
        const e2 = t2.indexOf("\n");
        return e2 === -1 ? t2 : t2.slice(0, e2);
      }};
      var Xt = {guessEndOfLine: function(t2) {
        const e2 = t2.indexOf("\r");
        return e2 >= 0 ? t2.charAt(e2 + 1) === "\n" ? "crlf" : "cr" : "lf";
      }, convertEndOfLineToChars: function(t2) {
        switch (t2) {
          case "cr":
            return "\r";
          case "crlf":
            return "\r\n";
          default:
            return "\n";
        }
      }, countEndOfLineChars: function(t2, e2) {
        let s2;
        if (e2 === "\n")
          s2 = /\n/g;
        else if (e2 === "\r")
          s2 = /\r/g;
        else {
          if (e2 !== "\r\n")
            throw new Error('Unexpected "eol" '.concat(JSON.stringify(e2), "."));
          s2 = /\r\n/g;
        }
        const i2 = t2.match(s2);
        return i2 ? i2.length : 0;
      }, normalizeEndOfLine: function(t2) {
        return t2.replace(/\r\n?/g, "\n");
      }};
      const {parseWithComments: Kt, strip: $t, extract: Jt, print: Yt} = o, {getShebang: Qt} = Wt, {normalizeEndOfLine: Zt} = Xt;
      function te(t2) {
        const e2 = Qt(t2);
        e2 && (t2 = t2.slice(e2.length + 1));
        const s2 = Jt(t2), {pragmas: i2, comments: r2} = Kt(s2);
        return {shebang: e2, text: t2, pragmas: i2, comments: r2};
      }
      var ee = {hasPragma: function(t2) {
        const e2 = Object.keys(te(t2).pragmas);
        return e2.includes("prettier") || e2.includes("format");
      }, insertPragma: function(t2) {
        const {shebang: e2, text: s2, pragmas: i2, comments: r2} = te(t2), a2 = $t(s2), n2 = Yt({pragmas: Object.assign({format: ""}, i2), comments: r2.trimStart()});
        return (e2 ? "".concat(e2, "\n") : "") + Zt(n2) + (a2.startsWith("\n") ? "\n" : "\n\n") + a2;
      }};
      function se(t2, e2) {
        const {ignoreDecorators: s2} = e2 || {};
        if (!s2) {
          const e3 = t2.declaration && t2.declaration.decorators || t2.decorators;
          if (e3 && e3.length > 0)
            return se(e3[0]);
        }
        return t2.range ? t2.range[0] : t2.start;
      }
      function ie(t2) {
        const e2 = t2.range ? t2.range[1] : t2.end;
        return t2.typeAnnotation ? Math.max(e2, ie(t2.typeAnnotation)) : e2;
      }
      var re = {locStart: se, locEnd: ie, composeLoc: function(t2, e2 = t2) {
        const s2 = se(t2);
        return [s2, typeof e2 == "number" ? s2 + e2 : ie(e2)];
      }};
      const {getLast: ae, hasNewline: ne, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: oe, getNextNonSpaceNonCommentCharacter: he, hasNewlineInRange: ce, isNodeIgnoreComment: pe, addLeadingComment: ue, addTrailingComment: le, addDanglingComment: de, getNextNonSpaceNonCommentCharacterIndex: me} = Wt;
      function fe(t2, e2) {
        const s2 = (t2.body || t2.properties).filter((t3) => t3.type !== "EmptyStatement");
        s2.length === 0 ? de(t2, e2) : ue(s2[0], e2);
      }
      function De(t2, e2) {
        t2.type === "BlockStatement" ? fe(t2, e2) : ue(t2, e2);
      }
      function ye(t2, e2, s2, i2, r2, a2) {
        if (!s2 || s2.type !== "IfStatement" || !i2)
          return false;
        return he(t2, r2, a2.locEnd) === ")" ? (le(e2, r2), true) : e2 === s2.consequent && i2 === s2.alternate ? (e2.type === "BlockStatement" ? le(e2, r2) : de(s2, r2), true) : i2.type === "BlockStatement" ? (fe(i2, r2), true) : i2.type === "IfStatement" ? (De(i2.consequent, r2), true) : s2.consequent === i2 && (ue(i2, r2), true);
      }
      function xe(t2, e2, s2, i2, r2, a2) {
        if (!s2 || s2.type !== "WhileStatement" || !i2)
          return false;
        return he(t2, r2, a2.locEnd) === ")" ? (le(e2, r2), true) : i2.type === "BlockStatement" && (fe(i2, r2), true);
      }
      function ge(t2, e2, s2, i2) {
        return !(!t2 || t2.type !== "TryStatement" && t2.type !== "CatchClause" || !s2) && (t2.type === "CatchClause" && e2 ? (le(e2, i2), true) : s2.type === "BlockStatement" ? (fe(s2, i2), true) : s2.type === "TryStatement" ? (De(s2.finalizer, i2), true) : s2.type === "CatchClause" && (De(s2.body, i2), true));
      }
      function Ee(t2, e2, s2, i2) {
        if (t2 && (t2.type === "ClassDeclaration" || t2.type === "ClassExpression" || t2.type === "DeclareClass" || t2.type === "DeclareInterface" || t2.type === "InterfaceDeclaration" || t2.type === "TSInterfaceDeclaration")) {
          if (t2.decorators && t2.decorators.length > 0 && (!s2 || s2.type !== "Decorator"))
            return le(t2.decorators[t2.decorators.length - 1], i2), true;
          if (t2.body && s2 === t2.body)
            return fe(t2.body, i2), true;
          if (s2) {
            for (const r2 of ["implements", "extends", "mixins"])
              if (t2[r2] && s2 === t2[r2][0])
                return !e2 || e2 !== t2.id && e2 !== t2.typeParameters && e2 !== t2.superClass ? de(t2, i2, r2) : le(e2, i2), true;
          }
        }
        return false;
      }
      function Pe(t2, e2, s2, i2, r2) {
        return (e2 && s2 && (e2.type === "Property" || e2.type === "TSDeclareMethod" || e2.type === "TSAbstractMethodDefinition") && s2.type === "Identifier" && e2.key === s2 && he(t2, s2, r2.locEnd) !== ":" || !(!s2 || !e2 || s2.type !== "Decorator" || e2.type !== "ClassMethod" && e2.type !== "ClassProperty" && e2.type !== "TSAbstractClassProperty" && e2.type !== "TSAbstractMethodDefinition" && e2.type !== "TSDeclareMethod" && e2.type !== "MethodDefinition")) && (le(s2, i2), true);
      }
      function be(t2, e2, s2, i2, r2, a2) {
        if (e2 && e2.type === "FunctionTypeParam" && s2 && s2.type === "FunctionTypeAnnotation" && i2 && i2.type !== "FunctionTypeParam")
          return le(e2, r2), true;
        if (e2 && (e2.type === "Identifier" || e2.type === "AssignmentPattern") && s2 && Ne(s2) && he(t2, r2, a2.locEnd) === ")")
          return le(e2, r2), true;
        if (s2 && s2.type === "FunctionDeclaration" && i2 && i2.type === "BlockStatement") {
          const e3 = (() => {
            if ((s2.params || s2.parameters).length !== 0)
              return oe(t2, a2.locEnd(ae(s2.params || s2.parameters)));
            const e4 = oe(t2, a2.locEnd(s2.id));
            return e4 !== false && oe(t2, e4 + 1);
          })();
          if (a2.locStart(r2) > e3)
            return fe(i2, r2), true;
        }
        return false;
      }
      function Ce(t2, e2) {
        return !(!t2 || t2.type !== "ImportSpecifier") && (ue(t2, e2), true);
      }
      function Te(t2, e2) {
        return !(!t2 || t2.type !== "LabeledStatement") && (ue(t2, e2), true);
      }
      function Ae(t2, e2, s2, i2) {
        return e2 && e2.body && e2.body.length === 0 ? (i2 ? de(e2, s2) : ue(e2, s2), true) : !(!t2 || t2.type !== "Program" || t2.body.length !== 0 || !t2.directives || t2.directives.length !== 0) && (i2 ? de(t2, s2) : ue(t2, s2), true);
      }
      function we(t2) {
        return t2.type === "Block" || t2.type === "CommentBlock";
      }
      function Ne(t2) {
        return t2.type === "ArrowFunctionExpression" || t2.type === "FunctionExpression" || t2.type === "FunctionDeclaration" || t2.type === "ObjectMethod" || t2.type === "ClassMethod" || t2.type === "TSDeclareFunction" || t2.type === "TSCallSignatureDeclaration" || t2.type === "TSConstructSignatureDeclaration" || t2.type === "TSConstructSignatureDeclaration" || t2.type === "TSMethodSignature" || t2.type === "TSConstructorType" || t2.type === "TSFunctionType" || t2.type === "TSDeclareMethod";
      }
      function Se(t2) {
        return we(t2) && t2.value[0] === "*" && /@type\b/.test(t2.value);
      }
      var Ie = {handleOwnLineComment: function(t2, e2, s2, i2, r2) {
        const {precedingNode: a2, enclosingNode: n2, followingNode: o2} = t2;
        return be(e2, a2, n2, o2, t2, s2) || function(t3, e3, s3) {
          if (t3 && (t3.type === "MemberExpression" || t3.type === "OptionalMemberExpression") && e3 && e3.type === "Identifier")
            return ue(t3, s3), true;
          return false;
        }(n2, o2, t2) || ye(e2, a2, n2, o2, t2, s2) || xe(e2, a2, n2, o2, t2, s2) || ge(n2, a2, o2, t2) || Ee(n2, a2, o2, t2) || Ce(n2, t2) || function(t3, e3, s3) {
          if (t3 && (t3.type === "ForInStatement" || t3.type === "ForOfStatement"))
            return ue(t3, s3), true;
          return false;
        }(n2, 0, t2) || function(t3, e3, s3, i3) {
          if (e3 && (e3.type === "UnionTypeAnnotation" || e3.type === "TSUnionType"))
            return pe(i3) && (s3.prettierIgnore = true, i3.unignore = true), !!t3 && (le(t3, i3), true);
          s3 && (s3.type === "UnionTypeAnnotation" || s3.type === "TSUnionType") && pe(i3) && (s3.types[0].prettierIgnore = true, i3.unignore = true);
          return false;
        }(a2, n2, o2, t2) || Ae(n2, i2, t2, r2) || function(t3, e3, s3, i3, r3) {
          if (s3 && s3.type === "ImportSpecifier" && e3 && e3.type === "ImportDeclaration" && ne(t3, r3.locEnd(i3)))
            return le(s3, i3), true;
          return false;
        }(e2, n2, a2, t2, s2) || function(t3, e3) {
          if (t3 && t3.type === "AssignmentPattern")
            return ue(t3, e3), true;
          return false;
        }(n2, t2) || Pe(e2, n2, a2, t2, s2) || Te(n2, t2);
      }, handleEndOfLineComment: function(t2, e2, s2, i2, r2) {
        const {precedingNode: a2, enclosingNode: n2, followingNode: o2} = t2;
        return function(t3, e3) {
          if (t3 && Se(e3))
            return ue(t3, e3), true;
          return false;
        }(o2, t2) || be(e2, a2, n2, o2, t2, s2) || function(t3, e3, s3, i3, r3, a3) {
          const n3 = e3 && !ce(r3, a3.locEnd(e3), a3.locStart(i3));
          if ((!e3 || !n3) && t3 && (t3.type === "ConditionalExpression" || t3.type === "TSConditionalType") && s3)
            return ue(s3, i3), true;
          return false;
        }(n2, a2, o2, t2, e2, s2) || Ce(n2, t2) || ye(e2, a2, n2, o2, t2, s2) || xe(e2, a2, n2, o2, t2, s2) || ge(n2, a2, o2, t2) || Ee(n2, a2, o2, t2) || Te(n2, t2) || function(t3, e3, s3) {
          if (e3 && (e3.type === "CallExpression" || e3.type === "OptionalCallExpression") && t3 && e3.callee === t3 && e3.arguments.length > 0)
            return ue(e3.arguments[0], s3), true;
          return false;
        }(a2, n2, t2) || function(t3, e3) {
          if (t3 && (t3.type === "Property" || t3.type === "ObjectProperty"))
            return ue(t3, e3), true;
          return false;
        }(n2, t2) || Ae(n2, i2, t2, r2) || function(t3, e3, s3) {
          if (t3 && t3.type === "TypeAlias")
            return ue(t3, s3), true;
          return false;
        }(n2, 0, t2) || function(t3, e3, s3) {
          if (t3 && (t3.type === "VariableDeclarator" || t3.type === "AssignmentExpression") && e3 && (e3.type === "ObjectExpression" || e3.type === "ArrayExpression" || e3.type === "TemplateLiteral" || e3.type === "TaggedTemplateExpression" || we(s3)))
            return ue(e3, s3), true;
          return false;
        }(n2, o2, t2);
      }, handleRemainingComment: function(t2, e2, s2, i2, r2) {
        const {precedingNode: a2, enclosingNode: n2, followingNode: o2} = t2;
        return !!(ye(e2, a2, n2, o2, t2, s2) || xe(e2, a2, n2, o2, t2, s2) || function(t3, e3, s3) {
          if (t3 && (t3.type === "ObjectProperty" || t3.type === "Property") && t3.shorthand && t3.key === e3 && t3.value.type === "AssignmentPattern")
            return le(t3.value.left, s3), true;
          return false;
        }(n2, a2, t2) || function(t3, e3, s3, i3) {
          if (he(t3, s3, i3.locEnd) !== ")")
            return false;
          if (e3 && (Ne(e3) && (e3.params || e3.parameters).length === 0 || (e3.type === "CallExpression" || e3.type === "OptionalCallExpression" || e3.type === "NewExpression") && e3.arguments.length === 0))
            return de(e3, s3), true;
          if (e3 && e3.type === "MethodDefinition" && e3.value.params.length === 0)
            return de(e3.value, s3), true;
          return false;
        }(e2, n2, t2, s2) || Pe(e2, n2, a2, t2, s2) || Ae(n2, i2, t2, r2) || function(t3, e3, s3, i3) {
          if (!e3 || e3.type !== "ArrowFunctionExpression")
            return false;
          const r3 = me(t3, s3, i3.locEnd);
          if (r3 !== false && t3.slice(r3, r3 + 2) === "=>")
            return de(e3, s3), true;
          return false;
        }(e2, n2, t2, s2) || function(t3, e3, s3, i3, r3) {
          if (he(t3, i3, r3.locEnd) !== "(")
            return false;
          if (s3 && e3 && (e3.type === "FunctionDeclaration" || e3.type === "FunctionExpression" || e3.type === "ClassMethod" || e3.type === "MethodDefinition" || e3.type === "ObjectMethod"))
            return le(s3, i3), true;
          return false;
        }(e2, n2, a2, t2, s2) || function(t3, e3, s3, i3, r3) {
          if (!e3 || e3.type !== "TSMappedType")
            return false;
          if (i3 && i3.type === "TSTypeParameter" && i3.name)
            return ue(i3.name, r3), true;
          if (s3 && s3.type === "TSTypeParameter" && s3.constraint)
            return le(s3.constraint, r3), true;
          return false;
        }(0, n2, a2, o2, t2) || function(t3, e3) {
          if (t3 && (t3.type === "ContinueStatement" || t3.type === "BreakStatement") && !t3.label)
            return le(t3, e3), true;
          return false;
        }(n2, t2) || function(t3, e3, s3, i3, r3) {
          if (!s3 && e3 && (e3.type === "TSMethodSignature" || e3.type === "TSDeclareFunction" || e3.type === "TSAbstractMethodDefinition") && he(t3, i3, r3.locEnd) === ";")
            return le(e3, i3), true;
          return false;
        }(e2, n2, o2, t2, s2));
      }, hasLeadingComment: function(t2, e2 = () => true) {
        return t2.leadingComments ? t2.leadingComments.some(e2) : !!t2.comments && t2.comments.some((t3) => t3.leading && e2(t3));
      }, isBlockComment: we, isTypeCastComment: Se, getGapRegex: function(t2) {
        if (t2 && t2.type !== "BinaryExpression" && t2.type !== "LogicalExpression")
          return /^[\s&(|]*$/;
      }, getCommentChildNodes: function(t2, e2) {
        if ((e2.parser === "typescript" || e2.parser === "flow") && t2.type === "MethodDefinition" && t2.value && t2.value.type === "FunctionExpression" && t2.value.params.length === 0 && !t2.value.returnType && (!t2.value.typeParameters || t2.value.typeParameters.length === 0) && t2.value.body)
          return [...t2.decorators || [], t2.key, t2.value.body];
      }};
      const {getLast: Fe, getNextNonSpaceNonCommentCharacter: ve, getShebang: ke} = Wt, {composeLoc: Le, locStart: Oe, locEnd: Re} = re, {isTypeCastComment: Me} = Ie;
      function Be(t2, e2) {
        let s2;
        if (Array.isArray(t2))
          s2 = t2.entries();
        else {
          if (!t2 || typeof t2 != "object" || typeof t2.type != "string")
            return t2;
          s2 = Object.entries(t2);
        }
        for (const [i2, r2] of s2)
          t2[i2] = Be(r2, e2);
        return e2(t2) || t2;
      }
      function _e(t2) {
        return t2.type === "LogicalExpression" && t2.right.type === "LogicalExpression" && t2.operator === t2.right.operator;
      }
      var je = function(t2, e2) {
        if (e2.parser !== "typescript" && e2.parser !== "flow" || function(t3, e3) {
          const s2 = ke(e3.originalText);
          s2 && t3.comments.unshift({type: "Line", value: s2.slice(2), range: [0, s2.length]});
        }(t2, e2), e2.parser !== "typescript" && e2.parser !== "flow") {
          const e3 = new Set();
          t2 = Be(t2, (t3) => {
            t3.leadingComments && t3.leadingComments.some(Me) && e3.add(Oe(t3));
          }), t2 = Be(t2, (t3) => {
            if (t3.type === "ParenthesizedExpression") {
              const s2 = Oe(t3);
              if (!e3.has(s2)) {
                const {expression: e4} = t3;
                return e4.extra || (e4.extra = {}), e4.extra.parenthesized = true, e4.extra.parenStart = s2, e4;
              }
            }
          });
        }
        return t2 = Be(t2, (t3) => {
          switch (t3.type) {
            case "LogicalExpression":
              if (_e(t3))
                return function t4(e3) {
                  if (!_e(e3))
                    return e3;
                  return t4({type: "LogicalExpression", operator: e3.operator, left: t4({type: "LogicalExpression", operator: e3.operator, left: e3.left, right: e3.right.left, range: Le(e3.left, e3.right.left)}), right: e3.right.right, range: Le(e3)});
                }(t3);
              break;
            case "VariableDeclaration": {
              const s2 = Fe(t3.declarations);
              s2 && s2.init && function(t4, s3) {
                if (e2.originalText[Re(s3)] === ";")
                  return;
                t4.range = Le(t4, s3);
              }(t3, s2);
              break;
            }
            case "TSParenthesizedType":
              return t3.typeAnnotation.range = Le(t3), t3.typeAnnotation;
            case "TSUnionType":
            case "TSIntersectionType":
              if (t3.types.length === 1) {
                const [e3] = t3.types;
                return e3.range = Le(t3), e3;
              }
              break;
            case "TSTypeParameter":
              typeof t3.name == "string" && (t3.name = {type: "Identifier", name: t3.name, range: Le(t3, t3.name.length)});
              break;
            case "SequenceExpression": {
              const e3 = Fe(t3.expressions);
              Re(t3) > Re(e3) && (t3.range = Le(t3, e3));
              break;
            }
            case "ClassProperty":
              t3.key && t3.key.type === "TSPrivateIdentifier" && ve(e2.originalText, t3.key, Re) === "?" && (t3.optional = true);
          }
        });
      }, Ue = e(function(t2, e2) {
        Object.defineProperty(e2, "__esModule", {value: true});
        class s2 {
          constructor(t3, e3 = {}) {
            this.label = t3, this.keyword = e3.keyword, this.beforeExpr = !!e3.beforeExpr, this.startsExpr = !!e3.startsExpr, this.rightAssociative = !!e3.rightAssociative, this.isLoop = !!e3.isLoop, this.isAssign = !!e3.isAssign, this.prefix = !!e3.prefix, this.postfix = !!e3.postfix, this.binop = e3.binop != null ? e3.binop : null, this.updateContext = null;
          }
        }
        const i2 = new Map();
        function r2(t3, e3 = {}) {
          e3.keyword = t3;
          const r3 = new s2(t3, e3);
          return i2.set(t3, r3), r3;
        }
        function a2(t3, e3) {
          return new s2(t3, {beforeExpr: true, binop: e3});
        }
        const n2 = {num: new s2("num", {startsExpr: true}), bigint: new s2("bigint", {startsExpr: true}), decimal: new s2("decimal", {startsExpr: true}), regexp: new s2("regexp", {startsExpr: true}), string: new s2("string", {startsExpr: true}), name: new s2("name", {startsExpr: true}), eof: new s2("eof"), bracketL: new s2("[", {beforeExpr: true, startsExpr: true}), bracketHashL: new s2("#[", {beforeExpr: true, startsExpr: true}), bracketBarL: new s2("[|", {beforeExpr: true, startsExpr: true}), bracketR: new s2("]"), bracketBarR: new s2("|]"), braceL: new s2("{", {beforeExpr: true, startsExpr: true}), braceBarL: new s2("{|", {beforeExpr: true, startsExpr: true}), braceHashL: new s2("#{", {beforeExpr: true, startsExpr: true}), braceR: new s2("}"), braceBarR: new s2("|}"), parenL: new s2("(", {beforeExpr: true, startsExpr: true}), parenR: new s2(")"), comma: new s2(",", {beforeExpr: true}), semi: new s2(";", {beforeExpr: true}), colon: new s2(":", {beforeExpr: true}), doubleColon: new s2("::", {beforeExpr: true}), dot: new s2("."), question: new s2("?", {beforeExpr: true}), questionDot: new s2("?."), arrow: new s2("=>", {beforeExpr: true}), template: new s2("template"), ellipsis: new s2("...", {beforeExpr: true}), backQuote: new s2("`", {startsExpr: true}), dollarBraceL: new s2("${", {beforeExpr: true, startsExpr: true}), at: new s2("@"), hash: new s2("#", {startsExpr: true}), interpreterDirective: new s2("#!..."), eq: new s2("=", {beforeExpr: true, isAssign: true}), assign: new s2("_=", {beforeExpr: true, isAssign: true}), incDec: new s2("++/--", {prefix: true, postfix: true, startsExpr: true}), bang: new s2("!", {beforeExpr: true, prefix: true, startsExpr: true}), tilde: new s2("~", {beforeExpr: true, prefix: true, startsExpr: true}), pipeline: a2("|>", 0), nullishCoalescing: a2("??", 1), logicalOR: a2("||", 1), logicalAND: a2("&&", 2), bitwiseOR: a2("|", 3), bitwiseXOR: a2("^", 4), bitwiseAND: a2("&", 5), equality: a2("==/!=/===/!==", 6), relational: a2("</>/<=/>=", 7), bitShift: a2("<</>>/>>>", 8), plusMin: new s2("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}), modulo: new s2("%", {beforeExpr: true, binop: 10, startsExpr: true}), star: a2("*", 10), slash: a2("/", 10), exponent: new s2("**", {beforeExpr: true, binop: 11, rightAssociative: true}), _break: r2("break"), _case: r2("case", {beforeExpr: true}), _catch: r2("catch"), _continue: r2("continue"), _debugger: r2("debugger"), _default: r2("default", {beforeExpr: true}), _do: r2("do", {isLoop: true, beforeExpr: true}), _else: r2("else", {beforeExpr: true}), _finally: r2("finally"), _for: r2("for", {isLoop: true}), _function: r2("function", {startsExpr: true}), _if: r2("if"), _return: r2("return", {beforeExpr: true}), _switch: r2("switch"), _throw: r2("throw", {beforeExpr: true, prefix: true, startsExpr: true}), _try: r2("try"), _var: r2("var"), _const: r2("const"), _while: r2("while", {isLoop: true}), _with: r2("with"), _new: r2("new", {beforeExpr: true, startsExpr: true}), _this: r2("this", {startsExpr: true}), _super: r2("super", {startsExpr: true}), _class: r2("class", {startsExpr: true}), _extends: r2("extends", {beforeExpr: true}), _export: r2("export"), _import: r2("import", {startsExpr: true}), _null: r2("null", {startsExpr: true}), _true: r2("true", {startsExpr: true}), _false: r2("false", {startsExpr: true}), _in: r2("in", {beforeExpr: true, binop: 7}), _instanceof: r2("instanceof", {beforeExpr: true, binop: 7}), _typeof: r2("typeof", {beforeExpr: true, prefix: true, startsExpr: true}), _void: r2("void", {beforeExpr: true, prefix: true, startsExpr: true}), _delete: r2("delete", {beforeExpr: true, prefix: true, startsExpr: true})}, o2 = /\r\n?|[\n\u2028\u2029]/, h2 = new RegExp(o2.source, "g");
        function c2(t3) {
          switch (t3) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        const p2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        function u2(t3) {
          switch (t3) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        class l2 {
          constructor(t3, e3) {
            this.line = t3, this.column = e3;
          }
        }
        class d2 {
          constructor(t3, e3) {
            this.start = t3, this.end = e3;
          }
        }
        function m2(t3) {
          return t3[t3.length - 1];
        }
        const f2 = Object.freeze({ArgumentsDisallowedInInitializer: "'arguments' is not allowed in class field initializer", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function", AwaitExpressionFormalParameter: "await is not allowed in async function parameters", AwaitNotInAsyncFunction: "Can not use keyword 'await' outside an async function", BadGetterArity: "getter must not have any formal parameters", BadSetterArity: "setter must have exactly one formal parameter", BadSetterRestParameter: "setter function argument must not be a rest parameter", ConstructorClassField: "Classes may not have a field named 'constructor'", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'", ConstructorIsAccessor: "Class constructor may not be an accessor", ConstructorIsAsync: "Constructor can't be an async function", ConstructorIsGenerator: "Constructor can't be a generator", DeclarationMissingInitializer: "%0 require an initialization value", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon", DeletePrivateField: "Deleting a private field is not allowed", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property", DuplicateRegExpFlags: "Duplicate regular expression flag", ElementAfterRest: "Rest element must be last element", EscapedCharNotAnIdentifier: "Invalid Unicode escape", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'", ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block", IllegalBreakContinue: "Unsyntactic %0", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list", IllegalReturn: "'return' outside of function", ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments", ImportCallArity: "import() requires exactly %0", ImportCallNotNewExpression: "Cannot use new with import(...)", ImportCallSpreadArgument: "... is not allowed in import()", ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`, InvalidBigIntLiteral: "Invalid BigIntLiteral", InvalidCodePoint: "Code point out of bounds", InvalidDecimal: "Invalid decimal", InvalidDigit: "Expected number in radix %0", InvalidEscapeSequence: "Bad character escape sequence", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template", InvalidEscapedReservedWord: "Escape sequence in keyword %0", InvalidIdentifier: "Invalid identifier %0", InvalidLhs: "Invalid left-hand side in %0", InvalidLhsBinding: "Binding invalid left-hand side in %0", InvalidNumber: "Invalid number", InvalidOrUnexpectedToken: "Unexpected character '%0'", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern", InvalidPrivateFieldResolution: "Private name #%0 is not defined", InvalidPropertyBindingPattern: "Binding member expression", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions", InvalidRestAssignmentPattern: "Invalid rest operator's argument", LabelRedeclaration: "Label '%0' is already declared", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'", MalformedRegExpFlags: "Invalid regular expression flag", MissingClassName: "A class name is required", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes', ModuleExportUndefined: "Export '%0' is not defined", MultipleDefaultsInSwitch: "Multiple default clauses", NewlineAfterThrow: "Illegal newline after throw", NoCatchOrFinally: "Missing catch or finally clause", NumberIdentifier: "Identifier directly after number", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences", ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain", ParamDupe: "Argument name clash", PatternHasAccessor: "Object pattern can't contain getter or setter", PatternHasMethod: "Object pattern can't contain methods", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding", PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.", PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)", PrivateNameRedeclaration: "Duplicate private name #%0", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'", RecordNoProto: "'__proto__' is not allowed in Record expressions", RestTrailingComma: "Unexpected trailing comma after rest element", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement", StaticPrototype: "Classes may not have static property named prototype", StrictDelete: "Deleting local variable in strict mode", StrictEvalArguments: "Assigning to '%0' in strict mode", StrictEvalArgumentsBinding: "Binding '%0' in strict mode", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode", StrictWith: "'with' in strict mode", SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super", TrailingDecorator: "Decorators must be attached to a class element", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal', UnexpectedDigitAfterHash: "Unexpected digit after hash token", UnexpectedImportExport: "'import' and 'export' may only appear at the top level", UnexpectedKeyword: "Unexpected keyword '%0'", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context", UnexpectedNewTarget: "new.target can only be used in functions", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'", UnexpectedSuper: "super is only allowed in object methods and classes", UnexpectedToken: "Unexpected token '%0'", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "import can only be used in import() or import.meta", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties", UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])", UnterminatedComment: "Unterminated comment", UnterminatedRegExp: "Unterminated regular expression", UnterminatedString: "Unterminated string constant", UnterminatedTemplate: "Unterminated template", VarRedeclaration: "Identifier '%0' has already been declared", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator", YieldInParameter: "yield is not allowed in generator parameters", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"});
        function D2(t3) {
          return t3 != null && t3.type === "Property" && t3.kind === "init" && t3.method === false;
        }
        class y2 {
          constructor(t3, e3, s3, i3) {
            this.token = t3, this.isExpr = !!e3, this.preserveSpace = !!s3, this.override = i3;
          }
        }
        const x2 = {braceStatement: new y2("{", false), braceExpression: new y2("{", true), templateQuasi: new y2("${", false), parenStatement: new y2("(", false), parenExpression: new y2("(", true), template: new y2("`", true, true, (t3) => t3.readTmplToken()), functionExpression: new y2("function", true), functionStatement: new y2("function", false)};
        n2.parenR.updateContext = n2.braceR.updateContext = function() {
          if (this.state.context.length === 1)
            return void (this.state.exprAllowed = true);
          let t3 = this.state.context.pop();
          t3 === x2.braceStatement && this.curContext().token === "function" && (t3 = this.state.context.pop()), this.state.exprAllowed = !t3.isExpr;
        }, n2.name.updateContext = function(t3) {
          let e3 = false;
          t3 !== n2.dot && (this.state.value === "of" && !this.state.exprAllowed && t3 !== n2._function && t3 !== n2._class || this.state.value === "yield" && this.prodParam.hasYield) && (e3 = true), this.state.exprAllowed = e3, this.state.isIterator && (this.state.isIterator = false);
        }, n2.braceL.updateContext = function(t3) {
          this.state.context.push(this.braceIsBlock(t3) ? x2.braceStatement : x2.braceExpression), this.state.exprAllowed = true;
        }, n2.dollarBraceL.updateContext = function() {
          this.state.context.push(x2.templateQuasi), this.state.exprAllowed = true;
        }, n2.parenL.updateContext = function(t3) {
          const e3 = t3 === n2._if || t3 === n2._for || t3 === n2._with || t3 === n2._while;
          this.state.context.push(e3 ? x2.parenStatement : x2.parenExpression), this.state.exprAllowed = true;
        }, n2.incDec.updateContext = function() {
        }, n2._function.updateContext = n2._class.updateContext = function(t3) {
          t3 === n2.dot || t3 === n2.questionDot || (!t3.beforeExpr || t3 === n2.semi || t3 === n2._else || t3 === n2._return && o2.test(this.input.slice(this.state.lastTokEnd, this.state.start)) || (t3 === n2.colon || t3 === n2.braceL) && this.curContext() === x2.b_stat ? this.state.context.push(x2.functionStatement) : this.state.context.push(x2.functionExpression)), this.state.exprAllowed = false;
        }, n2.backQuote.updateContext = function() {
          this.curContext() === x2.template ? this.state.context.pop() : this.state.context.push(x2.template), this.state.exprAllowed = false;
        }, n2.star.updateContext = function() {
          this.state.exprAllowed = false;
        };
        let g2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", E2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        const P2 = new RegExp("[" + g2 + "]"), b2 = new RegExp("[" + g2 + E2 + "]");
        g2 = E2 = null;
        const C2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], T2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function A2(t3, e3) {
          let s3 = 65536;
          for (let i3 = 0, r3 = e3.length; i3 < r3; i3 += 2) {
            if (s3 += e3[i3], s3 > t3)
              return false;
            if (s3 += e3[i3 + 1], s3 >= t3)
              return true;
          }
          return false;
        }
        function w2(t3) {
          return t3 < 65 ? t3 === 36 : t3 <= 90 || (t3 < 97 ? t3 === 95 : t3 <= 122 || (t3 <= 65535 ? t3 >= 170 && P2.test(String.fromCharCode(t3)) : A2(t3, C2)));
        }
        function N2(t3) {
          return t3 < 48 ? t3 === 36 : t3 < 58 || !(t3 < 65) && (t3 <= 90 || (t3 < 97 ? t3 === 95 : t3 <= 122 || (t3 <= 65535 ? t3 >= 170 && b2.test(String.fromCharCode(t3)) : A2(t3, C2) || A2(t3, T2))));
        }
        const S2 = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], I2 = ["eval", "arguments"], F2 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), v2 = new Set(S2), k2 = new Set(I2);
        function L2(t3, e3) {
          return e3 && t3 === "await" || t3 === "enum";
        }
        function O2(t3, e3) {
          return L2(t3, e3) || v2.has(t3);
        }
        function R2(t3) {
          return k2.has(t3);
        }
        function M2(t3, e3) {
          return O2(t3, e3) || R2(t3);
        }
        const B2 = /^in(stanceof)?$/;
        const _2 = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), j2 = Object.freeze({AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module", AssignReservedType: "Cannot overwrite reserved type %0", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions", InexactVariance: "Explicit inexact syntax cannot have variance", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`", NestedFlowComment: "Cannot have a flow comment inside another flow comment", OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.", SpreadVariance: "Spread properties cannot have variance", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object", UnexpectedReservedType: "Unexpected reserved type %0", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module", UnterminatedFlowComment: "Unterminated flow-comment"});
        function U2(t3) {
          return t3.importKind === "type" || t3.importKind === "typeof";
        }
        function q2(t3) {
          return (t3.type === n2.name || !!t3.type.keyword) && t3.value !== "from";
        }
        const V2 = {const: "declare export var", let: "declare export var", type: "export type", interface: "export interface"};
        const z2 = /\*?\s*@((?:no)?flow)\b/;
        const H2 = {quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666"}, G2 = /^[\da-fA-F]+$/, W2 = /^\d+$/, X2 = Object.freeze({AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text", UnterminatedJsxContent: "Unterminated JSX contents", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"});
        function K2(t3) {
          return !!t3 && (t3.type === "JSXOpeningFragment" || t3.type === "JSXClosingFragment");
        }
        function $2(t3) {
          if (t3.type === "JSXIdentifier")
            return t3.name;
          if (t3.type === "JSXNamespacedName")
            return t3.namespace.name + ":" + t3.name.name;
          if (t3.type === "JSXMemberExpression")
            return $2(t3.object) + "." + $2(t3.property);
          throw new Error("Node had unexpected type: " + t3.type);
        }
        x2.j_oTag = new y2("<tag", false), x2.j_cTag = new y2("</tag", false), x2.j_expr = new y2("<tag>...</tag>", true, true), n2.jsxName = new s2("jsxName"), n2.jsxText = new s2("jsxText", {beforeExpr: true}), n2.jsxTagStart = new s2("jsxTagStart", {startsExpr: true}), n2.jsxTagEnd = new s2("jsxTagEnd"), n2.jsxTagStart.updateContext = function() {
          this.state.context.push(x2.j_expr), this.state.context.push(x2.j_oTag), this.state.exprAllowed = false;
        }, n2.jsxTagEnd.updateContext = function(t3) {
          const e3 = this.state.context.pop();
          e3 === x2.j_oTag && t3 === n2.slash || e3 === x2.j_cTag ? (this.state.context.pop(), this.state.exprAllowed = this.curContext() === x2.j_expr) : this.state.exprAllowed = true;
        };
        class J2 {
          constructor(t3) {
            this.var = [], this.lexical = [], this.functions = [], this.flags = t3;
          }
        }
        class Y2 {
          constructor(t3, e3) {
            this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = t3, this.inModule = e3;
          }
          get inFunction() {
            return (2 & this.currentVarScope().flags) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScope().flags) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScope().flags) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScope().flags) > 0;
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScope().flags) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(t3) {
            return new J2(t3);
          }
          enter(t3) {
            this.scopeStack.push(this.createScope(t3));
          }
          exit() {
            this.scopeStack.pop();
          }
          treatFunctionsAsVarInScope(t3) {
            return !!(2 & t3.flags || !this.inModule && 1 & t3.flags);
          }
          declareName(t3, e3, s3) {
            let i3 = this.currentScope();
            if (8 & e3 || 16 & e3)
              this.checkRedeclarationInScope(i3, t3, e3, s3), 16 & e3 ? i3.functions.push(t3) : i3.lexical.push(t3), 8 & e3 && this.maybeExportDefined(i3, t3);
            else if (4 & e3)
              for (let r3 = this.scopeStack.length - 1; r3 >= 0 && (i3 = this.scopeStack[r3], this.checkRedeclarationInScope(i3, t3, e3, s3), i3.var.push(t3), this.maybeExportDefined(i3, t3), !(131 & i3.flags)); --r3)
                ;
            this.inModule && 1 & i3.flags && this.undefinedExports.delete(t3);
          }
          maybeExportDefined(t3, e3) {
            this.inModule && 1 & t3.flags && this.undefinedExports.delete(e3);
          }
          checkRedeclarationInScope(t3, e3, s3, i3) {
            this.isRedeclaredInScope(t3, e3, s3) && this.raise(i3, f2.VarRedeclaration, e3);
          }
          isRedeclaredInScope(t3, e3, s3) {
            return !!(1 & s3) && (8 & s3 ? t3.lexical.indexOf(e3) > -1 || t3.functions.indexOf(e3) > -1 || t3.var.indexOf(e3) > -1 : 16 & s3 ? t3.lexical.indexOf(e3) > -1 || !this.treatFunctionsAsVarInScope(t3) && t3.var.indexOf(e3) > -1 : t3.lexical.indexOf(e3) > -1 && !(8 & t3.flags && t3.lexical[0] === e3) || !this.treatFunctionsAsVarInScope(t3) && t3.functions.indexOf(e3) > -1);
          }
          checkLocalExport(t3) {
            this.scopeStack[0].lexical.indexOf(t3.name) === -1 && this.scopeStack[0].var.indexOf(t3.name) === -1 && this.scopeStack[0].functions.indexOf(t3.name) === -1 && this.undefinedExports.set(t3.name, t3.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScope() {
            for (let t3 = this.scopeStack.length - 1; ; t3--) {
              const e3 = this.scopeStack[t3];
              if (131 & e3.flags)
                return e3;
            }
          }
          currentThisScope() {
            for (let t3 = this.scopeStack.length - 1; ; t3--) {
              const e3 = this.scopeStack[t3];
              if ((131 & e3.flags || 64 & e3.flags) && !(4 & e3.flags))
                return e3;
            }
          }
        }
        class Q2 extends J2 {
          constructor(...t3) {
            super(...t3), this.types = [], this.enums = [], this.constEnums = [], this.classes = [], this.exportOnlyBindings = [];
          }
        }
        class Z2 extends Y2 {
          createScope(t3) {
            return new Q2(t3);
          }
          declareName(t3, e3, s3) {
            const i3 = this.currentScope();
            if (1024 & e3)
              return this.maybeExportDefined(i3, t3), void i3.exportOnlyBindings.push(t3);
            super.declareName(...arguments), 2 & e3 && (1 & e3 || (this.checkRedeclarationInScope(i3, t3, e3, s3), this.maybeExportDefined(i3, t3)), i3.types.push(t3)), 256 & e3 && i3.enums.push(t3), 512 & e3 && i3.constEnums.push(t3), 128 & e3 && i3.classes.push(t3);
          }
          isRedeclaredInScope(t3, e3, s3) {
            if (t3.enums.indexOf(e3) > -1) {
              if (256 & s3) {
                return !!(512 & s3) !== t3.constEnums.indexOf(e3) > -1;
              }
              return true;
            }
            return 128 & s3 && t3.classes.indexOf(e3) > -1 ? t3.lexical.indexOf(e3) > -1 && !!(1 & s3) : !!(2 & s3 && t3.types.indexOf(e3) > -1) || super.isRedeclaredInScope(...arguments);
          }
          checkLocalExport(t3) {
            this.scopeStack[0].types.indexOf(t3.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(t3.name) === -1 && super.checkLocalExport(t3);
          }
        }
        class tt2 {
          constructor() {
            this.stacks = [];
          }
          enter(t3) {
            this.stacks.push(t3);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
        }
        function et2(t3, e3) {
          return (t3 ? 2 : 0) | (e3 ? 1 : 0);
        }
        function st2(t3) {
          if (t3 == null)
            throw new Error("Unexpected ".concat(t3, " value."));
          return t3;
        }
        function it2(t3) {
          if (!t3)
            throw new Error("Assert fail");
        }
        const rt2 = Object.freeze({ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier", DeclareClassFieldHasInitializer: "'declare' class fields cannot have an initializer", DuplicateModifier: "Duplicate modifier: '%0'", EmptyHeritageClauseType: "'%0' list cannot be empty.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')", TemplateTypeHasSubstitution: "Template literal types cannot have any substitution", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"});
        n2.placeholder = new s2("%%", {startsExpr: true});
        function at2(t3, e3) {
          return t3.some((t4) => Array.isArray(t4) ? t4[0] === e3 : t4 === e3);
        }
        function nt2(t3, e3, s3) {
          const i3 = t3.find((t4) => Array.isArray(t4) ? t4[0] === e3 : t4 === e3);
          return i3 && Array.isArray(i3) ? i3[1][s3] : null;
        }
        const ot2 = ["minimal", "smart", "fsharp"], ht2 = ["hash", "bar"];
        const ct2 = {estree: (t3) => class extends t3 {
          estreeParseRegExpLiteral({pattern: t4, flags: e3}) {
            let s3 = null;
            try {
              s3 = new RegExp(t4, e3);
            } catch (t5) {
            }
            const i3 = this.estreeParseLiteral(s3);
            return i3.regex = {pattern: t4, flags: e3}, i3;
          }
          estreeParseBigIntLiteral(t4) {
            const e3 = typeof BigInt != "undefined" ? BigInt(t4) : null, s3 = this.estreeParseLiteral(e3);
            return s3.bigint = String(s3.value || t4), s3;
          }
          estreeParseDecimalLiteral(t4) {
            const e3 = this.estreeParseLiteral(null);
            return e3.decimal = String(e3.value || t4), e3;
          }
          estreeParseLiteral(t4) {
            return this.parseLiteral(t4, "Literal");
          }
          directiveToStmt(t4) {
            const e3 = t4.value, s3 = this.startNodeAt(t4.start, t4.loc.start), i3 = this.startNodeAt(e3.start, e3.loc.start);
            return i3.value = e3.value, i3.raw = e3.extra.raw, s3.expression = this.finishNodeAt(i3, "Literal", e3.end, e3.loc.end), s3.directive = e3.extra.raw.slice(1, -1), this.finishNodeAt(s3, "ExpressionStatement", t4.end, t4.loc.end);
          }
          initFunction(t4, e3) {
            super.initFunction(t4, e3), t4.expression = false;
          }
          checkDeclaration(t4) {
            D2(t4) ? this.checkDeclaration(t4.value) : super.checkDeclaration(t4);
          }
          checkGetterSetterParams(t4) {
            const e3 = t4, s3 = e3.kind === "get" ? 0 : 1, i3 = e3.start;
            e3.value.params.length !== s3 ? t4.kind === "get" ? this.raise(i3, f2.BadGetterArity) : this.raise(i3, f2.BadSetterArity) : e3.kind === "set" && e3.value.params[0].type === "RestElement" && this.raise(i3, f2.BadSetterRestParameter);
          }
          checkLVal(t4, e3 = 64, s3, i3, r3) {
            switch (t4.type) {
              case "ObjectPattern":
                t4.properties.forEach((t5) => {
                  this.checkLVal(t5.type === "Property" ? t5.value : t5, e3, s3, "object destructuring pattern", r3);
                });
                break;
              default:
                super.checkLVal(t4, e3, s3, i3, r3);
            }
          }
          checkProto(t4, e3, s3, i3) {
            t4.method || super.checkProto(t4, e3, s3, i3);
          }
          isValidDirective(t4) {
            var e3;
            return t4.type === "ExpressionStatement" && t4.expression.type === "Literal" && typeof t4.expression.value == "string" && !((e3 = t4.expression.extra) == null ? void 0 : e3.parenthesized);
          }
          stmtToDirective(t4) {
            const e3 = super.stmtToDirective(t4), s3 = t4.expression.value;
            return e3.value.value = s3, e3;
          }
          parseBlockBody(t4, e3, s3, i3) {
            super.parseBlockBody(t4, e3, s3, i3);
            const r3 = t4.directives.map((t5) => this.directiveToStmt(t5));
            t4.body = r3.concat(t4.body), delete t4.directives;
          }
          pushClassMethod(t4, e3, s3, i3, r3, a3) {
            this.parseMethod(e3, s3, i3, r3, a3, "ClassMethod", true), e3.typeParameters && (e3.value.typeParameters = e3.typeParameters, delete e3.typeParameters), t4.body.push(e3);
          }
          parseExprAtom(t4) {
            switch (this.state.type) {
              case n2.num:
              case n2.string:
                return this.estreeParseLiteral(this.state.value);
              case n2.regexp:
                return this.estreeParseRegExpLiteral(this.state.value);
              case n2.bigint:
                return this.estreeParseBigIntLiteral(this.state.value);
              case n2.decimal:
                return this.estreeParseDecimalLiteral(this.state.value);
              case n2._null:
                return this.estreeParseLiteral(null);
              case n2._true:
                return this.estreeParseLiteral(true);
              case n2._false:
                return this.estreeParseLiteral(false);
              default:
                return super.parseExprAtom(t4);
            }
          }
          parseLiteral(t4, e3, s3, i3) {
            const r3 = super.parseLiteral(t4, e3, s3, i3);
            return r3.raw = r3.extra.raw, delete r3.extra, r3;
          }
          parseFunctionBody(t4, e3, s3 = false) {
            super.parseFunctionBody(t4, e3, s3), t4.expression = t4.body.type !== "BlockStatement";
          }
          parseMethod(t4, e3, s3, i3, r3, a3, n3 = false) {
            let o3 = this.startNode();
            return o3.kind = t4.kind, o3 = super.parseMethod(o3, e3, s3, i3, r3, a3, n3), o3.type = "FunctionExpression", delete o3.kind, t4.value = o3, a3 = a3 === "ClassMethod" ? "MethodDefinition" : a3, this.finishNode(t4, a3);
          }
          parseObjectMethod(t4, e3, s3, i3, r3) {
            const a3 = super.parseObjectMethod(t4, e3, s3, i3, r3);
            return a3 && (a3.type = "Property", a3.kind === "method" && (a3.kind = "init"), a3.shorthand = false), a3;
          }
          parseObjectProperty(t4, e3, s3, i3, r3) {
            const a3 = super.parseObjectProperty(t4, e3, s3, i3, r3);
            return a3 && (a3.kind = "init", a3.type = "Property"), a3;
          }
          toAssignable(t4) {
            return D2(t4) ? (this.toAssignable(t4.value), t4) : super.toAssignable(t4);
          }
          toAssignableObjectExpressionProp(t4, e3) {
            if (t4.kind === "get" || t4.kind === "set")
              throw this.raise(t4.key.start, f2.PatternHasAccessor);
            if (t4.method)
              throw this.raise(t4.key.start, f2.PatternHasMethod);
            super.toAssignableObjectExpressionProp(t4, e3);
          }
          finishCallExpression(t4, e3) {
            return super.finishCallExpression(t4, e3), t4.callee.type === "Import" && (t4.type = "ImportExpression", t4.source = t4.arguments[0], delete t4.arguments, delete t4.callee), t4;
          }
          toReferencedListDeep(t4, e3) {
            t4 && super.toReferencedListDeep(t4, e3);
          }
          parseExport(t4) {
            switch (super.parseExport(t4), t4.type) {
              case "ExportAllDeclaration":
                t4.exported = null;
                break;
              case "ExportNamedDeclaration":
                t4.specifiers.length === 1 && t4.specifiers[0].type === "ExportNamespaceSpecifier" && (t4.type = "ExportAllDeclaration", t4.exported = t4.specifiers[0].exported, delete t4.specifiers);
            }
            return t4;
          }
          parseSubscript(t4, e3, s3, i3, r3) {
            const a3 = super.parseSubscript(t4, e3, s3, i3, r3);
            if (r3.optionalChainMember) {
              if (a3.type !== "OptionalMemberExpression" && a3.type !== "OptionalCallExpression" || (a3.type = a3.type.substring(8)), r3.stop) {
                const t5 = this.startNodeAtNode(a3);
                return t5.expression = a3, this.finishNode(t5, "ChainExpression");
              }
            } else
              a3.type !== "MemberExpression" && a3.type !== "CallExpression" || (a3.optional = false);
            return a3;
          }
        }, jsx: (t3) => class extends t3 {
          jsxReadToken() {
            let t4 = "", e3 = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, X2.UnterminatedJsxContent);
              const s3 = this.input.charCodeAt(this.state.pos);
              switch (s3) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? s3 === 60 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(n2.jsxTagStart)) : super.getTokenFromCode(s3) : (t4 += this.input.slice(e3, this.state.pos), this.finishToken(n2.jsxText, t4));
                case 38:
                  t4 += this.input.slice(e3, this.state.pos), t4 += this.jsxReadEntity(), e3 = this.state.pos;
                  break;
                default:
                  c2(s3) ? (t4 += this.input.slice(e3, this.state.pos), t4 += this.jsxReadNewLine(true), e3 = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(t4) {
            const e3 = this.input.charCodeAt(this.state.pos);
            let s3;
            return ++this.state.pos, e3 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s3 = t4 ? "\n" : "\r\n") : s3 = String.fromCharCode(e3), ++this.state.curLine, this.state.lineStart = this.state.pos, s3;
          }
          jsxReadString(t4) {
            let e3 = "", s3 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, f2.UnterminatedString);
              const i3 = this.input.charCodeAt(this.state.pos);
              if (i3 === t4)
                break;
              i3 === 38 ? (e3 += this.input.slice(s3, this.state.pos), e3 += this.jsxReadEntity(), s3 = this.state.pos) : c2(i3) ? (e3 += this.input.slice(s3, this.state.pos), e3 += this.jsxReadNewLine(false), s3 = this.state.pos) : ++this.state.pos;
            }
            return e3 += this.input.slice(s3, this.state.pos++), this.finishToken(n2.string, e3);
          }
          jsxReadEntity() {
            let t4, e3 = "", s3 = 0, i3 = this.input[this.state.pos];
            const r3 = ++this.state.pos;
            for (; this.state.pos < this.length && s3++ < 10; ) {
              if (i3 = this.input[this.state.pos++], i3 === ";") {
                e3[0] === "#" ? e3[1] === "x" ? (e3 = e3.substr(2), G2.test(e3) && (t4 = String.fromCodePoint(parseInt(e3, 16)))) : (e3 = e3.substr(1), W2.test(e3) && (t4 = String.fromCodePoint(parseInt(e3, 10)))) : t4 = H2[e3];
                break;
              }
              e3 += i3;
            }
            return t4 || (this.state.pos = r3, "&");
          }
          jsxReadWord() {
            let t4;
            const e3 = this.state.pos;
            do {
              t4 = this.input.charCodeAt(++this.state.pos);
            } while (N2(t4) || t4 === 45);
            return this.finishToken(n2.jsxName, this.input.slice(e3, this.state.pos));
          }
          jsxParseIdentifier() {
            const t4 = this.startNode();
            return this.match(n2.jsxName) ? t4.name = this.state.value : this.state.type.keyword ? t4.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(t4, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const t4 = this.state.start, e3 = this.state.startLoc, s3 = this.jsxParseIdentifier();
            if (!this.eat(n2.colon))
              return s3;
            const i3 = this.startNodeAt(t4, e3);
            return i3.namespace = s3, i3.name = this.jsxParseIdentifier(), this.finishNode(i3, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const t4 = this.state.start, e3 = this.state.startLoc;
            let s3 = this.jsxParseNamespacedName();
            if (s3.type === "JSXNamespacedName")
              return s3;
            for (; this.eat(n2.dot); ) {
              const i3 = this.startNodeAt(t4, e3);
              i3.object = s3, i3.property = this.jsxParseIdentifier(), s3 = this.finishNode(i3, "JSXMemberExpression");
            }
            return s3;
          }
          jsxParseAttributeValue() {
            let t4;
            switch (this.state.type) {
              case n2.braceL:
                return t4 = this.startNode(), this.next(), t4 = this.jsxParseExpressionContainer(t4), t4.expression.type === "JSXEmptyExpression" && this.raise(t4.start, X2.AttributeIsEmpty), t4;
              case n2.jsxTagStart:
              case n2.string:
                return this.parseExprAtom();
              default:
                throw this.raise(this.state.start, X2.UnsupportedJsxValue);
            }
          }
          jsxParseEmptyExpression() {
            const t4 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
            return this.finishNodeAt(t4, "JSXEmptyExpression", this.state.start, this.state.startLoc);
          }
          jsxParseSpreadChild(t4) {
            return this.next(), t4.expression = this.parseExpression(), this.expect(n2.braceR), this.finishNode(t4, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(t4) {
            return this.match(n2.braceR) ? t4.expression = this.jsxParseEmptyExpression() : t4.expression = this.parseExpression(), this.expect(n2.braceR), this.finishNode(t4, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const t4 = this.startNode();
            return this.eat(n2.braceL) ? (this.expect(n2.ellipsis), t4.argument = this.parseMaybeAssign(), this.expect(n2.braceR), this.finishNode(t4, "JSXSpreadAttribute")) : (t4.name = this.jsxParseNamespacedName(), t4.value = this.eat(n2.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(t4, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(t4, e3) {
            const s3 = this.startNodeAt(t4, e3);
            return this.match(n2.jsxTagEnd) ? (this.expect(n2.jsxTagEnd), this.finishNode(s3, "JSXOpeningFragment")) : (s3.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s3));
          }
          jsxParseOpeningElementAfterName(t4) {
            const e3 = [];
            for (; !this.match(n2.slash) && !this.match(n2.jsxTagEnd); )
              e3.push(this.jsxParseAttribute());
            return t4.attributes = e3, t4.selfClosing = this.eat(n2.slash), this.expect(n2.jsxTagEnd), this.finishNode(t4, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(t4, e3) {
            const s3 = this.startNodeAt(t4, e3);
            return this.match(n2.jsxTagEnd) ? (this.expect(n2.jsxTagEnd), this.finishNode(s3, "JSXClosingFragment")) : (s3.name = this.jsxParseElementName(), this.expect(n2.jsxTagEnd), this.finishNode(s3, "JSXClosingElement"));
          }
          jsxParseElementAt(t4, e3) {
            const s3 = this.startNodeAt(t4, e3), i3 = [], r3 = this.jsxParseOpeningElementAt(t4, e3);
            let a3 = null;
            if (!r3.selfClosing) {
              t:
                for (; ; )
                  switch (this.state.type) {
                    case n2.jsxTagStart:
                      if (t4 = this.state.start, e3 = this.state.startLoc, this.next(), this.eat(n2.slash)) {
                        a3 = this.jsxParseClosingElementAt(t4, e3);
                        break t;
                      }
                      i3.push(this.jsxParseElementAt(t4, e3));
                      break;
                    case n2.jsxText:
                      i3.push(this.parseExprAtom());
                      break;
                    case n2.braceL: {
                      const t5 = this.startNode();
                      this.next(), this.match(n2.ellipsis) ? i3.push(this.jsxParseSpreadChild(t5)) : i3.push(this.jsxParseExpressionContainer(t5));
                      break;
                    }
                    default:
                      throw this.unexpected();
                  }
              K2(r3) && !K2(a3) ? this.raise(a3.start, X2.MissingClosingTagFragment) : !K2(r3) && K2(a3) ? this.raise(a3.start, X2.MissingClosingTagElement, $2(r3.name)) : K2(r3) || K2(a3) || $2(a3.name) !== $2(r3.name) && this.raise(a3.start, X2.MissingClosingTagElement, $2(r3.name));
            }
            if (K2(r3) ? (s3.openingFragment = r3, s3.closingFragment = a3) : (s3.openingElement = r3, s3.closingElement = a3), s3.children = i3, this.isRelational("<"))
              throw this.raise(this.state.start, X2.UnwrappedAdjacentJSXElements);
            return K2(r3) ? this.finishNode(s3, "JSXFragment") : this.finishNode(s3, "JSXElement");
          }
          jsxParseElement() {
            const t4 = this.state.start, e3 = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(t4, e3);
          }
          parseExprAtom(t4) {
            return this.match(n2.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(n2.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33 ? (this.finishToken(n2.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(t4);
          }
          getTokenFromCode(t4) {
            if (this.state.inPropertyName)
              return super.getTokenFromCode(t4);
            const e3 = this.curContext();
            if (e3 === x2.j_expr)
              return this.jsxReadToken();
            if (e3 === x2.j_oTag || e3 === x2.j_cTag) {
              if (w2(t4))
                return this.jsxReadWord();
              if (t4 === 62)
                return ++this.state.pos, this.finishToken(n2.jsxTagEnd);
              if ((t4 === 34 || t4 === 39) && e3 === x2.j_oTag)
                return this.jsxReadString(t4);
            }
            return t4 === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(n2.jsxTagStart)) : super.getTokenFromCode(t4);
          }
          updateContext(t4) {
            if (this.match(n2.braceL)) {
              const e3 = this.curContext();
              e3 === x2.j_oTag ? this.state.context.push(x2.braceExpression) : e3 === x2.j_expr ? this.state.context.push(x2.templateQuasi) : super.updateContext(t4), this.state.exprAllowed = true;
            } else {
              if (!this.match(n2.slash) || t4 !== n2.jsxTagStart)
                return super.updateContext(t4);
              this.state.context.length -= 2, this.state.context.push(x2.j_cTag), this.state.exprAllowed = false;
            }
          }
        }, flow: (t3) => class extends t3 {
          constructor(t4, e3) {
            super(t4, e3), this.flowPragma = void 0;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(t4, e3) {
            return t4 !== n2.string && t4 !== n2.semi && t4 !== n2.interpreterDirective && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(t4, e3);
          }
          addComment(t4) {
            if (this.flowPragma === void 0) {
              const e3 = z2.exec(t4.value);
              if (e3)
                if (e3[1] === "flow")
                  this.flowPragma = "flow";
                else {
                  if (e3[1] !== "noflow")
                    throw new Error("Unexpected flow pragma");
                  this.flowPragma = "noflow";
                }
              else
                ;
            }
            return super.addComment(t4);
          }
          flowParseTypeInitialiser(t4) {
            const e3 = this.state.inType;
            this.state.inType = true, this.expect(t4 || n2.colon);
            const s3 = this.flowParseType();
            return this.state.inType = e3, s3;
          }
          flowParsePredicate() {
            const t4 = this.startNode(), e3 = this.state.startLoc, s3 = this.state.start;
            this.expect(n2.modulo);
            const i3 = this.state.startLoc;
            return this.expectContextual("checks"), e3.line === i3.line && e3.column === i3.column - 1 || this.raise(s3, j2.UnexpectedSpaceBetweenModuloChecks), this.eat(n2.parenL) ? (t4.value = this.parseExpression(), this.expect(n2.parenR), this.finishNode(t4, "DeclaredPredicate")) : this.finishNode(t4, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const t4 = this.state.inType;
            this.state.inType = true, this.expect(n2.colon);
            let e3 = null, s3 = null;
            return this.match(n2.modulo) ? (this.state.inType = t4, s3 = this.flowParsePredicate()) : (e3 = this.flowParseType(), this.state.inType = t4, this.match(n2.modulo) && (s3 = this.flowParsePredicate())), [e3, s3];
          }
          flowParseDeclareClass(t4) {
            return this.next(), this.flowParseInterfaceish(t4, true), this.finishNode(t4, "DeclareClass");
          }
          flowParseDeclareFunction(t4) {
            this.next();
            const e3 = t4.id = this.parseIdentifier(), s3 = this.startNode(), i3 = this.startNode();
            this.isRelational("<") ? s3.typeParameters = this.flowParseTypeParameterDeclaration() : s3.typeParameters = null, this.expect(n2.parenL);
            const r3 = this.flowParseFunctionTypeParams();
            return s3.params = r3.params, s3.rest = r3.rest, this.expect(n2.parenR), [s3.returnType, t4.predicate] = this.flowParseTypeAndPredicateInitialiser(), i3.typeAnnotation = this.finishNode(s3, "FunctionTypeAnnotation"), e3.typeAnnotation = this.finishNode(i3, "TypeAnnotation"), this.resetEndLocation(e3), this.semicolon(), this.finishNode(t4, "DeclareFunction");
          }
          flowParseDeclare(t4, e3) {
            if (this.match(n2._class))
              return this.flowParseDeclareClass(t4);
            if (this.match(n2._function))
              return this.flowParseDeclareFunction(t4);
            if (this.match(n2._var))
              return this.flowParseDeclareVariable(t4);
            if (this.eatContextual("module"))
              return this.match(n2.dot) ? this.flowParseDeclareModuleExports(t4) : (e3 && this.raise(this.state.lastTokStart, j2.NestedDeclareModule), this.flowParseDeclareModule(t4));
            if (this.isContextual("type"))
              return this.flowParseDeclareTypeAlias(t4);
            if (this.isContextual("opaque"))
              return this.flowParseDeclareOpaqueType(t4);
            if (this.isContextual("interface"))
              return this.flowParseDeclareInterface(t4);
            if (this.match(n2._export))
              return this.flowParseDeclareExportDeclaration(t4, e3);
            throw this.unexpected();
          }
          flowParseDeclareVariable(t4) {
            return this.next(), t4.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(t4.id.name, 5, t4.id.start), this.semicolon(), this.finishNode(t4, "DeclareVariable");
          }
          flowParseDeclareModule(t4) {
            this.scope.enter(0), this.match(n2.string) ? t4.id = this.parseExprAtom() : t4.id = this.parseIdentifier();
            const e3 = t4.body = this.startNode(), s3 = e3.body = [];
            for (this.expect(n2.braceL); !this.match(n2.braceR); ) {
              let t5 = this.startNode();
              this.match(n2._import) ? (this.next(), this.isContextual("type") || this.match(n2._typeof) || this.raise(this.state.lastTokStart, j2.InvalidNonTypeImportInDeclareModule), this.parseImport(t5)) : (this.expectContextual("declare", j2.UnsupportedStatementInDeclareModule), t5 = this.flowParseDeclare(t5, true)), s3.push(t5);
            }
            this.scope.exit(), this.expect(n2.braceR), this.finishNode(e3, "BlockStatement");
            let i3 = null, r3 = false;
            return s3.forEach((t5) => {
              !function(t6) {
                return t6.type === "DeclareExportAllDeclaration" || t6.type === "DeclareExportDeclaration" && (!t6.declaration || t6.declaration.type !== "TypeAlias" && t6.declaration.type !== "InterfaceDeclaration");
              }(t5) ? t5.type === "DeclareModuleExports" && (r3 && this.raise(t5.start, j2.DuplicateDeclareModuleExports), i3 === "ES" && this.raise(t5.start, j2.AmbiguousDeclareModuleKind), i3 = "CommonJS", r3 = true) : (i3 === "CommonJS" && this.raise(t5.start, j2.AmbiguousDeclareModuleKind), i3 = "ES");
            }), t4.kind = i3 || "CommonJS", this.finishNode(t4, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(t4, e3) {
            if (this.expect(n2._export), this.eat(n2._default))
              return this.match(n2._function) || this.match(n2._class) ? t4.declaration = this.flowParseDeclare(this.startNode()) : (t4.declaration = this.flowParseType(), this.semicolon()), t4.default = true, this.finishNode(t4, "DeclareExportDeclaration");
            if (this.match(n2._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !e3) {
              const t5 = this.state.value, e4 = V2[t5];
              throw this.raise(this.state.start, j2.UnsupportedDeclareExportKind, t5, e4);
            }
            if (this.match(n2._var) || this.match(n2._function) || this.match(n2._class) || this.isContextual("opaque"))
              return t4.declaration = this.flowParseDeclare(this.startNode()), t4.default = false, this.finishNode(t4, "DeclareExportDeclaration");
            if (this.match(n2.star) || this.match(n2.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
              return (t4 = this.parseExport(t4)).type === "ExportNamedDeclaration" && (t4.type = "ExportDeclaration", t4.default = false, delete t4.exportKind), t4.type = "Declare" + t4.type, t4;
            throw this.unexpected();
          }
          flowParseDeclareModuleExports(t4) {
            return this.next(), this.expectContextual("exports"), t4.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t4, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(t4) {
            return this.next(), this.flowParseTypeAlias(t4), t4.type = "DeclareTypeAlias", t4;
          }
          flowParseDeclareOpaqueType(t4) {
            return this.next(), this.flowParseOpaqueType(t4, true), t4.type = "DeclareOpaqueType", t4;
          }
          flowParseDeclareInterface(t4) {
            return this.next(), this.flowParseInterfaceish(t4), this.finishNode(t4, "DeclareInterface");
          }
          flowParseInterfaceish(t4, e3 = false) {
            if (t4.id = this.flowParseRestrictedIdentifier(!e3, true), this.scope.declareName(t4.id.name, e3 ? 17 : 9, t4.id.start), this.isRelational("<") ? t4.typeParameters = this.flowParseTypeParameterDeclaration() : t4.typeParameters = null, t4.extends = [], t4.implements = [], t4.mixins = [], this.eat(n2._extends))
              do {
                t4.extends.push(this.flowParseInterfaceExtends());
              } while (!e3 && this.eat(n2.comma));
            if (this.isContextual("mixins")) {
              this.next();
              do {
                t4.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(n2.comma));
            }
            if (this.isContextual("implements")) {
              this.next();
              do {
                t4.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(n2.comma));
            }
            t4.body = this.flowParseObjectType({allowStatic: e3, allowExact: false, allowSpread: false, allowProto: e3, allowInexact: false});
          }
          flowParseInterfaceExtends() {
            const t4 = this.startNode();
            return t4.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? t4.typeParameters = this.flowParseTypeParameterInstantiation() : t4.typeParameters = null, this.finishNode(t4, "InterfaceExtends");
          }
          flowParseInterface(t4) {
            return this.flowParseInterfaceish(t4), this.finishNode(t4, "InterfaceDeclaration");
          }
          checkNotUnderscore(t4) {
            t4 === "_" && this.raise(this.state.start, j2.UnexpectedReservedUnderscore);
          }
          checkReservedType(t4, e3, s3) {
            _2.has(t4) && this.raise(e3, s3 ? j2.AssignReservedType : j2.UnexpectedReservedType, t4);
          }
          flowParseRestrictedIdentifier(t4, e3) {
            return this.checkReservedType(this.state.value, this.state.start, e3), this.parseIdentifier(t4);
          }
          flowParseTypeAlias(t4) {
            return t4.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(t4.id.name, 9, t4.id.start), this.isRelational("<") ? t4.typeParameters = this.flowParseTypeParameterDeclaration() : t4.typeParameters = null, t4.right = this.flowParseTypeInitialiser(n2.eq), this.semicolon(), this.finishNode(t4, "TypeAlias");
          }
          flowParseOpaqueType(t4, e3) {
            return this.expectContextual("type"), t4.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(t4.id.name, 9, t4.id.start), this.isRelational("<") ? t4.typeParameters = this.flowParseTypeParameterDeclaration() : t4.typeParameters = null, t4.supertype = null, this.match(n2.colon) && (t4.supertype = this.flowParseTypeInitialiser(n2.colon)), t4.impltype = null, e3 || (t4.impltype = this.flowParseTypeInitialiser(n2.eq)), this.semicolon(), this.finishNode(t4, "OpaqueType");
          }
          flowParseTypeParameter(t4 = false) {
            const e3 = this.state.start, s3 = this.startNode(), i3 = this.flowParseVariance(), r3 = this.flowParseTypeAnnotatableIdentifier();
            return s3.name = r3.name, s3.variance = i3, s3.bound = r3.typeAnnotation, this.match(n2.eq) ? (this.eat(n2.eq), s3.default = this.flowParseType()) : t4 && this.raise(e3, j2.MissingTypeParamDefault), this.finishNode(s3, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const t4 = this.state.inType, e3 = this.startNode();
            e3.params = [], this.state.inType = true, this.isRelational("<") || this.match(n2.jsxTagStart) ? this.next() : this.unexpected();
            let s3 = false;
            do {
              const t5 = this.flowParseTypeParameter(s3);
              e3.params.push(t5), t5.default && (s3 = true), this.isRelational(">") || this.expect(n2.comma);
            } while (!this.isRelational(">"));
            return this.expectRelational(">"), this.state.inType = t4, this.finishNode(e3, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const t4 = this.startNode(), e3 = this.state.inType;
            t4.params = [], this.state.inType = true, this.expectRelational("<");
            const s3 = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
              t4.params.push(this.flowParseType()), this.isRelational(">") || this.expect(n2.comma);
            return this.state.noAnonFunctionType = s3, this.expectRelational(">"), this.state.inType = e3, this.finishNode(t4, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const t4 = this.startNode(), e3 = this.state.inType;
            for (t4.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
              t4.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(n2.comma);
            return this.expectRelational(">"), this.state.inType = e3, this.finishNode(t4, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const t4 = this.startNode();
            if (this.expectContextual("interface"), t4.extends = [], this.eat(n2._extends))
              do {
                t4.extends.push(this.flowParseInterfaceExtends());
              } while (this.eat(n2.comma));
            return t4.body = this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false}), this.finishNode(t4, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(n2.num) || this.match(n2.string) ? this.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(t4, e3, s3) {
            return t4.static = e3, this.lookahead().type === n2.colon ? (t4.id = this.flowParseObjectPropertyKey(), t4.key = this.flowParseTypeInitialiser()) : (t4.id = null, t4.key = this.flowParseType()), this.expect(n2.bracketR), t4.value = this.flowParseTypeInitialiser(), t4.variance = s3, this.finishNode(t4, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(t4, e3) {
            return t4.static = e3, t4.id = this.flowParseObjectPropertyKey(), this.expect(n2.bracketR), this.expect(n2.bracketR), this.isRelational("<") || this.match(n2.parenL) ? (t4.method = true, t4.optional = false, t4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t4.start, t4.loc.start))) : (t4.method = false, this.eat(n2.question) && (t4.optional = true), t4.value = this.flowParseTypeInitialiser()), this.finishNode(t4, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(t4) {
            for (t4.params = [], t4.rest = null, t4.typeParameters = null, this.isRelational("<") && (t4.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(n2.parenL); !this.match(n2.parenR) && !this.match(n2.ellipsis); )
              t4.params.push(this.flowParseFunctionTypeParam()), this.match(n2.parenR) || this.expect(n2.comma);
            return this.eat(n2.ellipsis) && (t4.rest = this.flowParseFunctionTypeParam()), this.expect(n2.parenR), t4.returnType = this.flowParseTypeInitialiser(), this.finishNode(t4, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(t4, e3) {
            const s3 = this.startNode();
            return t4.static = e3, t4.value = this.flowParseObjectTypeMethodish(s3), this.finishNode(t4, "ObjectTypeCallProperty");
          }
          flowParseObjectType({allowStatic: t4, allowExact: e3, allowSpread: s3, allowProto: i3, allowInexact: r3}) {
            const a3 = this.state.inType;
            this.state.inType = true;
            const o3 = this.startNode();
            let h3, c3;
            o3.callProperties = [], o3.properties = [], o3.indexers = [], o3.internalSlots = [];
            let p3 = false;
            for (e3 && this.match(n2.braceBarL) ? (this.expect(n2.braceBarL), h3 = n2.braceBarR, c3 = true) : (this.expect(n2.braceL), h3 = n2.braceR, c3 = false), o3.exact = c3; !this.match(h3); ) {
              let e4 = false, a4 = null, h4 = null;
              const u4 = this.startNode();
              if (i3 && this.isContextual("proto")) {
                const e5 = this.lookahead();
                e5.type !== n2.colon && e5.type !== n2.question && (this.next(), a4 = this.state.start, t4 = false);
              }
              if (t4 && this.isContextual("static")) {
                const t5 = this.lookahead();
                t5.type !== n2.colon && t5.type !== n2.question && (this.next(), e4 = true);
              }
              const l3 = this.flowParseVariance();
              if (this.eat(n2.bracketL))
                a4 != null && this.unexpected(a4), this.eat(n2.bracketL) ? (l3 && this.unexpected(l3.start), o3.internalSlots.push(this.flowParseObjectTypeInternalSlot(u4, e4))) : o3.indexers.push(this.flowParseObjectTypeIndexer(u4, e4, l3));
              else if (this.match(n2.parenL) || this.isRelational("<"))
                a4 != null && this.unexpected(a4), l3 && this.unexpected(l3.start), o3.callProperties.push(this.flowParseObjectTypeCallProperty(u4, e4));
              else {
                let t5 = "init";
                if (this.isContextual("get") || this.isContextual("set")) {
                  const e5 = this.lookahead();
                  e5.type !== n2.name && e5.type !== n2.string && e5.type !== n2.num || (t5 = this.state.value, this.next());
                }
                const i4 = this.flowParseObjectTypeProperty(u4, e4, a4, l3, t5, s3, r3 != null ? r3 : !c3);
                i4 === null ? (p3 = true, h4 = this.state.lastTokStart) : o3.properties.push(i4);
              }
              this.flowObjectTypeSemicolon(), !h4 || this.match(n2.braceR) || this.match(n2.braceBarR) || this.raise(h4, j2.UnexpectedExplicitInexactInObject);
            }
            this.expect(h3), s3 && (o3.inexact = p3);
            const u3 = this.finishNode(o3, "ObjectTypeAnnotation");
            return this.state.inType = a3, u3;
          }
          flowParseObjectTypeProperty(t4, e3, s3, i3, r3, a3, o3) {
            if (this.eat(n2.ellipsis)) {
              return this.match(n2.comma) || this.match(n2.semi) || this.match(n2.braceR) || this.match(n2.braceBarR) ? (a3 ? o3 || this.raise(this.state.lastTokStart, j2.InexactInsideExact) : this.raise(this.state.lastTokStart, j2.InexactInsideNonObject), i3 && this.raise(i3.start, j2.InexactVariance), null) : (a3 || this.raise(this.state.lastTokStart, j2.UnexpectedSpreadType), s3 != null && this.unexpected(s3), i3 && this.raise(i3.start, j2.SpreadVariance), t4.argument = this.flowParseType(), this.finishNode(t4, "ObjectTypeSpreadProperty"));
            }
            {
              t4.key = this.flowParseObjectPropertyKey(), t4.static = e3, t4.proto = s3 != null, t4.kind = r3;
              let a4 = false;
              return this.isRelational("<") || this.match(n2.parenL) ? (t4.method = true, s3 != null && this.unexpected(s3), i3 && this.unexpected(i3.start), t4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t4.start, t4.loc.start)), r3 !== "get" && r3 !== "set" || this.flowCheckGetterSetterParams(t4)) : (r3 !== "init" && this.unexpected(), t4.method = false, this.eat(n2.question) && (a4 = true), t4.value = this.flowParseTypeInitialiser(), t4.variance = i3), t4.optional = a4, this.finishNode(t4, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(t4) {
            const e3 = t4.kind === "get" ? 0 : 1, s3 = t4.start;
            t4.value.params.length + (t4.value.rest ? 1 : 0) !== e3 && (t4.kind === "get" ? this.raise(s3, f2.BadGetterArity) : this.raise(s3, f2.BadSetterArity)), t4.kind === "set" && t4.value.rest && this.raise(s3, f2.BadSetterRestParameter);
          }
          flowObjectTypeSemicolon() {
            this.eat(n2.semi) || this.eat(n2.comma) || this.match(n2.braceR) || this.match(n2.braceBarR) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(t4, e3, s3) {
            t4 = t4 || this.state.start, e3 = e3 || this.state.startLoc;
            let i3 = s3 || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(n2.dot); ) {
              const s4 = this.startNodeAt(t4, e3);
              s4.qualification = i3, s4.id = this.flowParseRestrictedIdentifier(true), i3 = this.finishNode(s4, "QualifiedTypeIdentifier");
            }
            return i3;
          }
          flowParseGenericType(t4, e3, s3) {
            const i3 = this.startNodeAt(t4, e3);
            return i3.typeParameters = null, i3.id = this.flowParseQualifiedTypeIdentifier(t4, e3, s3), this.isRelational("<") && (i3.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i3, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const t4 = this.startNode();
            return this.expect(n2._typeof), t4.argument = this.flowParsePrimaryType(), this.finishNode(t4, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const t4 = this.startNode();
            for (t4.types = [], this.expect(n2.bracketL); this.state.pos < this.length && !this.match(n2.bracketR) && (t4.types.push(this.flowParseType()), !this.match(n2.bracketR)); )
              this.expect(n2.comma);
            return this.expect(n2.bracketR), this.finishNode(t4, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam() {
            let t4 = null, e3 = false, s3 = null;
            const i3 = this.startNode(), r3 = this.lookahead();
            return r3.type === n2.colon || r3.type === n2.question ? (t4 = this.parseIdentifier(), this.eat(n2.question) && (e3 = true), s3 = this.flowParseTypeInitialiser()) : s3 = this.flowParseType(), i3.name = t4, i3.optional = e3, i3.typeAnnotation = s3, this.finishNode(i3, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(t4) {
            const e3 = this.startNodeAt(t4.start, t4.loc.start);
            return e3.name = null, e3.optional = false, e3.typeAnnotation = t4, this.finishNode(e3, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(t4 = []) {
            let e3 = null;
            for (; !this.match(n2.parenR) && !this.match(n2.ellipsis); )
              t4.push(this.flowParseFunctionTypeParam()), this.match(n2.parenR) || this.expect(n2.comma);
            return this.eat(n2.ellipsis) && (e3 = this.flowParseFunctionTypeParam()), {params: t4, rest: e3};
          }
          flowIdentToTypeAnnotation(t4, e3, s3, i3) {
            switch (i3.name) {
              case "any":
                return this.finishNode(s3, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(s3, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(s3, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(s3, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(s3, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(s3, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(s3, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(i3.name), this.flowParseGenericType(t4, e3, i3);
            }
          }
          flowParsePrimaryType() {
            const t4 = this.state.start, e3 = this.state.startLoc, s3 = this.startNode();
            let i3, r3, a3 = false;
            const o3 = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case n2.name:
                return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t4, e3, s3, this.parseIdentifier());
              case n2.braceL:
                return this.flowParseObjectType({allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true});
              case n2.braceBarL:
                return this.flowParseObjectType({allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false});
              case n2.bracketL:
                return this.state.noAnonFunctionType = false, r3 = this.flowParseTupleType(), this.state.noAnonFunctionType = o3, r3;
              case n2.relational:
                if (this.state.value === "<")
                  return s3.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(n2.parenL), i3 = this.flowParseFunctionTypeParams(), s3.params = i3.params, s3.rest = i3.rest, this.expect(n2.parenR), this.expect(n2.arrow), s3.returnType = this.flowParseType(), this.finishNode(s3, "FunctionTypeAnnotation");
                break;
              case n2.parenL:
                if (this.next(), !this.match(n2.parenR) && !this.match(n2.ellipsis))
                  if (this.match(n2.name)) {
                    const t5 = this.lookahead().type;
                    a3 = t5 !== n2.question && t5 !== n2.colon;
                  } else
                    a3 = true;
                if (a3) {
                  if (this.state.noAnonFunctionType = false, r3 = this.flowParseType(), this.state.noAnonFunctionType = o3, this.state.noAnonFunctionType || !(this.match(n2.comma) || this.match(n2.parenR) && this.lookahead().type === n2.arrow))
                    return this.expect(n2.parenR), r3;
                  this.eat(n2.comma);
                }
                return i3 = r3 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r3)]) : this.flowParseFunctionTypeParams(), s3.params = i3.params, s3.rest = i3.rest, this.expect(n2.parenR), this.expect(n2.arrow), s3.returnType = this.flowParseType(), s3.typeParameters = null, this.finishNode(s3, "FunctionTypeAnnotation");
              case n2.string:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case n2._true:
              case n2._false:
                return s3.value = this.match(n2._true), this.next(), this.finishNode(s3, "BooleanLiteralTypeAnnotation");
              case n2.plusMin:
                if (this.state.value === "-") {
                  if (this.next(), this.match(n2.num))
                    return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", s3.start, s3.loc.start);
                  if (this.match(n2.bigint))
                    return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", s3.start, s3.loc.start);
                  throw this.raise(this.state.start, j2.UnexpectedSubtractionOperand);
                }
                throw this.unexpected();
              case n2.num:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case n2.bigint:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case n2._void:
                return this.next(), this.finishNode(s3, "VoidTypeAnnotation");
              case n2._null:
                return this.next(), this.finishNode(s3, "NullLiteralTypeAnnotation");
              case n2._this:
                return this.next(), this.finishNode(s3, "ThisTypeAnnotation");
              case n2.star:
                return this.next(), this.finishNode(s3, "ExistsTypeAnnotation");
              default:
                if (this.state.type.keyword === "typeof")
                  return this.flowParseTypeofType();
                if (this.state.type.keyword) {
                  const t5 = this.state.type.label;
                  return this.next(), super.createIdentifier(s3, t5);
                }
            }
            throw this.unexpected();
          }
          flowParsePostfixType() {
            const t4 = this.state.start, e3 = this.state.startLoc;
            let s3 = this.flowParsePrimaryType();
            for (; this.match(n2.bracketL) && !this.canInsertSemicolon(); ) {
              const i3 = this.startNodeAt(t4, e3);
              i3.elementType = s3, this.expect(n2.bracketL), this.expect(n2.bracketR), s3 = this.finishNode(i3, "ArrayTypeAnnotation");
            }
            return s3;
          }
          flowParsePrefixType() {
            const t4 = this.startNode();
            return this.eat(n2.question) ? (t4.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t4, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const t4 = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(n2.arrow)) {
              const e3 = this.startNodeAt(t4.start, t4.loc.start);
              return e3.params = [this.reinterpretTypeAsFunctionTypeParam(t4)], e3.rest = null, e3.returnType = this.flowParseType(), e3.typeParameters = null, this.finishNode(e3, "FunctionTypeAnnotation");
            }
            return t4;
          }
          flowParseIntersectionType() {
            const t4 = this.startNode();
            this.eat(n2.bitwiseAND);
            const e3 = this.flowParseAnonFunctionWithoutParens();
            for (t4.types = [e3]; this.eat(n2.bitwiseAND); )
              t4.types.push(this.flowParseAnonFunctionWithoutParens());
            return t4.types.length === 1 ? e3 : this.finishNode(t4, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const t4 = this.startNode();
            this.eat(n2.bitwiseOR);
            const e3 = this.flowParseIntersectionType();
            for (t4.types = [e3]; this.eat(n2.bitwiseOR); )
              t4.types.push(this.flowParseIntersectionType());
            return t4.types.length === 1 ? e3 : this.finishNode(t4, "UnionTypeAnnotation");
          }
          flowParseType() {
            const t4 = this.state.inType;
            this.state.inType = true;
            const e3 = this.flowParseUnionType();
            return this.state.inType = t4, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, e3;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === n2.name && this.state.value === "_") {
              const t4 = this.state.start, e3 = this.state.startLoc, s3 = this.parseIdentifier();
              return this.flowParseGenericType(t4, e3, s3);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const t4 = this.startNode();
            return t4.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t4, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(t4) {
            const e3 = t4 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(n2.colon) && (e3.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e3)), e3;
          }
          typeCastToParameter(t4) {
            return t4.expression.typeAnnotation = t4.typeAnnotation, this.resetEndLocation(t4.expression, t4.typeAnnotation.end, t4.typeAnnotation.loc.end), t4.expression;
          }
          flowParseVariance() {
            let t4 = null;
            return this.match(n2.plusMin) && (t4 = this.startNode(), this.state.value === "+" ? t4.kind = "plus" : t4.kind = "minus", this.next(), this.finishNode(t4, "Variance")), t4;
          }
          parseFunctionBody(t4, e3, s3 = false) {
            return e3 ? this.forwardNoArrowParamsConversionAt(t4, () => super.parseFunctionBody(t4, true, s3)) : super.parseFunctionBody(t4, false, s3);
          }
          parseFunctionBodyAndFinish(t4, e3, s3 = false) {
            if (this.match(n2.colon)) {
              const e4 = this.startNode();
              [e4.typeAnnotation, t4.predicate] = this.flowParseTypeAndPredicateInitialiser(), t4.returnType = e4.typeAnnotation ? this.finishNode(e4, "TypeAnnotation") : null;
            }
            super.parseFunctionBodyAndFinish(t4, e3, s3);
          }
          parseStatement(t4, e3) {
            if (this.state.strict && this.match(n2.name) && this.state.value === "interface") {
              const t5 = this.startNode();
              return this.next(), this.flowParseInterface(t5);
            }
            if (this.shouldParseEnums() && this.isContextual("enum")) {
              const t5 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t5);
            }
            {
              const s3 = super.parseStatement(t4, e3);
              return this.flowPragma !== void 0 || this.isValidDirective(s3) || (this.flowPragma = null), s3;
            }
          }
          parseExpressionStatement(t4, e3) {
            if (e3.type === "Identifier") {
              if (e3.name === "declare") {
                if (this.match(n2._class) || this.match(n2.name) || this.match(n2._function) || this.match(n2._var) || this.match(n2._export))
                  return this.flowParseDeclare(t4);
              } else if (this.match(n2.name)) {
                if (e3.name === "interface")
                  return this.flowParseInterface(t4);
                if (e3.name === "type")
                  return this.flowParseTypeAlias(t4);
                if (e3.name === "opaque")
                  return this.flowParseOpaqueType(t4, false);
              }
            }
            return super.parseExpressionStatement(t4, e3);
          }
          shouldParseExportDeclaration() {
            return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            return (!this.match(n2.name) || !(this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) && super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual("enum")) {
              const t4 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t4);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(t4, e3, s3, i3, r3) {
            if (!this.match(n2.question))
              return t4;
            if (r3) {
              const a4 = this.tryParse(() => super.parseConditional(t4, e3, s3, i3));
              return a4.node ? (a4.error && (this.state = a4.failState), a4.node) : (r3.start = a4.error.pos || this.state.start, t4);
            }
            this.expect(n2.question);
            const a3 = this.state.clone(), o3 = this.state.noArrowAt, h3 = this.startNodeAt(s3, i3);
            let {consequent: c3, failed: p3} = this.tryParseConditionalConsequent(), [u3, l3] = this.getArrowLikeExpressions(c3);
            if (p3 || l3.length > 0) {
              const t5 = [...o3];
              if (l3.length > 0) {
                this.state = a3, this.state.noArrowAt = t5;
                for (let e4 = 0; e4 < l3.length; e4++)
                  t5.push(l3[e4].start);
                ({consequent: c3, failed: p3} = this.tryParseConditionalConsequent()), [u3, l3] = this.getArrowLikeExpressions(c3);
              }
              p3 && u3.length > 1 && this.raise(a3.start, j2.AmbiguousConditionalArrow), p3 && u3.length === 1 && (this.state = a3, this.state.noArrowAt = t5.concat(u3[0].start), {consequent: c3, failed: p3} = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(c3, true), this.state.noArrowAt = o3, this.expect(n2.colon), h3.test = t4, h3.consequent = c3, h3.alternate = this.forwardNoArrowParamsConversionAt(h3, () => this.parseMaybeAssign(e3, void 0, void 0, void 0)), this.finishNode(h3, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const t4 = this.parseMaybeAssign(), e3 = !this.match(n2.colon);
            return this.state.noArrowParamsConversionAt.pop(), {consequent: t4, failed: e3};
          }
          getArrowLikeExpressions(t4, e3) {
            const s3 = [t4], i3 = [];
            for (; s3.length !== 0; ) {
              const t5 = s3.pop();
              t5.type === "ArrowFunctionExpression" ? (t5.typeParameters || !t5.returnType ? this.finishArrowValidation(t5) : i3.push(t5), s3.push(t5.body)) : t5.type === "ConditionalExpression" && (s3.push(t5.consequent), s3.push(t5.alternate));
            }
            return e3 ? (i3.forEach((t5) => this.finishArrowValidation(t5)), [i3, []]) : function(t5, e4) {
              const s4 = [], i4 = [];
              for (let r3 = 0; r3 < t5.length; r3++)
                (e4(t5[r3], r3, t5) ? s4 : i4).push(t5[r3]);
              return [s4, i4];
            }(i3, (t5) => t5.params.every((t6) => this.isAssignable(t6, true)));
          }
          finishArrowValidation(t4) {
            var e3;
            this.toAssignableList(t4.params, (e3 = t4.extra) == null ? void 0 : e3.trailingComma), this.scope.enter(6), super.checkParams(t4, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(t4, e3) {
            let s3;
            return this.state.noArrowParamsConversionAt.indexOf(t4.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s3 = e3(), this.state.noArrowParamsConversionAt.pop()) : s3 = e3(), s3;
          }
          parseParenItem(t4, e3, s3) {
            if (t4 = super.parseParenItem(t4, e3, s3), this.eat(n2.question) && (t4.optional = true, this.resetEndLocation(t4)), this.match(n2.colon)) {
              const i3 = this.startNodeAt(e3, s3);
              return i3.expression = t4, i3.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i3, "TypeCastExpression");
            }
            return t4;
          }
          assertModuleNodeAllowed(t4) {
            t4.type === "ImportDeclaration" && (t4.importKind === "type" || t4.importKind === "typeof") || t4.type === "ExportNamedDeclaration" && t4.exportKind === "type" || t4.type === "ExportAllDeclaration" && t4.exportKind === "type" || super.assertModuleNodeAllowed(t4);
          }
          parseExport(t4) {
            const e3 = super.parseExport(t4);
            return e3.type !== "ExportNamedDeclaration" && e3.type !== "ExportAllDeclaration" || (e3.exportKind = e3.exportKind || "value"), e3;
          }
          parseExportDeclaration(t4) {
            if (this.isContextual("type")) {
              t4.exportKind = "type";
              const e3 = this.startNode();
              return this.next(), this.match(n2.braceL) ? (t4.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(t4), null) : this.flowParseTypeAlias(e3);
            }
            if (this.isContextual("opaque")) {
              t4.exportKind = "type";
              const e3 = this.startNode();
              return this.next(), this.flowParseOpaqueType(e3, false);
            }
            if (this.isContextual("interface")) {
              t4.exportKind = "type";
              const e3 = this.startNode();
              return this.next(), this.flowParseInterface(e3);
            }
            if (this.shouldParseEnums() && this.isContextual("enum")) {
              t4.exportKind = "value";
              const e3 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e3);
            }
            return super.parseExportDeclaration(t4);
          }
          eatExportStar(t4) {
            return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== n2.star) && (t4.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(t4) {
            const e3 = this.state.start, s3 = super.maybeParseExportNamespaceSpecifier(t4);
            return s3 && t4.exportKind === "type" && this.unexpected(e3), s3;
          }
          parseClassId(t4, e3, s3) {
            super.parseClassId(t4, e3, s3), this.isRelational("<") && (t4.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(t4, e3, s3, i3) {
            const r3 = this.state.start;
            if (this.isContextual("declare")) {
              if (this.parseClassMemberFromModifier(t4, e3))
                return;
              e3.declare = true;
            }
            super.parseClassMember(t4, e3, s3, i3), e3.declare && (e3.type !== "ClassProperty" && e3.type !== "ClassPrivateProperty" ? this.raise(r3, j2.DeclareClassElement) : e3.value && this.raise(e3.value.start, j2.DeclareClassFieldInitializer));
          }
          getTokenFromCode(t4) {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            return t4 === 123 && e3 === 124 ? this.finishOp(n2.braceBarL, 2) : !this.state.inType || t4 !== 62 && t4 !== 60 ? this.state.inType && t4 === 63 ? this.finishOp(n2.question, 1) : function(t5, e4) {
              return t5 === 64 && e4 === 64;
            }(t4, e3) ? (this.state.isIterator = true, super.readWord()) : super.getTokenFromCode(t4) : this.finishOp(n2.relational, 1);
          }
          isAssignable(t4, e3) {
            switch (t4.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
                return true;
              case "ObjectExpression": {
                const e4 = t4.properties.length - 1;
                return t4.properties.every((t5, s3) => t5.type !== "ObjectMethod" && (s3 === e4 || t5.type === "SpreadElement") && this.isAssignable(t5));
              }
              case "ObjectProperty":
                return this.isAssignable(t4.value);
              case "SpreadElement":
                return this.isAssignable(t4.argument);
              case "ArrayExpression":
                return t4.elements.every((t5) => this.isAssignable(t5));
              case "AssignmentExpression":
                return t4.operator === "=";
              case "ParenthesizedExpression":
              case "TypeCastExpression":
                return this.isAssignable(t4.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !e3;
              default:
                return false;
            }
          }
          toAssignable(t4) {
            return t4.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(t4)) : super.toAssignable(t4);
          }
          toAssignableList(t4, e3) {
            for (let e4 = 0; e4 < t4.length; e4++) {
              const s3 = t4[e4];
              (s3 == null ? void 0 : s3.type) === "TypeCastExpression" && (t4[e4] = this.typeCastToParameter(s3));
            }
            return super.toAssignableList(t4, e3);
          }
          toReferencedList(t4, e3) {
            for (let i3 = 0; i3 < t4.length; i3++) {
              var s3;
              const r3 = t4[i3];
              r3 && r3.type === "TypeCastExpression" && !((s3 = r3.extra) == null ? void 0 : s3.parenthesized) && (t4.length > 1 || !e3) && this.raise(r3.typeAnnotation.start, j2.TypeCastInPattern);
            }
            return t4;
          }
          checkLVal(t4, e3 = 64, s3, i3) {
            if (t4.type !== "TypeCastExpression")
              return super.checkLVal(t4, e3, s3, i3);
          }
          parseClassProperty(t4) {
            return this.match(n2.colon) && (t4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t4);
          }
          parseClassPrivateProperty(t4) {
            return this.match(n2.colon) && (t4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t4);
          }
          isClassMethod() {
            return this.isRelational("<") || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(n2.colon) || super.isClassProperty();
          }
          isNonstaticConstructor(t4) {
            return !this.match(n2.colon) && super.isNonstaticConstructor(t4);
          }
          pushClassMethod(t4, e3, s3, i3, r3, a3) {
            e3.variance && this.unexpected(e3.variance.start), delete e3.variance, this.isRelational("<") && (e3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t4, e3, s3, i3, r3, a3);
          }
          pushClassPrivateMethod(t4, e3, s3, i3) {
            e3.variance && this.unexpected(e3.variance.start), delete e3.variance, this.isRelational("<") && (e3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t4, e3, s3, i3);
          }
          parseClassSuper(t4) {
            if (super.parseClassSuper(t4), t4.superClass && this.isRelational("<") && (t4.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
              this.next();
              const e3 = t4.implements = [];
              do {
                const t5 = this.startNode();
                t5.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? t5.typeParameters = this.flowParseTypeParameterInstantiation() : t5.typeParameters = null, e3.push(this.finishNode(t5, "ClassImplements"));
              } while (this.eat(n2.comma));
            }
          }
          parsePropertyName(t4, e3) {
            const s3 = this.flowParseVariance(), i3 = super.parsePropertyName(t4, e3);
            return t4.variance = s3, i3;
          }
          parseObjPropValue(t4, e3, s3, i3, r3, a3, o3, h3) {
            let c3;
            t4.variance && this.unexpected(t4.variance.start), delete t4.variance, this.isRelational("<") && !o3 && (c3 = this.flowParseTypeParameterDeclaration(), this.match(n2.parenL) || this.unexpected()), super.parseObjPropValue(t4, e3, s3, i3, r3, a3, o3, h3), c3 && ((t4.value || t4).typeParameters = c3);
          }
          parseAssignableListItemTypes(t4) {
            return this.eat(n2.question) && (t4.type !== "Identifier" && this.raise(t4.start, j2.OptionalBindingPattern), t4.optional = true), this.match(n2.colon) && (t4.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t4), t4;
          }
          parseMaybeDefault(t4, e3, s3) {
            const i3 = super.parseMaybeDefault(t4, e3, s3);
            return i3.type === "AssignmentPattern" && i3.typeAnnotation && i3.right.start < i3.typeAnnotation.start && this.raise(i3.typeAnnotation.start, j2.TypeBeforeInitializer), i3;
          }
          shouldParseDefaultImport(t4) {
            return U2(t4) ? q2(this.state) : super.shouldParseDefaultImport(t4);
          }
          parseImportSpecifierLocal(t4, e3, s3, i3) {
            e3.local = U2(t4) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(e3.local, 9, void 0, i3), t4.specifiers.push(this.finishNode(e3, s3));
          }
          maybeParseDefaultImportSpecifier(t4) {
            t4.importKind = "value";
            let e3 = null;
            if (this.match(n2._typeof) ? e3 = "typeof" : this.isContextual("type") && (e3 = "type"), e3) {
              const s3 = this.lookahead();
              e3 === "type" && s3.type === n2.star && this.unexpected(s3.start), (q2(s3) || s3.type === n2.braceL || s3.type === n2.star) && (this.next(), t4.importKind = e3);
            }
            return super.maybeParseDefaultImportSpecifier(t4);
          }
          parseImportSpecifier(t4) {
            const e3 = this.startNode(), s3 = this.state.start, i3 = this.parseIdentifier(true);
            let r3 = null;
            i3.name === "type" ? r3 = "type" : i3.name === "typeof" && (r3 = "typeof");
            let a3 = false;
            if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
              const t5 = this.parseIdentifier(true);
              r3 === null || this.match(n2.name) || this.state.type.keyword ? (e3.imported = i3, e3.importKind = null, e3.local = this.parseIdentifier()) : (e3.imported = t5, e3.importKind = r3, e3.local = t5.__clone());
            } else
              r3 !== null && (this.match(n2.name) || this.state.type.keyword) ? (e3.imported = this.parseIdentifier(true), e3.importKind = r3, this.eatContextual("as") ? e3.local = this.parseIdentifier() : (a3 = true, e3.local = e3.imported.__clone())) : (a3 = true, e3.imported = i3, e3.importKind = null, e3.local = e3.imported.__clone());
            const o3 = U2(t4), h3 = U2(e3);
            o3 && h3 && this.raise(s3, j2.ImportTypeShorthandOnlyInPureImport), (o3 || h3) && this.checkReservedType(e3.local.name, e3.local.start, true), !a3 || o3 || h3 || this.checkReservedWord(e3.local.name, e3.start, true, true), this.checkLVal(e3.local, 9, void 0, "import specifier"), t4.specifiers.push(this.finishNode(e3, "ImportSpecifier"));
          }
          parseFunctionParams(t4, e3) {
            const s3 = t4.kind;
            s3 !== "get" && s3 !== "set" && this.isRelational("<") && (t4.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t4, e3);
          }
          parseVarId(t4, e3) {
            super.parseVarId(t4, e3), this.match(n2.colon) && (t4.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t4.id));
          }
          parseAsyncArrowFromCallExpression(t4, e3) {
            if (this.match(n2.colon)) {
              const e4 = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, t4.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = e4;
            }
            return super.parseAsyncArrowFromCallExpression(t4, e3);
          }
          shouldParseAsyncArrow() {
            return this.match(n2.colon) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(t4, e3, s3, i3) {
            var r3;
            let a3, o3 = null;
            if (this.hasPlugin("jsx") && (this.match(n2.jsxTagStart) || this.isRelational("<"))) {
              if (o3 = this.state.clone(), a3 = this.tryParse(() => super.parseMaybeAssign(t4, e3, s3, i3), o3), !a3.error)
                return a3.node;
              const {context: r4} = this.state;
              r4[r4.length - 1] === x2.j_oTag ? r4.length -= 2 : r4[r4.length - 1] === x2.j_expr && (r4.length -= 1);
            }
            if (((r3 = a3) == null ? void 0 : r3.error) || this.isRelational("<")) {
              var h3, c3, p3;
              let r4;
              o3 = o3 || this.state.clone();
              const n3 = this.tryParse(() => {
                r4 = this.flowParseTypeParameterDeclaration();
                const a4 = this.forwardNoArrowParamsConversionAt(r4, () => super.parseMaybeAssign(t4, e3, s3, i3));
                return a4.typeParameters = r4, this.resetStartLocationFromNode(a4, r4), a4;
              }, o3), u3 = ((h3 = n3.node) == null ? void 0 : h3.type) === "ArrowFunctionExpression" ? n3.node : null;
              if (!n3.error && u3)
                return u3;
              if ((c3 = a3) == null ? void 0 : c3.node)
                return this.state = a3.failState, a3.node;
              if (u3)
                return this.state = n3.failState, u3;
              if ((p3 = a3) == null ? void 0 : p3.thrown)
                throw a3.error;
              if (n3.thrown)
                throw n3.error;
              throw this.raise(r4.start, j2.UnexpectedTokenAfterTypeParameter);
            }
            return super.parseMaybeAssign(t4, e3, s3, i3);
          }
          parseArrow(t4) {
            if (this.match(n2.colon)) {
              const e3 = this.tryParse(() => {
                const e4 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const s3 = this.startNode();
                return [s3.typeAnnotation, t4.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = e4, this.canInsertSemicolon() && this.unexpected(), this.match(n2.arrow) || this.unexpected(), s3;
              });
              if (e3.thrown)
                return null;
              e3.error && (this.state = e3.failState), t4.returnType = e3.node.typeAnnotation ? this.finishNode(e3.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(t4);
          }
          shouldParseArrow() {
            return this.match(n2.colon) || super.shouldParseArrow();
          }
          setArrowFunctionParameters(t4, e3) {
            this.state.noArrowParamsConversionAt.indexOf(t4.start) !== -1 ? t4.params = e3 : super.setArrowFunctionParameters(t4, e3);
          }
          checkParams(t4, e3, s3) {
            if (!s3 || this.state.noArrowParamsConversionAt.indexOf(t4.start) === -1)
              return super.checkParams(...arguments);
          }
          parseParenAndDistinguishExpression(t4) {
            return super.parseParenAndDistinguishExpression(t4 && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(t4, e3, s3, i3) {
            if (t4.type === "Identifier" && t4.name === "async" && this.state.noArrowAt.indexOf(e3) !== -1) {
              this.next();
              const i4 = this.startNodeAt(e3, s3);
              i4.callee = t4, i4.arguments = this.parseCallExpressionArguments(n2.parenR, false), t4 = this.finishNode(i4, "CallExpression");
            } else if (t4.type === "Identifier" && t4.name === "async" && this.isRelational("<")) {
              const r3 = this.state.clone(), a3 = this.tryParse((t5) => this.parseAsyncArrowWithTypeParameters(e3, s3) || t5(), r3);
              if (!a3.error && !a3.aborted)
                return a3.node;
              const n3 = this.tryParse(() => super.parseSubscripts(t4, e3, s3, i3), r3);
              if (n3.node && !n3.error)
                return n3.node;
              if (a3.node)
                return this.state = a3.failState, a3.node;
              if (n3.node)
                return this.state = n3.failState, n3.node;
              throw a3.error || n3.error;
            }
            return super.parseSubscripts(t4, e3, s3, i3);
          }
          parseSubscript(t4, e3, s3, i3, r3) {
            if (this.match(n2.questionDot) && this.isLookaheadRelational("<")) {
              if (r3.optionalChainMember = true, i3)
                return r3.stop = true, t4;
              this.next();
              const a3 = this.startNodeAt(e3, s3);
              return a3.callee = t4, a3.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(n2.parenL), a3.arguments = this.parseCallExpressionArguments(n2.parenR, false), a3.optional = true, this.finishCallExpression(a3, true);
            }
            if (!i3 && this.shouldParseTypes() && this.isRelational("<")) {
              const i4 = this.startNodeAt(e3, s3);
              i4.callee = t4;
              const a3 = this.tryParse(() => (i4.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(n2.parenL), i4.arguments = this.parseCallExpressionArguments(n2.parenR, false), r3.optionalChainMember && (i4.optional = false), this.finishCallExpression(i4, r3.optionalChainMember)));
              if (a3.node)
                return a3.error && (this.state = a3.failState), a3.node;
            }
            return super.parseSubscript(t4, e3, s3, i3, r3);
          }
          parseNewArguments(t4) {
            let e3 = null;
            this.shouldParseTypes() && this.isRelational("<") && (e3 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), t4.typeArguments = e3, super.parseNewArguments(t4);
          }
          parseAsyncArrowWithTypeParameters(t4, e3) {
            const s3 = this.startNodeAt(t4, e3);
            if (this.parseFunctionParams(s3), this.parseArrow(s3))
              return this.parseArrowExpression(s3, void 0, true);
          }
          readToken_mult_modulo(t4) {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            if (t4 === 42 && e3 === 47 && this.state.hasFlowComment)
              return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(t4);
          }
          readToken_pipe_amp(t4) {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            t4 !== 124 || e3 !== 125 ? super.readToken_pipe_amp(t4) : this.finishOp(n2.braceBarR, 2);
          }
          parseTopLevel(t4, e3) {
            const s3 = super.parseTopLevel(t4, e3);
            return this.state.hasFlowComment && this.raise(this.state.pos, j2.UnterminatedFlowComment), s3;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment())
              return this.state.hasFlowComment && this.unexpected(null, j2.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
            if (this.state.hasFlowComment) {
              const t4 = this.input.indexOf("*-/", this.state.pos += 2);
              if (t4 === -1)
                throw this.raise(this.state.pos - 2, f2.UnterminatedComment);
              this.state.pos = t4 + 3;
            } else
              super.skipBlockComment();
          }
          skipFlowComment() {
            const {pos: t4} = this.state;
            let e3 = 2;
            for (; [32, 9].includes(this.input.charCodeAt(t4 + e3)); )
              e3++;
            const s3 = this.input.charCodeAt(e3 + t4), i3 = this.input.charCodeAt(e3 + t4 + 1);
            return s3 === 58 && i3 === 58 ? e3 + 2 : this.input.slice(e3 + t4, e3 + t4 + 12) === "flow-include" ? e3 + 12 : s3 === 58 && i3 !== 58 && e3;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1)
              throw this.raise(this.state.pos, f2.UnterminatedComment);
          }
          flowEnumErrorBooleanMemberNotInitialized(t4, {enumName: e3, memberName: s3}) {
            this.raise(t4, j2.EnumBooleanMemberNotInitialized, s3, e3);
          }
          flowEnumErrorInvalidMemberName(t4, {enumName: e3, memberName: s3}) {
            const i3 = s3[0].toUpperCase() + s3.slice(1);
            this.raise(t4, j2.EnumInvalidMemberName, s3, i3, e3);
          }
          flowEnumErrorDuplicateMemberName(t4, {enumName: e3, memberName: s3}) {
            this.raise(t4, j2.EnumDuplicateMemberName, s3, e3);
          }
          flowEnumErrorInconsistentMemberValues(t4, {enumName: e3}) {
            this.raise(t4, j2.EnumInconsistentMemberValues, e3);
          }
          flowEnumErrorInvalidExplicitType(t4, {enumName: e3, suppliedType: s3}) {
            return this.raise(t4, s3 === null ? j2.EnumInvalidExplicitTypeUnknownSupplied : j2.EnumInvalidExplicitType, e3, s3);
          }
          flowEnumErrorInvalidMemberInitializer(t4, {enumName: e3, explicitType: s3, memberName: i3}) {
            let r3 = null;
            switch (s3) {
              case "boolean":
              case "number":
              case "string":
                r3 = j2.EnumInvalidMemberInitializerPrimaryType;
                break;
              case "symbol":
                r3 = j2.EnumInvalidMemberInitializerSymbolType;
                break;
              default:
                r3 = j2.EnumInvalidMemberInitializerUnknownType;
            }
            return this.raise(t4, r3, e3, i3, s3);
          }
          flowEnumErrorNumberMemberNotInitialized(t4, {enumName: e3, memberName: s3}) {
            this.raise(t4, j2.EnumNumberMemberNotInitialized, e3, s3);
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(t4, {enumName: e3}) {
            this.raise(t4, j2.EnumStringMemberInconsistentlyInitailized, e3);
          }
          flowEnumMemberInit() {
            const t4 = this.state.start, e3 = () => this.match(n2.comma) || this.match(n2.braceR);
            switch (this.state.type) {
              case n2.num: {
                const s3 = this.parseLiteral(this.state.value, "NumericLiteral");
                return e3() ? {type: "number", pos: s3.start, value: s3} : {type: "invalid", pos: t4};
              }
              case n2.string: {
                const s3 = this.parseLiteral(this.state.value, "StringLiteral");
                return e3() ? {type: "string", pos: s3.start, value: s3} : {type: "invalid", pos: t4};
              }
              case n2._true:
              case n2._false: {
                const s3 = this.parseBooleanLiteral();
                return e3() ? {type: "boolean", pos: s3.start, value: s3} : {type: "invalid", pos: t4};
              }
              default:
                return {type: "invalid", pos: t4};
            }
          }
          flowEnumMemberRaw() {
            const t4 = this.state.start;
            return {id: this.parseIdentifier(true), init: this.eat(n2.eq) ? this.flowEnumMemberInit() : {type: "none", pos: t4}};
          }
          flowEnumCheckExplicitTypeMismatch(t4, e3, s3) {
            const {explicitType: i3} = e3;
            i3 !== null && i3 !== s3 && this.flowEnumErrorInvalidMemberInitializer(t4, e3);
          }
          flowEnumMembers({enumName: t4, explicitType: e3}) {
            const s3 = new Set(), i3 = {booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: []};
            for (; !this.match(n2.braceR); ) {
              const r3 = this.startNode(), {id: a3, init: o3} = this.flowEnumMemberRaw(), h3 = a3.name;
              if (h3 === "")
                continue;
              /^[a-z]/.test(h3) && this.flowEnumErrorInvalidMemberName(a3.start, {enumName: t4, memberName: h3}), s3.has(h3) && this.flowEnumErrorDuplicateMemberName(a3.start, {enumName: t4, memberName: h3}), s3.add(h3);
              const c3 = {enumName: t4, explicitType: e3, memberName: h3};
              switch (r3.id = a3, o3.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(o3.pos, c3, "boolean"), r3.init = o3.value, i3.booleanMembers.push(this.finishNode(r3, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(o3.pos, c3, "number"), r3.init = o3.value, i3.numberMembers.push(this.finishNode(r3, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(o3.pos, c3, "string"), r3.init = o3.value, i3.stringMembers.push(this.finishNode(r3, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(o3.pos, c3);
                case "none":
                  switch (e3) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(o3.pos, c3);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(o3.pos, c3);
                      break;
                    default:
                      i3.defaultedMembers.push(this.finishNode(r3, "EnumDefaultedMember"));
                  }
              }
              this.match(n2.braceR) || this.expect(n2.comma);
            }
            return i3;
          }
          flowEnumStringMembers(t4, e3, {enumName: s3}) {
            if (t4.length === 0)
              return e3;
            if (e3.length === 0)
              return t4;
            if (e3.length > t4.length) {
              for (let e4 = 0; e4 < t4.length; e4++) {
                const i3 = t4[e4];
                this.flowEnumErrorStringMemberInconsistentlyInitailized(i3.start, {enumName: s3});
              }
              return e3;
            }
            for (let t5 = 0; t5 < e3.length; t5++) {
              const i3 = e3[t5];
              this.flowEnumErrorStringMemberInconsistentlyInitailized(i3.start, {enumName: s3});
            }
            return t4;
          }
          flowEnumParseExplicitType({enumName: t4}) {
            if (this.eatContextual("of")) {
              if (!this.match(n2.name))
                throw this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName: t4, suppliedType: null});
              const {value: e3} = this.state;
              return this.next(), e3 !== "boolean" && e3 !== "number" && e3 !== "string" && e3 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, {enumName: t4, suppliedType: e3}), e3;
            }
            return null;
          }
          flowEnumBody(t4, {enumName: e3, nameLoc: s3}) {
            const i3 = this.flowEnumParseExplicitType({enumName: e3});
            this.expect(n2.braceL);
            const r3 = this.flowEnumMembers({enumName: e3, explicitType: i3});
            switch (i3) {
              case "boolean":
                return t4.explicitType = true, t4.members = r3.booleanMembers, this.expect(n2.braceR), this.finishNode(t4, "EnumBooleanBody");
              case "number":
                return t4.explicitType = true, t4.members = r3.numberMembers, this.expect(n2.braceR), this.finishNode(t4, "EnumNumberBody");
              case "string":
                return t4.explicitType = true, t4.members = this.flowEnumStringMembers(r3.stringMembers, r3.defaultedMembers, {enumName: e3}), this.expect(n2.braceR), this.finishNode(t4, "EnumStringBody");
              case "symbol":
                return t4.members = r3.defaultedMembers, this.expect(n2.braceR), this.finishNode(t4, "EnumSymbolBody");
              default: {
                const i4 = () => (t4.members = [], this.expect(n2.braceR), this.finishNode(t4, "EnumStringBody"));
                t4.explicitType = false;
                const a3 = r3.booleanMembers.length, o3 = r3.numberMembers.length, h3 = r3.stringMembers.length, c3 = r3.defaultedMembers.length;
                if (a3 || o3 || h3 || c3) {
                  if (a3 || o3) {
                    if (!o3 && !h3 && a3 >= c3) {
                      for (let t5 = 0, s4 = r3.defaultedMembers; t5 < s4.length; t5++) {
                        const i5 = s4[t5];
                        this.flowEnumErrorBooleanMemberNotInitialized(i5.start, {enumName: e3, memberName: i5.id.name});
                      }
                      return t4.members = r3.booleanMembers, this.expect(n2.braceR), this.finishNode(t4, "EnumBooleanBody");
                    }
                    if (!a3 && !h3 && o3 >= c3) {
                      for (let t5 = 0, s4 = r3.defaultedMembers; t5 < s4.length; t5++) {
                        const i5 = s4[t5];
                        this.flowEnumErrorNumberMemberNotInitialized(i5.start, {enumName: e3, memberName: i5.id.name});
                      }
                      return t4.members = r3.numberMembers, this.expect(n2.braceR), this.finishNode(t4, "EnumNumberBody");
                    }
                    return this.flowEnumErrorInconsistentMemberValues(s3, {enumName: e3}), i4();
                  }
                  return t4.members = this.flowEnumStringMembers(r3.stringMembers, r3.defaultedMembers, {enumName: e3}), this.expect(n2.braceR), this.finishNode(t4, "EnumStringBody");
                }
                return i4();
              }
            }
          }
          flowParseEnumDeclaration(t4) {
            const e3 = this.parseIdentifier();
            return t4.id = e3, t4.body = this.flowEnumBody(this.startNode(), {enumName: e3.name, nameLoc: e3.start}), this.finishNode(t4, "EnumDeclaration");
          }
          updateContext(t4) {
            this.match(n2.name) && this.state.value === "of" && t4 === n2.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === "interface" ? this.state.exprAllowed = false : super.updateContext(t4);
          }
        }, typescript: (t3) => class extends t3 {
          getScopeHandler() {
            return Z2;
          }
          tsIsIdentifier() {
            return this.match(n2.name);
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), !(this.hasPrecedingLineBreak() || this.match(n2.parenL) || this.match(n2.parenR) || this.match(n2.colon) || this.match(n2.eq) || this.match(n2.question) || this.match(n2.bang));
          }
          tsParseModifier(t4) {
            if (!this.match(n2.name))
              return;
            const e3 = this.state.value;
            return t4.indexOf(e3) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? e3 : void 0;
          }
          tsParseModifiers(t4, e3) {
            for (; ; ) {
              const s3 = this.state.start, i3 = this.tsParseModifier(e3);
              if (!i3)
                break;
              Object.hasOwnProperty.call(t4, i3) && this.raise(s3, rt2.DuplicateModifier, i3), t4[i3] = true;
            }
          }
          tsIsListTerminator(t4) {
            switch (t4) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(n2.braceR);
              case "HeritageClauseElement":
                return this.match(n2.braceL);
              case "TupleElementTypes":
                return this.match(n2.bracketR);
              case "TypeParametersOrArguments":
                return this.isRelational(">");
            }
            throw new Error("Unreachable");
          }
          tsParseList(t4, e3) {
            const s3 = [];
            for (; !this.tsIsListTerminator(t4); )
              s3.push(e3());
            return s3;
          }
          tsParseDelimitedList(t4, e3) {
            return st2(this.tsParseDelimitedListWorker(t4, e3, true));
          }
          tsParseDelimitedListWorker(t4, e3, s3) {
            const i3 = [];
            for (; !this.tsIsListTerminator(t4); ) {
              const r3 = e3();
              if (r3 == null)
                return;
              if (i3.push(r3), !this.eat(n2.comma)) {
                if (this.tsIsListTerminator(t4))
                  break;
                return void (s3 && this.expect(n2.comma));
              }
            }
            return i3;
          }
          tsParseBracketedList(t4, e3, s3, i3) {
            i3 || (s3 ? this.expect(n2.bracketL) : this.expectRelational("<"));
            const r3 = this.tsParseDelimitedList(t4, e3);
            return s3 ? this.expect(n2.bracketR) : this.expectRelational(">"), r3;
          }
          tsParseImportType() {
            const t4 = this.startNode();
            return this.expect(n2._import), this.expect(n2.parenL), this.match(n2.string) || this.raise(this.state.start, rt2.UnsupportedImportTypeArgument), t4.argument = this.parseExprAtom(), this.expect(n2.parenR), this.eat(n2.dot) && (t4.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (t4.typeParameters = this.tsParseTypeArguments()), this.finishNode(t4, "TSImportType");
          }
          tsParseEntityName(t4) {
            let e3 = this.parseIdentifier();
            for (; this.eat(n2.dot); ) {
              const s3 = this.startNodeAtNode(e3);
              s3.left = e3, s3.right = this.parseIdentifier(t4), e3 = this.finishNode(s3, "TSQualifiedName");
            }
            return e3;
          }
          tsParseTypeReference() {
            const t4 = this.startNode();
            return t4.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (t4.typeParameters = this.tsParseTypeArguments()), this.finishNode(t4, "TSTypeReference");
          }
          tsParseThisTypePredicate(t4) {
            this.next();
            const e3 = this.startNodeAtNode(t4);
            return e3.parameterName = t4, e3.typeAnnotation = this.tsParseTypeAnnotation(false), this.finishNode(e3, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const t4 = this.startNode();
            return this.next(), this.finishNode(t4, "TSThisType");
          }
          tsParseTypeQuery() {
            const t4 = this.startNode();
            return this.expect(n2._typeof), this.match(n2._import) ? t4.exprName = this.tsParseImportType() : t4.exprName = this.tsParseEntityName(true), this.finishNode(t4, "TSTypeQuery");
          }
          tsParseTypeParameter() {
            const t4 = this.startNode();
            return t4.name = this.parseIdentifierName(t4.start), t4.constraint = this.tsEatThenParseType(n2._extends), t4.default = this.tsEatThenParseType(n2.eq), this.finishNode(t4, "TSTypeParameter");
          }
          tsTryParseTypeParameters() {
            if (this.isRelational("<"))
              return this.tsParseTypeParameters();
          }
          tsParseTypeParameters() {
            const t4 = this.startNode();
            return this.isRelational("<") || this.match(n2.jsxTagStart) ? this.next() : this.unexpected(), t4.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), this.finishNode(t4, "TSTypeParameterDeclaration");
          }
          tsTryNextParseConstantContext() {
            return this.lookahead().type === n2._const ? (this.next(), this.tsParseTypeReference()) : null;
          }
          tsFillSignature(t4, e3) {
            const s3 = t4 === n2.arrow;
            e3.typeParameters = this.tsTryParseTypeParameters(), this.expect(n2.parenL), e3.parameters = this.tsParseBindingListForSignature(), (s3 || this.match(t4)) && (e3.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t4));
          }
          tsParseBindingListForSignature() {
            return this.parseBindingList(n2.parenR, 41).map((t4) => (t4.type !== "Identifier" && t4.type !== "RestElement" && t4.type !== "ObjectPattern" && t4.type !== "ArrayPattern" && this.raise(t4.start, rt2.UnsupportedSignatureParameterKind, t4.type), t4));
          }
          tsParseTypeMemberSemicolon() {
            this.eat(n2.comma) || this.semicolon();
          }
          tsParseSignatureMember(t4, e3) {
            return this.tsFillSignature(n2.colon, e3), this.tsParseTypeMemberSemicolon(), this.finishNode(e3, t4);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), this.eat(n2.name) && this.match(n2.colon);
          }
          tsTryParseIndexSignature(t4) {
            if (!this.match(n2.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
              return;
            this.expect(n2.bracketL);
            const e3 = this.parseIdentifier();
            e3.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e3), this.expect(n2.bracketR), t4.parameters = [e3];
            const s3 = this.tsTryParseTypeAnnotation();
            return s3 && (t4.typeAnnotation = s3), this.tsParseTypeMemberSemicolon(), this.finishNode(t4, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(t4, e3) {
            this.eat(n2.question) && (t4.optional = true);
            const s3 = t4;
            if (e3 || !this.match(n2.parenL) && !this.isRelational("<")) {
              const t5 = s3;
              e3 && (t5.readonly = true);
              const i3 = this.tsTryParseTypeAnnotation();
              return i3 && (t5.typeAnnotation = i3), this.tsParseTypeMemberSemicolon(), this.finishNode(t5, "TSPropertySignature");
            }
            {
              const t5 = s3;
              return this.tsFillSignature(n2.colon, t5), this.tsParseTypeMemberSemicolon(), this.finishNode(t5, "TSMethodSignature");
            }
          }
          tsParseTypeMember() {
            const t4 = this.startNode();
            if (this.match(n2.parenL) || this.isRelational("<"))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", t4);
            if (this.match(n2._new)) {
              const e4 = this.startNode();
              return this.next(), this.match(n2.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t4) : (t4.key = this.createIdentifier(e4, "new"), this.tsParsePropertyOrMethodSignature(t4, false));
            }
            const e3 = !!this.tsParseModifier(["readonly"]), s3 = this.tsTryParseIndexSignature(t4);
            return s3 ? (e3 && (t4.readonly = true), s3) : (this.parsePropertyName(t4, false), this.tsParsePropertyOrMethodSignature(t4, e3));
          }
          tsParseTypeLiteral() {
            const t4 = this.startNode();
            return t4.members = this.tsParseObjectTypeMembers(), this.finishNode(t4, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(n2.braceL);
            const t4 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(n2.braceR), t4;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(n2.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(n2.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(n2._in))));
          }
          tsParseMappedTypeParameter() {
            const t4 = this.startNode();
            return t4.name = this.parseIdentifierName(t4.start), t4.constraint = this.tsExpectThenParseType(n2._in), this.finishNode(t4, "TSTypeParameter");
          }
          tsParseMappedType() {
            const t4 = this.startNode();
            return this.expect(n2.braceL), this.match(n2.plusMin) ? (t4.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (t4.readonly = true), this.expect(n2.bracketL), t4.typeParameter = this.tsParseMappedTypeParameter(), this.expect(n2.bracketR), this.match(n2.plusMin) ? (t4.optional = this.state.value, this.next(), this.expect(n2.question)) : this.eat(n2.question) && (t4.optional = true), t4.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(n2.braceR), this.finishNode(t4, "TSMappedType");
          }
          tsParseTupleType() {
            const t4 = this.startNode();
            t4.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let e3 = false, s3 = null;
            return t4.elementTypes.forEach((t5) => {
              var i3;
              let {type: r3} = t5;
              !e3 || r3 === "TSRestType" || r3 === "TSOptionalType" || r3 === "TSNamedTupleMember" && t5.optional || this.raise(t5.start, rt2.OptionalTypeBeforeRequired), e3 = e3 || r3 === "TSNamedTupleMember" && t5.optional || r3 === "TSOptionalType", r3 === "TSRestType" && (r3 = (t5 = t5.typeAnnotation).type);
              const a3 = r3 === "TSNamedTupleMember";
              s3 = (i3 = s3) != null ? i3 : a3, s3 !== a3 && this.raise(t5.start, rt2.MixedLabeledAndUnlabeledElements);
            }), this.finishNode(t4, "TSTupleType");
          }
          tsParseTupleElementType() {
            const {start: t4, startLoc: e3} = this.state, s3 = this.eat(n2.ellipsis);
            let i3 = this.tsParseType();
            const r3 = this.eat(n2.question);
            if (this.eat(n2.colon)) {
              const t5 = this.startNodeAtNode(i3);
              t5.optional = r3, i3.type !== "TSTypeReference" || i3.typeParameters || i3.typeName.type !== "Identifier" ? (this.raise(i3.start, rt2.InvalidTupleMemberLabel), t5.label = i3) : t5.label = i3.typeName, t5.elementType = this.tsParseType(), i3 = this.finishNode(t5, "TSNamedTupleMember");
            } else if (r3) {
              const t5 = this.startNodeAtNode(i3);
              t5.typeAnnotation = i3, i3 = this.finishNode(t5, "TSOptionalType");
            }
            if (s3) {
              const s4 = this.startNodeAt(t4, e3);
              s4.typeAnnotation = i3, i3 = this.finishNode(s4, "TSRestType");
            }
            return i3;
          }
          tsParseParenthesizedType() {
            const t4 = this.startNode();
            return this.expect(n2.parenL), t4.typeAnnotation = this.tsParseType(), this.expect(n2.parenR), this.finishNode(t4, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(t4) {
            const e3 = this.startNode();
            return t4 === "TSConstructorType" && this.expect(n2._new), this.tsFillSignature(n2.arrow, e3), this.finishNode(e3, t4);
          }
          tsParseLiteralTypeNode() {
            const t4 = this.startNode();
            return t4.literal = (() => {
              switch (this.state.type) {
                case n2.num:
                case n2.bigint:
                case n2.string:
                case n2._true:
                case n2._false:
                  return this.parseExprAtom();
                default:
                  throw this.unexpected();
              }
            })(), this.finishNode(t4, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const t4 = this.startNode(), e3 = this.parseTemplate(false);
            return e3.expressions.length > 0 && this.raise(e3.expressions[0].start, rt2.TemplateTypeHasSubstitution), t4.literal = e3, this.finishNode(t4, "TSLiteralType");
          }
          tsParseThisTypeOrThisTypePredicate() {
            const t4 = this.tsParseThisTypeNode();
            return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t4) : t4;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case n2.name:
              case n2._void:
              case n2._null: {
                const t4 = this.match(n2._void) ? "TSVoidKeyword" : this.match(n2._null) ? "TSNullKeyword" : function(t5) {
                  switch (t5) {
                    case "any":
                      return "TSAnyKeyword";
                    case "boolean":
                      return "TSBooleanKeyword";
                    case "bigint":
                      return "TSBigIntKeyword";
                    case "never":
                      return "TSNeverKeyword";
                    case "number":
                      return "TSNumberKeyword";
                    case "object":
                      return "TSObjectKeyword";
                    case "string":
                      return "TSStringKeyword";
                    case "symbol":
                      return "TSSymbolKeyword";
                    case "undefined":
                      return "TSUndefinedKeyword";
                    case "unknown":
                      return "TSUnknownKeyword";
                    default:
                      return;
                  }
                }(this.state.value);
                if (t4 !== void 0 && this.lookaheadCharCode() !== 46) {
                  const e3 = this.startNode();
                  return this.next(), this.finishNode(e3, t4);
                }
                return this.tsParseTypeReference();
              }
              case n2.string:
              case n2.num:
              case n2.bigint:
              case n2._true:
              case n2._false:
                return this.tsParseLiteralTypeNode();
              case n2.plusMin:
                if (this.state.value === "-") {
                  const t4 = this.startNode(), e3 = this.lookahead();
                  if (e3.type !== n2.num && e3.type !== n2.bigint)
                    throw this.unexpected();
                  return t4.literal = this.parseMaybeUnary(), this.finishNode(t4, "TSLiteralType");
                }
                break;
              case n2._this:
                return this.tsParseThisTypeOrThisTypePredicate();
              case n2._typeof:
                return this.tsParseTypeQuery();
              case n2._import:
                return this.tsParseImportType();
              case n2.braceL:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case n2.bracketL:
                return this.tsParseTupleType();
              case n2.parenL:
                return this.tsParseParenthesizedType();
              case n2.backQuote:
                return this.tsParseTemplateLiteralType();
            }
            throw this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let t4 = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(n2.bracketL); )
              if (this.match(n2.bracketR)) {
                const e3 = this.startNodeAtNode(t4);
                e3.elementType = t4, this.expect(n2.bracketR), t4 = this.finishNode(e3, "TSArrayType");
              } else {
                const e3 = this.startNodeAtNode(t4);
                e3.objectType = t4, e3.indexType = this.tsParseType(), this.expect(n2.bracketR), t4 = this.finishNode(e3, "TSIndexedAccessType");
              }
            return t4;
          }
          tsParseTypeOperator(t4) {
            const e3 = this.startNode();
            return this.expectContextual(t4), e3.operator = t4, e3.typeAnnotation = this.tsParseTypeOperatorOrHigher(), t4 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e3), this.finishNode(e3, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(t4) {
            switch (t4.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(t4.start, rt2.UnexpectedReadonly);
            }
          }
          tsParseInferType() {
            const t4 = this.startNode();
            this.expectContextual("infer");
            const e3 = this.startNode();
            return e3.name = this.parseIdentifierName(e3.start), t4.typeParameter = this.finishNode(e3, "TSTypeParameter"), this.finishNode(t4, "TSInferType");
          }
          tsParseTypeOperatorOrHigher() {
            const t4 = ["keyof", "unique", "readonly"].find((t5) => this.isContextual(t5));
            return t4 ? this.tsParseTypeOperator(t4) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
          }
          tsParseUnionOrIntersectionType(t4, e3, s3) {
            this.eat(s3);
            let i3 = e3();
            if (this.match(s3)) {
              const r3 = [i3];
              for (; this.eat(s3); )
                r3.push(e3());
              const a3 = this.startNodeAtNode(i3);
              a3.types = r3, i3 = this.finishNode(a3, t4);
            }
            return i3;
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), n2.bitwiseAND);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), n2.bitwiseOR);
          }
          tsIsStartOfFunctionType() {
            return !!this.isRelational("<") || this.match(n2.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (this.match(n2.name) || this.match(n2._this))
              return this.next(), true;
            if (this.match(n2.braceL)) {
              let t4 = 1;
              for (this.next(); t4 > 0; )
                this.match(n2.braceL) ? ++t4 : this.match(n2.braceR) && --t4, this.next();
              return true;
            }
            if (this.match(n2.bracketL)) {
              let t4 = 1;
              for (this.next(); t4 > 0; )
                this.match(n2.bracketL) ? ++t4 : this.match(n2.bracketR) && --t4, this.next();
              return true;
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(n2.parenR) || this.match(n2.ellipsis))
              return true;
            if (this.tsSkipParameterStart()) {
              if (this.match(n2.colon) || this.match(n2.comma) || this.match(n2.question) || this.match(n2.eq))
                return true;
              if (this.match(n2.parenR) && (this.next(), this.match(n2.arrow)))
                return true;
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(t4) {
            return this.tsInType(() => {
              const e3 = this.startNode();
              this.expect(t4);
              const s3 = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (s3 && this.match(n2._this)) {
                let t5 = this.tsParseThisTypeOrThisTypePredicate();
                if (t5.type === "TSThisType") {
                  const s4 = this.startNodeAtNode(e3);
                  s4.parameterName = t5, s4.asserts = true, t5 = this.finishNode(s4, "TSTypePredicate");
                } else
                  t5.asserts = true;
                return e3.typeAnnotation = t5, this.finishNode(e3, "TSTypeAnnotation");
              }
              const i3 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!i3) {
                if (!s3)
                  return this.tsParseTypeAnnotation(false, e3);
                const t5 = this.startNodeAtNode(e3);
                return t5.parameterName = this.parseIdentifier(), t5.asserts = s3, e3.typeAnnotation = this.finishNode(t5, "TSTypePredicate"), this.finishNode(e3, "TSTypeAnnotation");
              }
              const r3 = this.tsParseTypeAnnotation(false), a3 = this.startNodeAtNode(e3);
              return a3.parameterName = i3, a3.typeAnnotation = r3, a3.asserts = s3, e3.typeAnnotation = this.finishNode(a3, "TSTypePredicate"), this.finishNode(e3, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            return this.match(n2.colon) ? this.tsParseTypeOrTypePredicateAnnotation(n2.colon) : void 0;
          }
          tsTryParseTypeAnnotation() {
            return this.match(n2.colon) ? this.tsParseTypeAnnotation() : void 0;
          }
          tsTryParseType() {
            return this.tsEatThenParseType(n2.colon);
          }
          tsParseTypePredicatePrefix() {
            const t4 = this.parseIdentifier();
            if (this.isContextual("is") && !this.hasPrecedingLineBreak())
              return this.next(), t4;
          }
          tsParseTypePredicateAsserts() {
            if (!this.match(n2.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak())
              return false;
            const t4 = this.state.containsEsc;
            return this.next(), !(!this.match(n2.name) && !this.match(n2._this)) && (t4 && this.raise(this.state.lastTokStart, f2.InvalidEscapedReservedWord, "asserts"), true);
          }
          tsParseTypeAnnotation(t4 = true, e3 = this.startNode()) {
            return this.tsInType(() => {
              t4 && this.expect(n2.colon), e3.typeAnnotation = this.tsParseType();
            }), this.finishNode(e3, "TSTypeAnnotation");
          }
          tsParseType() {
            it2(this.state.inType);
            const t4 = this.tsParseNonConditionalType();
            if (this.hasPrecedingLineBreak() || !this.eat(n2._extends))
              return t4;
            const e3 = this.startNodeAtNode(t4);
            return e3.checkType = t4, e3.extendsType = this.tsParseNonConditionalType(), this.expect(n2.question), e3.trueType = this.tsParseType(), this.expect(n2.colon), e3.falseType = this.tsParseType(), this.finishNode(e3, "TSConditionalType");
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(n2._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            const t4 = this.startNode(), e3 = this.tsTryNextParseConstantContext();
            return t4.typeAnnotation = e3 || this.tsNextThenParseType(), this.expectRelational(">"), t4.expression = this.parseMaybeUnary(), this.finishNode(t4, "TSTypeAssertion");
          }
          tsParseHeritageClause(t4) {
            const e3 = this.state.start, s3 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
            return s3.length || this.raise(e3, rt2.EmptyHeritageClauseType, t4), s3;
          }
          tsParseExpressionWithTypeArguments() {
            const t4 = this.startNode();
            return t4.expression = this.tsParseEntityName(false), this.isRelational("<") && (t4.typeParameters = this.tsParseTypeArguments()), this.finishNode(t4, "TSExpressionWithTypeArguments");
          }
          tsParseInterfaceDeclaration(t4) {
            t4.id = this.parseIdentifier(), this.checkLVal(t4.id, 130, void 0, "typescript interface declaration"), t4.typeParameters = this.tsTryParseTypeParameters(), this.eat(n2._extends) && (t4.extends = this.tsParseHeritageClause("extends"));
            const e3 = this.startNode();
            return e3.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t4.body = this.finishNode(e3, "TSInterfaceBody"), this.finishNode(t4, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(t4) {
            return t4.id = this.parseIdentifier(), this.checkLVal(t4.id, 2, void 0, "typescript type alias"), t4.typeParameters = this.tsTryParseTypeParameters(), t4.typeAnnotation = this.tsExpectThenParseType(n2.eq), this.semicolon(), this.finishNode(t4, "TSTypeAliasDeclaration");
          }
          tsInNoContext(t4) {
            const e3 = this.state.context;
            this.state.context = [e3[0]];
            try {
              return t4();
            } finally {
              this.state.context = e3;
            }
          }
          tsInType(t4) {
            const e3 = this.state.inType;
            this.state.inType = true;
            try {
              return t4();
            } finally {
              this.state.inType = e3;
            }
          }
          tsEatThenParseType(t4) {
            return this.match(t4) ? this.tsNextThenParseType() : void 0;
          }
          tsExpectThenParseType(t4) {
            return this.tsDoThenParseType(() => this.expect(t4));
          }
          tsNextThenParseType() {
            return this.tsDoThenParseType(() => this.next());
          }
          tsDoThenParseType(t4) {
            return this.tsInType(() => (t4(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const t4 = this.startNode();
            return t4.id = this.match(n2.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(n2.eq) && (t4.initializer = this.parseMaybeAssign()), this.finishNode(t4, "TSEnumMember");
          }
          tsParseEnumDeclaration(t4, e3) {
            return e3 && (t4.const = true), t4.id = this.parseIdentifier(), this.checkLVal(t4.id, e3 ? 779 : 267, void 0, "typescript enum declaration"), this.expect(n2.braceL), t4.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(n2.braceR), this.finishNode(t4, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const t4 = this.startNode();
            return this.scope.enter(0), this.expect(n2.braceL), this.parseBlockOrModuleBlockBody(t4.body = [], void 0, true, n2.braceR), this.scope.exit(), this.finishNode(t4, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(t4, e3 = false) {
            if (t4.id = this.parseIdentifier(), e3 || this.checkLVal(t4.id, 1024, null, "module or namespace declaration"), this.eat(n2.dot)) {
              const e4 = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(e4, true), t4.body = e4;
            } else
              this.scope.enter(128), this.prodParam.enter(0), t4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(t4, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(t4) {
            return this.isContextual("global") ? (t4.global = true, t4.id = this.parseIdentifier()) : this.match(n2.string) ? t4.id = this.parseExprAtom() : this.unexpected(), this.match(n2.braceL) ? (this.scope.enter(128), this.prodParam.enter(0), t4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t4, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(t4, e3) {
            return t4.isExport = e3 || false, t4.id = this.parseIdentifier(), this.checkLVal(t4.id, 9, void 0, "import equals declaration"), this.expect(n2.eq), t4.moduleReference = this.tsParseModuleReference(), this.semicolon(), this.finishNode(t4, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual("require") && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const t4 = this.startNode();
            if (this.expectContextual("require"), this.expect(n2.parenL), !this.match(n2.string))
              throw this.unexpected();
            return t4.expression = this.parseExprAtom(), this.expect(n2.parenR), this.finishNode(t4, "TSExternalModuleReference");
          }
          tsLookAhead(t4) {
            const e3 = this.state.clone(), s3 = t4();
            return this.state = e3, s3;
          }
          tsTryParseAndCatch(t4) {
            const e3 = this.tryParse((e4) => t4() || e4());
            if (!e3.aborted && e3.node)
              return e3.error && (this.state = e3.failState), e3.node;
          }
          tsTryParse(t4) {
            const e3 = this.state.clone(), s3 = t4();
            return s3 !== void 0 && s3 !== false ? s3 : void (this.state = e3);
          }
          tsTryParseDeclare(t4) {
            if (this.isLineTerminator())
              return;
            let e3, s3 = this.state.type;
            switch (this.isContextual("let") && (s3 = n2._var, e3 = "let"), s3) {
              case n2._function:
                return this.parseFunctionStatement(t4, false, true);
              case n2._class:
                return t4.declare = true, this.parseClass(t4, true, false);
              case n2._const:
                if (this.match(n2._const) && this.isLookaheadContextual("enum"))
                  return this.expect(n2._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t4, true);
              case n2._var:
                return e3 = e3 || this.state.value, this.parseVarStatement(t4, e3);
              case n2.name: {
                const e4 = this.state.value;
                return e4 === "global" ? this.tsParseAmbientExternalModuleDeclaration(t4) : this.tsParseDeclaration(t4, e4, true);
              }
            }
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true);
          }
          tsParseExpressionStatement(t4, e3) {
            switch (e3.name) {
              case "declare": {
                const e4 = this.tsTryParseDeclare(t4);
                if (e4)
                  return e4.declare = true, e4;
                break;
              }
              case "global":
                if (this.match(n2.braceL)) {
                  this.scope.enter(128), this.prodParam.enter(0);
                  const s3 = t4;
                  return s3.global = true, s3.id = e3, s3.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s3, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(t4, e3.name, false);
            }
          }
          tsParseDeclaration(t4, e3, s3) {
            switch (e3) {
              case "abstract":
                if (this.tsCheckLineTerminatorAndMatch(n2._class, s3)) {
                  const e4 = t4;
                  return e4.abstract = true, s3 && (this.next(), this.match(n2._class) || this.unexpected(null, n2._class)), this.parseClass(e4, true, false);
                }
                break;
              case "enum":
                if (s3 || this.match(n2.name))
                  return s3 && this.next(), this.tsParseEnumDeclaration(t4, false);
                break;
              case "interface":
                if (this.tsCheckLineTerminatorAndMatch(n2.name, s3))
                  return s3 && this.next(), this.tsParseInterfaceDeclaration(t4);
                break;
              case "module":
                if (s3 && this.next(), this.match(n2.string))
                  return this.tsParseAmbientExternalModuleDeclaration(t4);
                if (this.tsCheckLineTerminatorAndMatch(n2.name, s3))
                  return this.tsParseModuleOrNamespaceDeclaration(t4);
                break;
              case "namespace":
                if (this.tsCheckLineTerminatorAndMatch(n2.name, s3))
                  return s3 && this.next(), this.tsParseModuleOrNamespaceDeclaration(t4);
                break;
              case "type":
                if (this.tsCheckLineTerminatorAndMatch(n2.name, s3))
                  return s3 && this.next(), this.tsParseTypeAliasDeclaration(t4);
            }
          }
          tsCheckLineTerminatorAndMatch(t4, e3) {
            return (e3 || this.match(t4)) && !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(t4, e3) {
            if (!this.isRelational("<"))
              return;
            const s3 = this.state.maybeInArrowParameters, i3 = this.state.yieldPos, r3 = this.state.awaitPos;
            this.state.maybeInArrowParameters = true, this.state.yieldPos = -1, this.state.awaitPos = -1;
            const a3 = this.tsTryParseAndCatch(() => {
              const s4 = this.startNodeAt(t4, e3);
              return s4.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s4), s4.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(n2.arrow), s4;
            });
            return this.state.maybeInArrowParameters = s3, this.state.yieldPos = i3, this.state.awaitPos = r3, a3 ? this.parseArrowExpression(a3, null, true) : void 0;
          }
          tsParseTypeArguments() {
            const t4 = this.startNode();
            return t4.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), this.state.exprAllowed = false, this.expectRelational(">"), this.finishNode(t4, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            if (this.match(n2.name))
              switch (this.state.value) {
                case "abstract":
                case "declare":
                case "enum":
                case "interface":
                case "module":
                case "namespace":
                case "type":
                  return true;
              }
            return false;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(t4, e3) {
            const s3 = this.state.start, i3 = this.state.startLoc;
            let r3, a3 = false;
            t4 && (r3 = this.parseAccessModifier(), a3 = !!this.tsParseModifier(["readonly"]));
            const n3 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(n3);
            const o3 = this.parseMaybeDefault(n3.start, n3.loc.start, n3);
            if (r3 || a3) {
              const t5 = this.startNodeAt(s3, i3);
              return e3.length && (t5.decorators = e3), r3 && (t5.accessibility = r3), a3 && (t5.readonly = a3), o3.type !== "Identifier" && o3.type !== "AssignmentPattern" && this.raise(t5.start, rt2.UnsupportedParameterPropertyKind), t5.parameter = o3, this.finishNode(t5, "TSParameterProperty");
            }
            return e3.length && (n3.decorators = e3), o3;
          }
          parseFunctionBodyAndFinish(t4, e3, s3 = false) {
            this.match(n2.colon) && (t4.returnType = this.tsParseTypeOrTypePredicateAnnotation(n2.colon));
            const i3 = e3 === "FunctionDeclaration" ? "TSDeclareFunction" : e3 === "ClassMethod" ? "TSDeclareMethod" : void 0;
            i3 && !this.match(n2.braceL) && this.isLineTerminator() ? this.finishNode(t4, i3) : super.parseFunctionBodyAndFinish(t4, e3, s3);
          }
          registerFunctionStatementId(t4) {
            !t4.body && t4.id ? this.checkLVal(t4.id, 1024, null, "function name") : super.registerFunctionStatementId(...arguments);
          }
          parseSubscript(t4, e3, s3, i3, r3) {
            if (!this.hasPrecedingLineBreak() && this.match(n2.bang)) {
              this.state.exprAllowed = false, this.next();
              const i4 = this.startNodeAt(e3, s3);
              return i4.expression = t4, this.finishNode(i4, "TSNonNullExpression");
            }
            if (this.isRelational("<")) {
              const a3 = this.tsTryParseAndCatch(() => {
                if (!i3 && this.atPossibleAsyncArrow(t4)) {
                  const t5 = this.tsTryParseGenericAsyncArrowFunction(e3, s3);
                  if (t5)
                    return t5;
                }
                const a4 = this.startNodeAt(e3, s3);
                a4.callee = t4;
                const o3 = this.tsParseTypeArguments();
                if (o3) {
                  if (!i3 && this.eat(n2.parenL))
                    return a4.arguments = this.parseCallExpressionArguments(n2.parenR, false), a4.typeParameters = o3, this.finishCallExpression(a4, r3.optionalChainMember);
                  if (this.match(n2.backQuote)) {
                    const i4 = this.parseTaggedTemplateExpression(t4, e3, s3, r3);
                    return i4.typeParameters = o3, i4;
                  }
                }
                this.unexpected();
              });
              if (a3)
                return a3;
            }
            return super.parseSubscript(t4, e3, s3, i3, r3);
          }
          parseNewArguments(t4) {
            if (this.isRelational("<")) {
              const e3 = this.tsTryParseAndCatch(() => {
                const t5 = this.tsParseTypeArguments();
                return this.match(n2.parenL) || this.unexpected(), t5;
              });
              e3 && (t4.typeParameters = e3);
            }
            super.parseNewArguments(t4);
          }
          parseExprOp(t4, e3, s3, i3, r3) {
            if (st2(n2._in.binop) > i3 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
              const a3 = this.startNodeAt(e3, s3);
              a3.expression = t4;
              const n3 = this.tsTryNextParseConstantContext();
              return a3.typeAnnotation = n3 || this.tsNextThenParseType(), this.finishNode(a3, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a3, e3, s3, i3, r3);
            }
            return super.parseExprOp(t4, e3, s3, i3, r3);
          }
          checkReservedWord(t4, e3, s3, i3) {
          }
          checkDuplicateExports() {
          }
          parseImport(t4) {
            if (this.match(n2.name) || this.match(n2.star) || this.match(n2.braceL)) {
              const e4 = this.lookahead();
              if (this.match(n2.name) && e4.type === n2.eq)
                return this.tsParseImportEqualsDeclaration(t4);
              !this.isContextual("type") || e4.type === n2.comma || e4.type === n2.name && e4.value === "from" ? t4.importKind = "value" : (t4.importKind = "type", this.next());
            }
            const e3 = super.parseImport(t4);
            return e3.importKind === "type" && e3.specifiers.length > 1 && e3.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(e3.start, "A type-only import can specify a default import or named bindings, but not both."), e3;
          }
          parseExport(t4) {
            if (this.match(n2._import))
              return this.expect(n2._import), this.tsParseImportEqualsDeclaration(t4, true);
            if (this.eat(n2.eq)) {
              const e3 = t4;
              return e3.expression = this.parseExpression(), this.semicolon(), this.finishNode(e3, "TSExportAssignment");
            }
            if (this.eatContextual("as")) {
              const e3 = t4;
              return this.expectContextual("namespace"), e3.id = this.parseIdentifier(), this.semicolon(), this.finishNode(e3, "TSNamespaceExportDeclaration");
            }
            return this.isContextual("type") && this.lookahead().type === n2.braceL ? (this.next(), t4.exportKind = "type") : t4.exportKind = "value", super.parseExport(t4);
          }
          isAbstractClass() {
            return this.isContextual("abstract") && this.lookahead().type === n2._class;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const t4 = this.startNode();
              return this.next(), this.parseClass(t4, true, true), t4.abstract = true, t4;
            }
            if (this.state.value === "interface") {
              const t4 = this.tsParseDeclaration(this.startNode(), this.state.value, true);
              if (t4)
                return t4;
            }
            return super.parseExportDefaultExpression();
          }
          parseStatementContent(t4, e3) {
            if (this.state.type === n2._const) {
              const t5 = this.lookahead();
              if (t5.type === n2.name && t5.value === "enum") {
                const t6 = this.startNode();
                return this.expect(n2._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t6, true);
              }
            }
            return super.parseStatementContent(t4, e3);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          parseClassMember(t4, e3, s3, i3) {
            this.tsParseModifiers(e3, ["declare"]);
            const r3 = this.parseAccessModifier();
            r3 && (e3.accessibility = r3), this.tsParseModifiers(e3, ["declare"]), super.parseClassMember(t4, e3, s3, i3);
          }
          parseClassMemberWithIsStatic(t4, e3, s3, i3, r3) {
            this.tsParseModifiers(e3, ["abstract", "readonly", "declare"]);
            const a3 = this.tsTryParseIndexSignature(e3);
            if (a3)
              return t4.body.push(a3), e3.abstract && this.raise(e3.start, rt2.IndexSignatureHasAbstract), i3 && this.raise(e3.start, rt2.IndexSignatureHasStatic), void (e3.accessibility && this.raise(e3.start, rt2.IndexSignatureHasAccessibility, e3.accessibility));
            super.parseClassMemberWithIsStatic(t4, e3, s3, i3, r3);
          }
          parsePostMemberNameModifiers(t4) {
            this.eat(n2.question) && (t4.optional = true), t4.readonly && this.match(n2.parenL) && this.raise(t4.start, rt2.ClassMethodHasReadonly), t4.declare && this.match(n2.parenL) && this.raise(t4.start, rt2.ClassMethodHasDeclare);
          }
          parseExpressionStatement(t4, e3) {
            return (e3.type === "Identifier" ? this.tsParseExpressionStatement(t4, e3) : void 0) || super.parseExpressionStatement(t4, e3);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(t4, e3, s3, i3, r3) {
            if (!r3 || !this.match(n2.question))
              return super.parseConditional(t4, e3, s3, i3, r3);
            const a3 = this.tryParse(() => super.parseConditional(t4, e3, s3, i3));
            return a3.node ? (a3.error && (this.state = a3.failState), a3.node) : (r3.start = a3.error.pos || this.state.start, t4);
          }
          parseParenItem(t4, e3, s3) {
            if (t4 = super.parseParenItem(t4, e3, s3), this.eat(n2.question) && (t4.optional = true, this.resetEndLocation(t4)), this.match(n2.colon)) {
              const i3 = this.startNodeAt(e3, s3);
              return i3.expression = t4, i3.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i3, "TSTypeCastExpression");
            }
            return t4;
          }
          parseExportDeclaration(t4) {
            const e3 = this.state.start, s3 = this.state.startLoc, i3 = this.eatContextual("declare");
            let r3;
            return this.match(n2.name) && (r3 = this.tsTryParseExportDeclaration()), r3 || (r3 = super.parseExportDeclaration(t4)), r3 && (r3.type === "TSInterfaceDeclaration" || r3.type === "TSTypeAliasDeclaration" || i3) && (t4.exportKind = "type"), r3 && i3 && (this.resetStartLocation(r3, e3, s3), r3.declare = true), r3;
          }
          parseClassId(t4, e3, s3) {
            if ((!e3 || s3) && this.isContextual("implements"))
              return;
            super.parseClassId(t4, e3, s3, t4.declare ? 1024 : 139);
            const i3 = this.tsTryParseTypeParameters();
            i3 && (t4.typeParameters = i3);
          }
          parseClassPropertyAnnotation(t4) {
            !t4.optional && this.eat(n2.bang) && (t4.definite = true);
            const e3 = this.tsTryParseTypeAnnotation();
            e3 && (t4.typeAnnotation = e3);
          }
          parseClassProperty(t4) {
            return this.parseClassPropertyAnnotation(t4), t4.declare && this.match(n2.equal) && this.raise(this.state.start, rt2.DeclareClassFieldHasInitializer), super.parseClassProperty(t4);
          }
          parseClassPrivateProperty(t4) {
            return t4.abstract && this.raise(t4.start, rt2.PrivateElementHasAbstract), t4.accessibility && this.raise(t4.start, rt2.PrivateElementHasAccessibility, t4.accessibility), this.parseClassPropertyAnnotation(t4), super.parseClassPrivateProperty(t4);
          }
          pushClassMethod(t4, e3, s3, i3, r3, a3) {
            const n3 = this.tsTryParseTypeParameters();
            n3 && (e3.typeParameters = n3), super.pushClassMethod(t4, e3, s3, i3, r3, a3);
          }
          pushClassPrivateMethod(t4, e3, s3, i3) {
            const r3 = this.tsTryParseTypeParameters();
            r3 && (e3.typeParameters = r3), super.pushClassPrivateMethod(t4, e3, s3, i3);
          }
          parseClassSuper(t4) {
            super.parseClassSuper(t4), t4.superClass && this.isRelational("<") && (t4.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (t4.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(t4, ...e3) {
            const s3 = this.tsTryParseTypeParameters();
            s3 && (t4.typeParameters = s3), super.parseObjPropValue(t4, ...e3);
          }
          parseFunctionParams(t4, e3) {
            const s3 = this.tsTryParseTypeParameters();
            s3 && (t4.typeParameters = s3), super.parseFunctionParams(t4, e3);
          }
          parseVarId(t4, e3) {
            super.parseVarId(t4, e3), t4.id.type === "Identifier" && this.eat(n2.bang) && (t4.definite = true);
            const s3 = this.tsTryParseTypeAnnotation();
            s3 && (t4.id.typeAnnotation = s3, this.resetEndLocation(t4.id));
          }
          parseAsyncArrowFromCallExpression(t4, e3) {
            return this.match(n2.colon) && (t4.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t4, e3);
          }
          parseMaybeAssign(...t4) {
            var e3, s3, i3, r3, a3, o3, h3;
            let c3, p3, u3, l3;
            if (this.match(n2.jsxTagStart)) {
              if (c3 = this.state.clone(), p3 = this.tryParse(() => super.parseMaybeAssign(...t4), c3), !p3.error)
                return p3.node;
              const {context: e4} = this.state;
              e4[e4.length - 1] === x2.j_oTag ? e4.length -= 2 : e4[e4.length - 1] === x2.j_expr && (e4.length -= 1);
            }
            if (!((e3 = p3) == null ? void 0 : e3.error) && !this.isRelational("<"))
              return super.parseMaybeAssign(...t4);
            c3 = c3 || this.state.clone();
            const d3 = this.tryParse((e4) => {
              var s4;
              l3 = this.tsParseTypeParameters();
              const i4 = super.parseMaybeAssign(...t4);
              return (i4.type !== "ArrowFunctionExpression" || i4.extra && i4.extra.parenthesized) && e4(), ((s4 = l3) == null ? void 0 : s4.params.length) !== 0 && this.resetStartLocationFromNode(i4, l3), i4.typeParameters = l3, i4;
            }, c3);
            if (!d3.error && !d3.aborted)
              return d3.node;
            if (!p3 && (it2(!this.hasPlugin("jsx")), u3 = this.tryParse(() => super.parseMaybeAssign(...t4), c3), !u3.error))
              return u3.node;
            if ((s3 = p3) == null ? void 0 : s3.node)
              return this.state = p3.failState, p3.node;
            if (d3.node)
              return this.state = d3.failState, d3.node;
            if ((i3 = u3) == null ? void 0 : i3.node)
              return this.state = u3.failState, u3.node;
            if ((r3 = p3) == null ? void 0 : r3.thrown)
              throw p3.error;
            if (d3.thrown)
              throw d3.error;
            if ((a3 = u3) == null ? void 0 : a3.thrown)
              throw u3.error;
            throw ((o3 = p3) == null ? void 0 : o3.error) || d3.error || ((h3 = u3) == null ? void 0 : h3.error);
          }
          parseMaybeUnary(t4) {
            return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t4);
          }
          parseArrow(t4) {
            if (this.match(n2.colon)) {
              const e3 = this.tryParse((t5) => {
                const e4 = this.tsParseTypeOrTypePredicateAnnotation(n2.colon);
                return !this.canInsertSemicolon() && this.match(n2.arrow) || t5(), e4;
              });
              if (e3.aborted)
                return;
              e3.thrown || (e3.error && (this.state = e3.failState), t4.returnType = e3.node);
            }
            return super.parseArrow(t4);
          }
          parseAssignableListItemTypes(t4) {
            this.eat(n2.question) && (t4.type !== "Identifier" && this.raise(t4.start, rt2.PatternIsOptional), t4.optional = true);
            const e3 = this.tsTryParseTypeAnnotation();
            return e3 && (t4.typeAnnotation = e3), this.resetEndLocation(t4), t4;
          }
          toAssignable(t4) {
            switch (t4.type) {
              case "TSTypeCastExpression":
                return super.toAssignable(this.typeCastToParameter(t4));
              case "TSParameterProperty":
                return super.toAssignable(t4);
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                return t4.expression = this.toAssignable(t4.expression), t4;
              default:
                return super.toAssignable(t4);
            }
          }
          checkLVal(t4, e3 = 64, s3, i3) {
            switch (t4.type) {
              case "TSTypeCastExpression":
                return;
              case "TSParameterProperty":
                return void this.checkLVal(t4.parameter, e3, s3, "parameter property");
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                return void this.checkLVal(t4.expression, e3, s3, i3);
              default:
                return void super.checkLVal(t4, e3, s3, i3);
            }
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case n2._this:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseMaybeDecoratorArguments(t4) {
            if (this.isRelational("<")) {
              const e3 = this.tsParseTypeArguments();
              if (this.match(n2.parenL)) {
                const s3 = super.parseMaybeDecoratorArguments(t4);
                return s3.typeParameters = e3, s3;
              }
              this.unexpected(this.state.start, n2.parenL);
            }
            return super.parseMaybeDecoratorArguments(t4);
          }
          isClassMethod() {
            return this.isRelational("<") || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(n2.bang) || this.match(n2.colon) || super.isClassProperty();
          }
          parseMaybeDefault(...t4) {
            const e3 = super.parseMaybeDefault(...t4);
            return e3.type === "AssignmentPattern" && e3.typeAnnotation && e3.right.start < e3.typeAnnotation.start && this.raise(e3.typeAnnotation.start, rt2.TypeAnnotationAfterAssign), e3;
          }
          getTokenFromCode(t4) {
            return !this.state.inType || t4 !== 62 && t4 !== 60 ? super.getTokenFromCode(t4) : this.finishOp(n2.relational, 1);
          }
          reScan_lt_gt() {
            if (this.match(n2.relational)) {
              const t4 = this.input.charCodeAt(this.state.start);
              t4 !== 60 && t4 !== 62 || (this.state.pos -= 1, this.readToken_lt_gt(t4));
            }
          }
          toAssignableList(t4) {
            for (let e3 = 0; e3 < t4.length; e3++) {
              const s3 = t4[e3];
              if (s3)
                switch (s3.type) {
                  case "TSTypeCastExpression":
                    t4[e3] = this.typeCastToParameter(s3);
                    break;
                  case "TSAsExpression":
                  case "TSTypeAssertion":
                    this.state.maybeInArrowParameters ? this.raise(s3.start, rt2.UnexpectedTypeCastInParameter) : t4[e3] = this.typeCastToParameter(s3);
                }
            }
            return super.toAssignableList(...arguments);
          }
          typeCastToParameter(t4) {
            return t4.expression.typeAnnotation = t4.typeAnnotation, this.resetEndLocation(t4.expression, t4.typeAnnotation.end, t4.typeAnnotation.loc.end), t4.expression;
          }
          toReferencedList(t4, e3) {
            for (let e4 = 0; e4 < t4.length; e4++) {
              const s3 = t4[e4];
              (s3 == null ? void 0 : s3.type) === "TSTypeCastExpression" && this.raise(s3.start, rt2.UnexpectedTypeAnnotation);
            }
            return t4;
          }
          shouldParseArrow() {
            return this.match(n2.colon) || super.shouldParseArrow();
          }
          shouldParseAsyncArrow() {
            return this.match(n2.colon) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(t4) {
            if (this.isRelational("<")) {
              const e3 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
              e3 && (t4.typeParameters = e3);
            }
            return super.jsxParseOpeningElementAfterName(t4);
          }
          getGetterSetterExpectedParamCount(t4) {
            const e3 = super.getGetterSetterExpectedParamCount(t4), s3 = t4.params[0];
            return s3 && s3.type === "Identifier" && s3.name === "this" ? e3 + 1 : e3;
          }
          parseCatchClauseParam() {
            const t4 = super.parseCatchClauseParam(), e3 = this.tsTryParseTypeAnnotation();
            return e3 && (t4.typeAnnotation = e3), t4;
          }
        }, v8intrinsic: (t3) => class extends t3 {
          parseV8Intrinsic() {
            if (this.match(n2.modulo)) {
              const t4 = this.state.start, e3 = this.startNode();
              if (this.eat(n2.modulo), this.match(n2.name)) {
                const t5 = this.parseIdentifierName(this.state.start), s3 = this.createIdentifier(e3, t5);
                if (s3.type = "V8IntrinsicIdentifier", this.match(n2.parenL))
                  return s3;
              }
              this.unexpected(t4);
            }
          }
          parseExprAtom() {
            return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
          }
        }, placeholders: (t3) => class extends t3 {
          parsePlaceholder(t4) {
            if (this.match(n2.placeholder)) {
              const e3 = this.startNode();
              return this.next(), this.assertNoSpace("Unexpected space in placeholder."), e3.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(n2.placeholder), this.finishPlaceholder(e3, t4);
            }
          }
          finishPlaceholder(t4, e3) {
            const s3 = !(!t4.expectedNode || t4.type !== "Placeholder");
            return t4.expectedNode = e3, s3 ? t4 : this.finishNode(t4, "Placeholder");
          }
          getTokenFromCode(t4) {
            return t4 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(n2.placeholder, 2) : super.getTokenFromCode(...arguments);
          }
          parseExprAtom() {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
          }
          parseIdentifier() {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
          }
          checkReservedWord(t4) {
            t4 !== void 0 && super.checkReservedWord(...arguments);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
          }
          checkLVal(t4) {
            t4.type !== "Placeholder" && super.checkLVal(...arguments);
          }
          toAssignable(t4) {
            return t4 && t4.type === "Placeholder" && t4.expectedNode === "Expression" ? (t4.expectedNode = "Pattern", t4) : super.toAssignable(...arguments);
          }
          verifyBreakContinue(t4) {
            t4.label && t4.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
          }
          parseExpressionStatement(t4, e3) {
            if (e3.type !== "Placeholder" || e3.extra && e3.extra.parenthesized)
              return super.parseExpressionStatement(...arguments);
            if (this.match(n2.colon)) {
              const s3 = t4;
              return s3.label = this.finishPlaceholder(e3, "Identifier"), this.next(), s3.body = this.parseStatement("label"), this.finishNode(s3, "LabeledStatement");
            }
            return this.semicolon(), t4.name = e3.name, this.finishPlaceholder(t4, "Statement");
          }
          parseBlock() {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
          }
          parseFunctionId() {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
          }
          parseClass(t4, e3, s3) {
            const i3 = e3 ? "ClassDeclaration" : "ClassExpression";
            this.next(), this.takeDecorators(t4);
            const r3 = this.parsePlaceholder("Identifier");
            if (r3)
              if (this.match(n2._extends) || this.match(n2.placeholder) || this.match(n2.braceL))
                t4.id = r3;
              else {
                if (s3 || !e3)
                  return t4.id = null, t4.body = this.finishPlaceholder(r3, "ClassBody"), this.finishNode(t4, i3);
                this.unexpected(null, "A class name is required");
              }
            else
              this.parseClassId(t4, e3, s3);
            return this.parseClassSuper(t4), t4.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t4.superClass), this.finishNode(t4, i3);
          }
          parseExport(t4) {
            const e3 = this.parsePlaceholder("Identifier");
            if (!e3)
              return super.parseExport(...arguments);
            if (!this.isContextual("from") && !this.match(n2.comma))
              return t4.specifiers = [], t4.source = null, t4.declaration = this.finishPlaceholder(e3, "Declaration"), this.finishNode(t4, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const s3 = this.startNode();
            return s3.exported = e3, t4.specifiers = [this.finishNode(s3, "ExportDefaultSpecifier")], super.parseExport(t4);
          }
          isExportDefaultSpecifier() {
            if (this.match(n2._default)) {
              const t4 = this.nextTokenStart();
              if (this.isUnparsedContextual(t4, "from") && this.input.startsWith(n2.placeholder.label, this.nextTokenStartSince(t4 + 4)))
                return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(t4) {
            return !!(t4.specifiers && t4.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
          }
          checkExport(t4) {
            const {specifiers: e3} = t4;
            (e3 == null ? void 0 : e3.length) && (t4.specifiers = e3.filter((t5) => t5.exported.type === "Placeholder")), super.checkExport(t4), t4.specifiers = e3;
          }
          parseImport(t4) {
            const e3 = this.parsePlaceholder("Identifier");
            if (!e3)
              return super.parseImport(...arguments);
            if (t4.specifiers = [], !this.isContextual("from") && !this.match(n2.comma))
              return t4.source = this.finishPlaceholder(e3, "StringLiteral"), this.semicolon(), this.finishNode(t4, "ImportDeclaration");
            const s3 = this.startNodeAtNode(e3);
            if (s3.local = e3, this.finishNode(s3, "ImportDefaultSpecifier"), t4.specifiers.push(s3), this.eat(n2.comma)) {
              this.maybeParseStarImportSpecifier(t4) || this.parseNamedImportSpecifiers(t4);
            }
            return this.expectContextual("from"), t4.source = this.parseImportSource(), this.semicolon(), this.finishNode(t4, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
          }
        }}, pt2 = Object.keys(ct2), ut2 = {sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false};
        class lt2 {
          constructor() {
            this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.inParameters = false, this.maybeInArrowParameters = false, this.maybeInAsyncArrowHead = false, this.inPipeline = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isIterator = false, this.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null}, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.yieldPos = -1, this.awaitPos = -1, this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = 0, this.lineStart = 0, this.type = n2.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [x2.braceStatement], this.exprAllowed = true, this.containsEsc = false, this.octalPositions = [], this.exportedIdentifiers = [], this.tokensLength = 0;
          }
          init(t3) {
            this.strict = t3.strictMode !== false && t3.sourceType === "module", this.curLine = t3.startLine, this.startLoc = this.endLoc = this.curPosition();
          }
          curPosition() {
            return new l2(this.curLine, this.pos - this.lineStart);
          }
          clone(t3) {
            const e3 = new lt2(), s3 = Object.keys(this);
            for (let i3 = 0, r3 = s3.length; i3 < r3; i3++) {
              const r4 = s3[i3];
              let a3 = this[r4];
              !t3 && Array.isArray(a3) && (a3 = a3.slice()), e3[r4] = a3;
            }
            return e3;
          }
        }
        var dt2 = function(t3) {
          return t3 >= 48 && t3 <= 57;
        };
        const mt2 = new Set(["g", "m", "s", "i", "y", "u"]), ft2 = {decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120]}, Dt2 = {bin: [48, 49]};
        Dt2.oct = [...Dt2.bin, 50, 51, 52, 53, 54, 55], Dt2.dec = [...Dt2.oct, 56, 57], Dt2.hex = [...Dt2.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
        class yt2 {
          constructor(t3) {
            this.type = t3.type, this.value = t3.value, this.start = t3.start, this.end = t3.end, this.loc = new d2(t3.startLoc, t3.endLoc);
          }
        }
        class xt2 {
          constructor() {
            this.shorthandAssign = -1, this.doubleProto = -1;
          }
        }
        class gt2 {
          constructor(t3, e3, s3) {
            this.type = "", this.start = e3, this.end = 0, this.loc = new d2(s3), (t3 == null ? void 0 : t3.options.ranges) && (this.range = [e3, 0]), (t3 == null ? void 0 : t3.filename) && (this.loc.filename = t3.filename);
          }
          __clone() {
            const t3 = new gt2(), e3 = Object.keys(this);
            for (let s3 = 0, i3 = e3.length; s3 < i3; s3++) {
              const i4 = e3[s3];
              i4 !== "leadingComments" && i4 !== "trailingComments" && i4 !== "innerComments" && (t3[i4] = this[i4]);
            }
            return t3;
          }
        }
        const Et2 = (t3) => t3.type === "ParenthesizedExpression" ? Et2(t3.expression) : t3;
        const Pt2 = {kind: "loop"}, bt2 = {kind: "switch"};
        class Ct2 {
          constructor() {
            this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();
          }
        }
        class Tt2 {
          constructor(t3) {
            this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = t3;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new Ct2());
          }
          exit() {
            const t3 = this.stack.pop(), e3 = this.current();
            for (let s3 = 0, i3 = Array.from(t3.undefinedPrivateNames); s3 < i3.length; s3++) {
              const [t4, r3] = i3[s3];
              e3 ? e3.undefinedPrivateNames.has(t4) || e3.undefinedPrivateNames.set(t4, r3) : this.raise(r3, f2.InvalidPrivateFieldResolution, t4);
            }
          }
          declarePrivateName(t3, e3, s3) {
            const i3 = this.current();
            let r3 = i3.privateNames.has(t3);
            if (3 & e3) {
              const s4 = r3 && i3.loneAccessors.get(t3);
              if (s4) {
                const a3 = 4 & s4, n3 = 4 & e3;
                r3 = (3 & s4) === (3 & e3) || a3 !== n3, r3 || i3.loneAccessors.delete(t3);
              } else
                r3 || i3.loneAccessors.set(t3, e3);
            }
            r3 && this.raise(s3, f2.PrivateNameRedeclaration, t3), i3.privateNames.add(t3), i3.undefinedPrivateNames.delete(t3);
          }
          usePrivateName(t3, e3) {
            let s3;
            for (let e4 = 0, i3 = this.stack; e4 < i3.length; e4++)
              if (s3 = i3[e4], s3.privateNames.has(t3))
                return;
            s3 ? s3.undefinedPrivateNames.set(t3, e3) : this.raise(e3, f2.InvalidPrivateFieldResolution, t3);
          }
        }
        class At2 extends class extends class extends class extends class extends class extends class extends class extends class extends class {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(t3) {
            return this.plugins.has(t3);
          }
          getPluginOption(t3, e3) {
            if (this.hasPlugin(t3))
              return this.plugins.get(t3)[e3];
          }
        } {
          addComment(t3) {
            this.filename && (t3.loc.filename = this.filename), this.state.trailingComments.push(t3), this.state.leadingComments.push(t3);
          }
          adjustCommentsAfterTrailingComma(t3, e3, s3) {
            if (this.state.leadingComments.length === 0)
              return;
            let i3 = null, r3 = e3.length;
            for (; i3 === null && r3 > 0; )
              i3 = e3[--r3];
            if (i3 === null)
              return;
            for (let t4 = 0; t4 < this.state.leadingComments.length; t4++)
              this.state.leadingComments[t4].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(t4, 1), t4--);
            const a3 = [];
            for (let e4 = 0; e4 < this.state.leadingComments.length; e4++) {
              const i4 = this.state.leadingComments[e4];
              i4.end < t3.end ? (a3.push(i4), s3 || (this.state.leadingComments.splice(e4, 1), e4--)) : (t3.trailingComments === void 0 && (t3.trailingComments = []), t3.trailingComments.push(i4));
            }
            s3 && (this.state.leadingComments = []), a3.length > 0 ? i3.trailingComments = a3 : i3.trailingComments !== void 0 && (i3.trailingComments = []);
          }
          processComment(t3) {
            if (t3.type === "Program" && t3.body.length > 0)
              return;
            const e3 = this.state.commentStack;
            let s3, i3, r3, a3, n3;
            if (this.state.trailingComments.length > 0)
              this.state.trailingComments[0].start >= t3.end ? (r3 = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0;
            else if (e3.length > 0) {
              const s4 = m2(e3);
              s4.trailingComments && s4.trailingComments[0].start >= t3.end && (r3 = s4.trailingComments, delete s4.trailingComments);
            }
            for (e3.length > 0 && m2(e3).start >= t3.start && (s3 = e3.pop()); e3.length > 0 && m2(e3).start >= t3.start; )
              i3 = e3.pop();
            if (!i3 && s3 && (i3 = s3), s3)
              switch (t3.type) {
                case "ObjectExpression":
                  this.adjustCommentsAfterTrailingComma(t3, t3.properties);
                  break;
                case "ObjectPattern":
                  this.adjustCommentsAfterTrailingComma(t3, t3.properties, true);
                  break;
                case "CallExpression":
                  this.adjustCommentsAfterTrailingComma(t3, t3.arguments);
                  break;
                case "ArrayExpression":
                  this.adjustCommentsAfterTrailingComma(t3, t3.elements);
                  break;
                case "ArrayPattern":
                  this.adjustCommentsAfterTrailingComma(t3, t3.elements, true);
              }
            else
              this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && t3.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && t3.type !== "ExportSpecifier") && this.adjustCommentsAfterTrailingComma(t3, [this.state.commentPreviousNode]);
            if (i3) {
              if (i3.leadingComments) {
                if (i3 !== t3 && i3.leadingComments.length > 0 && m2(i3.leadingComments).end <= t3.start)
                  t3.leadingComments = i3.leadingComments, delete i3.leadingComments;
                else
                  for (a3 = i3.leadingComments.length - 2; a3 >= 0; --a3)
                    if (i3.leadingComments[a3].end <= t3.start) {
                      t3.leadingComments = i3.leadingComments.splice(0, a3 + 1);
                      break;
                    }
              }
            } else if (this.state.leadingComments.length > 0)
              if (m2(this.state.leadingComments).end <= t3.start) {
                if (this.state.commentPreviousNode)
                  for (n3 = 0; n3 < this.state.leadingComments.length; n3++)
                    this.state.leadingComments[n3].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(n3, 1), n3--);
                this.state.leadingComments.length > 0 && (t3.leadingComments = this.state.leadingComments, this.state.leadingComments = []);
              } else {
                for (a3 = 0; a3 < this.state.leadingComments.length && !(this.state.leadingComments[a3].end > t3.start); a3++)
                  ;
                const e4 = this.state.leadingComments.slice(0, a3);
                e4.length && (t3.leadingComments = e4), r3 = this.state.leadingComments.slice(a3), r3.length === 0 && (r3 = null);
              }
            if (this.state.commentPreviousNode = t3, r3)
              if (r3.length && r3[0].start >= t3.start && m2(r3).end <= t3.end)
                t3.innerComments = r3;
              else {
                const e4 = r3.findIndex((e5) => e5.end >= t3.end);
                e4 > 0 ? (t3.innerComments = r3.slice(0, e4), t3.trailingComments = r3.slice(e4)) : t3.trailingComments = r3;
              }
            e3.push(t3);
          }
        } {
          getLocationForPosition(t3) {
            let e3;
            return e3 = t3 === this.state.start ? this.state.startLoc : t3 === this.state.lastTokStart ? this.state.lastTokStartLoc : t3 === this.state.end ? this.state.endLoc : t3 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(t4, e4) {
              let s3, i3 = 1, r3 = 0;
              for (h2.lastIndex = 0; (s3 = h2.exec(t4)) && s3.index < e4; )
                i3++, r3 = h2.lastIndex;
              return new l2(i3, e4 - r3);
            }(this.input, t3), e3;
          }
          raise(t3, e3, ...s3) {
            return this.raiseWithData(t3, void 0, e3, ...s3);
          }
          raiseWithData(t3, e3, s3, ...i3) {
            const r3 = this.getLocationForPosition(t3), a3 = s3.replace(/%(\d+)/g, (t4, e4) => i3[e4]) + " (".concat(r3.line, ":").concat(r3.column, ")");
            return this._raise(Object.assign({loc: r3, pos: t3}, e3), a3);
          }
          _raise(t3, e3) {
            const s3 = new SyntaxError(e3);
            if (Object.assign(s3, t3), this.options.errorRecovery)
              return this.isLookahead || this.state.errors.push(s3), s3;
            throw s3;
          }
        } {
          constructor(t3, e3) {
            super(), this.tokens = [], this.state = new lt2(), this.state.init(t3), this.input = e3, this.length = e3.length, this.isLookahead = false;
          }
          pushToken(t3) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t3), ++this.state.tokensLength;
          }
          next() {
            this.isLookahead || (this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new yt2(this.state))), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(t3) {
            return !!this.match(t3) && (this.next(), true);
          }
          match(t3) {
            return this.state.type === t3;
          }
          lookahead() {
            const t3 = this.state;
            this.state = t3.clone(true), this.isLookahead = true, this.next(), this.isLookahead = false;
            const e3 = this.state;
            return this.state = t3, e3;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(t3) {
            p2.lastIndex = t3;
            return t3 + p2.exec(this.input)[0].length;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          setStrict(t3) {
            if (this.state.strict = t3, this.match(n2.num) || this.match(n2.string)) {
              for (this.state.pos = this.state.start; this.state.pos < this.state.lineStart; )
                this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1, --this.state.curLine;
              this.nextToken();
            }
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            const t3 = this.curContext();
            if ((t3 == null ? void 0 : t3.preserveSpace) || this.skipSpace(), this.state.octalPositions = [], this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), this.state.pos >= this.length)
              return void this.finishToken(n2.eof);
            const e3 = t3 == null ? void 0 : t3.override;
            e3 ? e3(this) : this.getTokenFromCode(this.input.codePointAt(this.state.pos));
          }
          pushComment(t3, e3, s3, i3, r3, a3) {
            const n3 = {type: t3 ? "CommentBlock" : "CommentLine", value: e3, start: s3, end: i3, loc: new d2(r3, a3)};
            this.options.tokens && this.pushToken(n3), this.state.comments.push(n3), this.addComment(n3);
          }
          skipBlockComment() {
            const t3 = this.state.curPosition(), e3 = this.state.pos, s3 = this.input.indexOf("*/", this.state.pos + 2);
            if (s3 === -1)
              throw this.raise(e3, f2.UnterminatedComment);
            let i3;
            for (this.state.pos = s3 + 2, h2.lastIndex = e3; (i3 = h2.exec(this.input)) && i3.index < this.state.pos; )
              ++this.state.curLine, this.state.lineStart = i3.index + i3[0].length;
            this.isLookahead || this.pushComment(true, this.input.slice(e3 + 2, s3), e3, this.state.pos, t3, this.state.curPosition());
          }
          skipLineComment(t3) {
            const e3 = this.state.pos, s3 = this.state.curPosition();
            let i3 = this.input.charCodeAt(this.state.pos += t3);
            if (this.state.pos < this.length)
              for (; !c2(i3) && ++this.state.pos < this.length; )
                i3 = this.input.charCodeAt(this.state.pos);
            this.isLookahead || this.pushComment(false, this.input.slice(e3 + t3, this.state.pos), e3, this.state.pos, s3, this.state.curPosition());
          }
          skipSpace() {
            t:
              for (; this.state.pos < this.length; ) {
                const t3 = this.input.charCodeAt(this.state.pos);
                switch (t3) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42:
                        this.skipBlockComment();
                        break;
                      case 47:
                        this.skipLineComment(2);
                        break;
                      default:
                        break t;
                    }
                    break;
                  default:
                    if (!u2(t3))
                      break t;
                    ++this.state.pos;
                }
              }
          }
          finishToken(t3, e3) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const s3 = this.state.type;
            this.state.type = t3, this.state.value = e3, this.isLookahead || this.updateContext(s3);
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter())
              return;
            const t3 = this.state.pos + 1, e3 = this.input.charCodeAt(t3);
            if (e3 >= 48 && e3 <= 57)
              throw this.raise(this.state.pos, f2.UnexpectedDigitAfterHash);
            if (e3 === 123 || e3 === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
                throw this.raise(this.state.pos, e3 === 123 ? f2.RecordExpressionHashIncorrectStartSyntaxType : f2.TupleExpressionHashIncorrectStartSyntaxType);
              e3 === 123 ? this.finishToken(n2.braceHashL) : this.finishToken(n2.bracketHashL), this.state.pos += 2;
            } else
              this.finishOp(n2.hash, 1);
          }
          readToken_dot() {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            t3 >= 48 && t3 <= 57 ? this.readNumber(true) : t3 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(n2.ellipsis)) : (++this.state.pos, this.finishToken(n2.dot));
          }
          readToken_slash() {
            if (this.state.exprAllowed && !this.state.inType)
              return ++this.state.pos, void this.readRegexp();
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(n2.assign, 2) : this.finishOp(n2.slash, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return false;
            let t3 = this.input.charCodeAt(this.state.pos + 1);
            if (t3 !== 33)
              return false;
            const e3 = this.state.pos;
            for (this.state.pos += 1; !c2(t3) && ++this.state.pos < this.length; )
              t3 = this.input.charCodeAt(this.state.pos);
            const s3 = this.input.slice(e3 + 2, this.state.pos);
            return this.finishToken(n2.interpreterDirective, s3), true;
          }
          readToken_mult_modulo(t3) {
            let e3 = t3 === 42 ? n2.star : n2.modulo, s3 = 1, i3 = this.input.charCodeAt(this.state.pos + 1);
            const r3 = this.state.exprAllowed;
            t3 === 42 && i3 === 42 && (s3++, i3 = this.input.charCodeAt(this.state.pos + 2), e3 = n2.exponent), i3 !== 61 || r3 || (s3++, e3 = n2.assign), this.finishOp(e3, s3);
          }
          readToken_pipe_amp(t3) {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            if (e3 !== t3) {
              if (t3 === 124) {
                if (e3 === 62)
                  return void this.finishOp(n2.pipeline, 2);
                if (this.hasPlugin("recordAndTuple") && e3 === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, f2.RecordExpressionBarIncorrectEndSyntaxType);
                  return void this.finishOp(n2.braceBarR, 2);
                }
                if (this.hasPlugin("recordAndTuple") && e3 === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, f2.TupleExpressionBarIncorrectEndSyntaxType);
                  return void this.finishOp(n2.bracketBarR, 2);
                }
              }
              e3 !== 61 ? this.finishOp(t3 === 124 ? n2.bitwiseOR : n2.bitwiseAND, 1) : this.finishOp(n2.assign, 2);
            } else
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(n2.assign, 3) : this.finishOp(t3 === 124 ? n2.logicalOR : n2.logicalAND, 2);
          }
          readToken_caret() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(n2.assign, 2) : this.finishOp(n2.bitwiseXOR, 1);
          }
          readToken_plus_min(t3) {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            if (e3 === t3)
              return e3 !== 45 || this.inModule || this.input.charCodeAt(this.state.pos + 2) !== 62 || this.state.lastTokEnd !== 0 && !o2.test(this.input.slice(this.state.lastTokEnd, this.state.pos)) ? void this.finishOp(n2.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), void this.nextToken());
            e3 === 61 ? this.finishOp(n2.assign, 2) : this.finishOp(n2.plusMin, 1);
          }
          readToken_lt_gt(t3) {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            let s3 = 1;
            return e3 === t3 ? (s3 = t3 === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.state.pos + s3) === 61 ? void this.finishOp(n2.assign, s3 + 1) : void this.finishOp(n2.bitShift, s3)) : e3 !== 33 || t3 !== 60 || this.inModule || this.input.charCodeAt(this.state.pos + 2) !== 45 || this.input.charCodeAt(this.state.pos + 3) !== 45 ? (e3 === 61 && (s3 = 2), void this.finishOp(n2.relational, s3)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken());
          }
          readToken_eq_excl(t3) {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            if (e3 !== 61)
              return t3 === 61 && e3 === 62 ? (this.state.pos += 2, void this.finishToken(n2.arrow)) : void this.finishOp(t3 === 61 ? n2.eq : n2.bang, 1);
            this.finishOp(n2.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          }
          readToken_question() {
            const t3 = this.input.charCodeAt(this.state.pos + 1), e3 = this.input.charCodeAt(this.state.pos + 2);
            t3 === 63 ? e3 === 61 ? this.finishOp(n2.assign, 3) : this.finishOp(n2.nullishCoalescing, 2) : t3 !== 46 || e3 >= 48 && e3 <= 57 ? (++this.state.pos, this.finishToken(n2.question)) : (this.state.pos += 2, this.finishToken(n2.questionDot));
          }
          getTokenFromCode(t3) {
            switch (t3) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(n2.parenL);
              case 41:
                return ++this.state.pos, void this.finishToken(n2.parenR);
              case 59:
                return ++this.state.pos, void this.finishToken(n2.semi);
              case 44:
                return ++this.state.pos, void this.finishToken(n2.comma);
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, f2.TupleExpressionBarIncorrectStartSyntaxType);
                  this.finishToken(n2.bracketBarL), this.state.pos += 2;
                } else
                  ++this.state.pos, this.finishToken(n2.bracketL);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(n2.bracketR);
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, f2.RecordExpressionBarIncorrectStartSyntaxType);
                  this.finishToken(n2.braceBarL), this.state.pos += 2;
                } else
                  ++this.state.pos, this.finishToken(n2.braceL);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(n2.braceR);
              case 58:
                return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(n2.doubleColon, 2) : (++this.state.pos, this.finishToken(n2.colon)));
              case 63:
                return void this.readToken_question();
              case 96:
                return ++this.state.pos, void this.finishToken(n2.backQuote);
              case 48: {
                const t4 = this.input.charCodeAt(this.state.pos + 1);
                if (t4 === 120 || t4 === 88)
                  return void this.readRadixNumber(16);
                if (t4 === 111 || t4 === 79)
                  return void this.readRadixNumber(8);
                if (t4 === 98 || t4 === 66)
                  return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(false);
              case 34:
              case 39:
                return void this.readString(t3);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(t3);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(t3);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(t3);
              case 60:
              case 62:
                return void this.readToken_lt_gt(t3);
              case 61:
              case 33:
                return void this.readToken_eq_excl(t3);
              case 126:
                return void this.finishOp(n2.tilde, 1);
              case 64:
                return ++this.state.pos, void this.finishToken(n2.at);
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (w2(t3))
                  return void this.readWord();
            }
            throw this.raise(this.state.pos, f2.InvalidOrUnexpectedToken, String.fromCodePoint(t3));
          }
          finishOp(t3, e3) {
            const s3 = this.input.slice(this.state.pos, this.state.pos + e3);
            this.state.pos += e3, this.finishToken(t3, s3);
          }
          readRegexp() {
            const t3 = this.state.pos;
            let e3, s3;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(t3, f2.UnterminatedRegExp);
              const i4 = this.input.charAt(this.state.pos);
              if (o2.test(i4))
                throw this.raise(t3, f2.UnterminatedRegExp);
              if (e3)
                e3 = false;
              else {
                if (i4 === "[")
                  s3 = true;
                else if (i4 === "]" && s3)
                  s3 = false;
                else if (i4 === "/" && !s3)
                  break;
                e3 = i4 === "\\";
              }
              ++this.state.pos;
            }
            const i3 = this.input.slice(t3, this.state.pos);
            ++this.state.pos;
            let r3 = "";
            for (; this.state.pos < this.length; ) {
              const t4 = this.input[this.state.pos], e4 = this.input.codePointAt(this.state.pos);
              if (mt2.has(t4))
                r3.indexOf(t4) > -1 && this.raise(this.state.pos + 1, f2.DuplicateRegExpFlags);
              else {
                if (!N2(e4) && e4 !== 92)
                  break;
                this.raise(this.state.pos + 1, f2.MalformedRegExpFlags);
              }
              ++this.state.pos, r3 += t4;
            }
            this.finishToken(n2.regexp, {pattern: i3, flags: r3});
          }
          readInt(t3, e3, s3, i3 = true) {
            const r3 = this.state.pos, a3 = t3 === 16 ? ft2.hex : ft2.decBinOct, n3 = t3 === 16 ? Dt2.hex : t3 === 10 ? Dt2.dec : t3 === 8 ? Dt2.oct : Dt2.bin;
            let o3 = false, h3 = 0;
            for (let r4 = 0, c3 = e3 == null ? 1 / 0 : e3; r4 < c3; ++r4) {
              const e4 = this.input.charCodeAt(this.state.pos);
              let c4;
              if (e4 !== 95) {
                if (c4 = e4 >= 97 ? e4 - 97 + 10 : e4 >= 65 ? e4 - 65 + 10 : dt2(e4) ? e4 - 48 : 1 / 0, c4 >= t3)
                  if (this.options.errorRecovery && c4 <= 9)
                    c4 = 0, this.raise(this.state.start + r4 + 2, f2.InvalidDigit, t3);
                  else {
                    if (!s3)
                      break;
                    c4 = 0, o3 = true;
                  }
                ++this.state.pos, h3 = h3 * t3 + c4;
              } else {
                const t4 = this.input.charCodeAt(this.state.pos - 1), e5 = this.input.charCodeAt(this.state.pos + 1);
                (n3.indexOf(e5) === -1 || a3.indexOf(t4) > -1 || a3.indexOf(e5) > -1 || Number.isNaN(e5)) && this.raise(this.state.pos, f2.UnexpectedNumericSeparator), i3 || this.raise(this.state.pos, f2.NumericSeparatorInEscapeSequence), ++this.state.pos;
              }
            }
            return this.state.pos === r3 || e3 != null && this.state.pos - r3 !== e3 || o3 ? null : h3;
          }
          readRadixNumber(t3) {
            const e3 = this.state.pos;
            let s3 = false;
            this.state.pos += 2;
            const i3 = this.readInt(t3);
            i3 == null && this.raise(this.state.start + 2, f2.InvalidDigit, t3);
            const r3 = this.input.charCodeAt(this.state.pos);
            if (r3 === 110)
              ++this.state.pos, s3 = true;
            else if (r3 === 109)
              throw this.raise(e3, f2.InvalidDecimal);
            if (w2(this.input.codePointAt(this.state.pos)))
              throw this.raise(this.state.pos, f2.NumberIdentifier);
            if (s3) {
              const t4 = this.input.slice(e3, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(n2.bigint, t4);
            } else
              this.finishToken(n2.num, i3);
          }
          readNumber(t3) {
            const e3 = this.state.pos;
            let s3 = false, i3 = false, r3 = false, a3 = false, o3 = false;
            t3 || this.readInt(10) !== null || this.raise(e3, f2.InvalidNumber);
            const h3 = this.state.pos - e3 >= 2 && this.input.charCodeAt(e3) === 48;
            if (h3) {
              const t4 = this.input.slice(e3, this.state.pos);
              if (this.state.strict)
                this.raise(e3, f2.StrictOctalLiteral);
              else {
                const s4 = t4.indexOf("_");
                s4 > 0 && this.raise(s4 + e3, f2.ZeroDigitNumericSeparator);
              }
              o3 = h3 && !/[89]/.test(t4);
            }
            let c3 = this.input.charCodeAt(this.state.pos);
            if (c3 !== 46 || o3 || (++this.state.pos, this.readInt(10), s3 = true, c3 = this.input.charCodeAt(this.state.pos)), c3 !== 69 && c3 !== 101 || o3 || (c3 = this.input.charCodeAt(++this.state.pos), c3 !== 43 && c3 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(e3, f2.InvalidNumber), s3 = true, a3 = true, c3 = this.input.charCodeAt(this.state.pos)), c3 === 110 && ((s3 || h3) && this.raise(e3, f2.InvalidBigIntLiteral), ++this.state.pos, i3 = true), c3 === 109 && (this.expectPlugin("decimal", this.state.pos), (a3 || h3) && this.raise(e3, f2.InvalidDecimal), ++this.state.pos, r3 = true), w2(this.input.codePointAt(this.state.pos)))
              throw this.raise(this.state.pos, f2.NumberIdentifier);
            const p3 = this.input.slice(e3, this.state.pos).replace(/[_mn]/g, "");
            if (i3)
              return void this.finishToken(n2.bigint, p3);
            if (r3)
              return void this.finishToken(n2.decimal, p3);
            const u3 = o3 ? parseInt(p3, 8) : parseFloat(p3);
            this.finishToken(n2.num, u3);
          }
          readCodePoint(t3) {
            let e3;
            if (this.input.charCodeAt(this.state.pos) === 123) {
              const s3 = ++this.state.pos;
              if (e3 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, t3), ++this.state.pos, e3 !== null && e3 > 1114111) {
                if (!t3)
                  return null;
                this.raise(s3, f2.InvalidCodePoint);
              }
            } else
              e3 = this.readHexChar(4, false, t3);
            return e3;
          }
          readString(t3) {
            let e3 = "", s3 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, f2.UnterminatedString);
              const i3 = this.input.charCodeAt(this.state.pos);
              if (i3 === t3)
                break;
              if (i3 === 92)
                e3 += this.input.slice(s3, this.state.pos), e3 += this.readEscapedChar(false), s3 = this.state.pos;
              else if (i3 === 8232 || i3 === 8233)
                ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              else {
                if (c2(i3))
                  throw this.raise(this.state.start, f2.UnterminatedString);
                ++this.state.pos;
              }
            }
            e3 += this.input.slice(s3, this.state.pos++), this.finishToken(n2.string, e3);
          }
          readTmplToken() {
            let t3 = "", e3 = this.state.pos, s3 = false;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, f2.UnterminatedTemplate);
              const i3 = this.input.charCodeAt(this.state.pos);
              if (i3 === 96 || i3 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
                return this.state.pos === this.state.start && this.match(n2.template) ? i3 === 36 ? (this.state.pos += 2, void this.finishToken(n2.dollarBraceL)) : (++this.state.pos, void this.finishToken(n2.backQuote)) : (t3 += this.input.slice(e3, this.state.pos), void this.finishToken(n2.template, s3 ? null : t3));
              if (i3 === 92) {
                t3 += this.input.slice(e3, this.state.pos);
                const i4 = this.readEscapedChar(true);
                i4 === null ? s3 = true : t3 += i4, e3 = this.state.pos;
              } else if (c2(i3)) {
                switch (t3 += this.input.slice(e3, this.state.pos), ++this.state.pos, i3) {
                  case 13:
                    this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
                  case 10:
                    t3 += "\n";
                    break;
                  default:
                    t3 += String.fromCharCode(i3);
                }
                ++this.state.curLine, this.state.lineStart = this.state.pos, e3 = this.state.pos;
              } else
                ++this.state.pos;
            }
          }
          readEscapedChar(t3) {
            const e3 = !t3, s3 = this.input.charCodeAt(++this.state.pos);
            switch (++this.state.pos, s3) {
              case 110:
                return "\n";
              case 114:
                return "\r";
              case 120: {
                const t4 = this.readHexChar(2, false, e3);
                return t4 === null ? null : String.fromCharCode(t4);
              }
              case 117: {
                const t4 = this.readCodePoint(e3);
                return t4 === null ? null : String.fromCodePoint(t4);
              }
              case 116:
                return "	";
              case 98:
                return "\b";
              case 118:
                return "\v";
              case 102:
                return "\f";
              case 13:
                this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
              case 10:
                this.state.lineStart = this.state.pos, ++this.state.curLine;
              case 8232:
              case 8233:
                return "";
              case 56:
              case 57:
                if (t3)
                  return null;
                this.state.strict && this.raise(this.state.pos - 1, f2.StrictNumericEscape);
              default:
                if (s3 >= 48 && s3 <= 55) {
                  const e4 = this.state.pos - 1;
                  let s4 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], i3 = parseInt(s4, 8);
                  i3 > 255 && (s4 = s4.slice(0, -1), i3 = parseInt(s4, 8)), this.state.pos += s4.length - 1;
                  const r3 = this.input.charCodeAt(this.state.pos);
                  if (s4 !== "0" || r3 === 56 || r3 === 57) {
                    if (t3)
                      return null;
                    this.state.strict ? this.raise(e4, f2.StrictNumericEscape) : this.state.octalPositions.push(e4);
                  }
                  return String.fromCharCode(i3);
                }
                return String.fromCharCode(s3);
            }
          }
          readHexChar(t3, e3, s3) {
            const i3 = this.state.pos, r3 = this.readInt(16, t3, e3, false);
            return r3 === null && (s3 ? this.raise(i3, f2.InvalidEscapeSequence) : this.state.pos = i3 - 1), r3;
          }
          readWord1() {
            let t3 = "";
            this.state.containsEsc = false;
            const e3 = this.state.pos;
            let s3 = this.state.pos;
            for (; this.state.pos < this.length; ) {
              const i3 = this.input.codePointAt(this.state.pos);
              if (N2(i3))
                this.state.pos += i3 <= 65535 ? 1 : 2;
              else if (this.state.isIterator && i3 === 64)
                ++this.state.pos;
              else {
                if (i3 !== 92)
                  break;
                {
                  this.state.containsEsc = true, t3 += this.input.slice(s3, this.state.pos);
                  const i4 = this.state.pos, r3 = this.state.pos === e3 ? w2 : N2;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(this.state.pos, f2.MissingUnicodeEscape);
                    continue;
                  }
                  ++this.state.pos;
                  const a3 = this.readCodePoint(true);
                  a3 !== null && (r3(a3) || this.raise(i4, f2.EscapedCharNotAnIdentifier), t3 += String.fromCodePoint(a3)), s3 = this.state.pos;
                }
              }
            }
            return t3 + this.input.slice(s3, this.state.pos);
          }
          isIterator(t3) {
            return t3 === "@@iterator" || t3 === "@@asyncIterator";
          }
          readWord() {
            const t3 = this.readWord1(), e3 = i2.get(t3) || n2.name;
            !this.state.isIterator || this.isIterator(t3) && this.state.inType || this.raise(this.state.pos, f2.InvalidIdentifier, t3), this.finishToken(e3, t3);
          }
          checkKeywordEscapes() {
            const t3 = this.state.type.keyword;
            t3 && this.state.containsEsc && this.raise(this.state.start, f2.InvalidEscapedReservedWord, t3);
          }
          braceIsBlock(t3) {
            const e3 = this.curContext();
            return e3 === x2.functionExpression || e3 === x2.functionStatement || (t3 !== n2.colon || e3 !== x2.braceStatement && e3 !== x2.braceExpression ? t3 === n2._return || t3 === n2.name && this.state.exprAllowed ? o2.test(this.input.slice(this.state.lastTokEnd, this.state.start)) : t3 === n2._else || t3 === n2.semi || t3 === n2.eof || t3 === n2.parenR || t3 === n2.arrow || (t3 === n2.braceL ? e3 === x2.braceStatement : t3 !== n2._var && t3 !== n2._const && t3 !== n2.name && (t3 === n2.relational || !this.state.exprAllowed)) : !e3.isExpr);
          }
          updateContext(t3) {
            const e3 = this.state.type;
            let s3;
            !e3.keyword || t3 !== n2.dot && t3 !== n2.questionDot ? (s3 = e3.updateContext) ? s3.call(this, t3) : this.state.exprAllowed = e3.beforeExpr : this.state.exprAllowed = false;
          }
        } {
          addExtra(t3, e3, s3) {
            if (!t3)
              return;
            (t3.extra = t3.extra || {})[e3] = s3;
          }
          isRelational(t3) {
            return this.match(n2.relational) && this.state.value === t3;
          }
          isLookaheadRelational(t3) {
            const e3 = this.nextTokenStart();
            if (this.input.charAt(e3) === t3) {
              if (e3 + 1 === this.input.length)
                return true;
              const s3 = this.input.charCodeAt(e3 + 1);
              return s3 !== t3.charCodeAt(0) && s3 !== 61;
            }
            return false;
          }
          expectRelational(t3) {
            this.isRelational(t3) ? this.next() : this.unexpected(null, n2.relational);
          }
          isContextual(t3) {
            return this.match(n2.name) && this.state.value === t3 && !this.state.containsEsc;
          }
          isUnparsedContextual(t3, e3) {
            const s3 = t3 + e3.length;
            return this.input.slice(t3, s3) === e3 && (s3 === this.input.length || !N2(this.input.charCodeAt(s3)));
          }
          isLookaheadContextual(t3) {
            const e3 = this.nextTokenStart();
            return this.isUnparsedContextual(e3, t3);
          }
          eatContextual(t3) {
            return this.isContextual(t3) && this.eat(n2.name);
          }
          expectContextual(t3, e3) {
            this.eatContextual(t3) || this.unexpected(null, e3);
          }
          canInsertSemicolon() {
            return this.match(n2.eof) || this.match(n2.braceR) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return o2.test(this.input.slice(this.state.lastTokEnd, this.state.start));
          }
          isLineTerminator() {
            return this.eat(n2.semi) || this.canInsertSemicolon();
          }
          semicolon() {
            this.isLineTerminator() || this.unexpected(null, n2.semi);
          }
          expect(t3, e3) {
            this.eat(t3) || this.unexpected(e3, t3);
          }
          assertNoSpace(t3 = "Unexpected space.") {
            this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, t3);
          }
          unexpected(t3, e3 = "Unexpected token") {
            throw typeof e3 != "string" && (e3 = 'Unexpected token, expected "'.concat(e3.label, '"')), this.raise(t3 != null ? t3 : this.state.start, e3);
          }
          expectPlugin(t3, e3) {
            if (!this.hasPlugin(t3))
              throw this.raiseWithData(e3 != null ? e3 : this.state.start, {missingPlugin: [t3]}, "This experimental syntax requires enabling the parser plugin: '".concat(t3, "'"));
            return true;
          }
          expectOnePlugin(t3, e3) {
            if (!t3.some((t4) => this.hasPlugin(t4)))
              throw this.raiseWithData(e3 != null ? e3 : this.state.start, {missingPlugin: t3}, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(t3.join(", "), "'"));
          }
          checkYieldAwaitInDefaultParams() {
            this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos) && this.raise(this.state.yieldPos, f2.YieldBindingIdentifier), this.state.awaitPos !== -1 && this.raise(this.state.awaitPos, f2.AwaitBindingIdentifier);
          }
          tryParse(t3, e3 = this.state.clone()) {
            const s3 = {node: null};
            try {
              const i3 = t3((t4 = null) => {
                throw s3.node = t4, s3;
              });
              if (this.state.errors.length > e3.errors.length) {
                const t4 = this.state;
                return this.state = e3, {node: i3, error: t4.errors[e3.errors.length], thrown: false, aborted: false, failState: t4};
              }
              return {node: i3, error: null, thrown: false, aborted: false, failState: null};
            } catch (t4) {
              const i3 = this.state;
              if (this.state = e3, t4 instanceof SyntaxError)
                return {node: null, error: t4, thrown: true, aborted: false, failState: i3};
              if (t4 === s3)
                return {node: s3.node, error: null, thrown: false, aborted: true, failState: i3};
              throw t4;
            }
          }
          checkExpressionErrors(t3, e3) {
            if (!t3)
              return false;
            const {shorthandAssign: s3, doubleProto: i3} = t3;
            if (!e3)
              return s3 >= 0 || i3 >= 0;
            s3 >= 0 && this.unexpected(s3), i3 >= 0 && this.raise(i3, f2.DuplicateProto);
          }
          isLiteralPropertyName() {
            return this.match(n2.name) || !!this.state.type.keyword || this.match(n2.string) || this.match(n2.num) || this.match(n2.bigint) || this.match(n2.decimal);
          }
        } {
          startNode() {
            return new gt2(this, this.state.start, this.state.startLoc);
          }
          startNodeAt(t3, e3) {
            return new gt2(this, t3, e3);
          }
          startNodeAtNode(t3) {
            return this.startNodeAt(t3.start, t3.loc.start);
          }
          finishNode(t3, e3) {
            return this.finishNodeAt(t3, e3, this.state.lastTokEnd, this.state.lastTokEndLoc);
          }
          finishNodeAt(t3, e3, s3, i3) {
            return t3.type = e3, t3.end = s3, t3.loc.end = i3, this.options.ranges && (t3.range[1] = s3), this.processComment(t3), t3;
          }
          resetStartLocation(t3, e3, s3) {
            t3.start = e3, t3.loc.start = s3, this.options.ranges && (t3.range[0] = e3);
          }
          resetEndLocation(t3, e3 = this.state.lastTokEnd, s3 = this.state.lastTokEndLoc) {
            t3.end = e3, t3.loc.end = s3, this.options.ranges && (t3.range[1] = e3);
          }
          resetStartLocationFromNode(t3, e3) {
            this.resetStartLocation(t3, e3.start, e3.loc.start);
          }
        } {
          toAssignable(t3) {
            var e3, s3;
            let i3 = void 0;
            switch ((t3.type === "ParenthesizedExpression" || ((e3 = t3.extra) == null ? void 0 : e3.parenthesized)) && (i3 = Et2(t3), i3.type !== "Identifier" && i3.type !== "MemberExpression" && this.raise(t3.start, f2.InvalidParenthesizedAssignment)), t3.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
                break;
              case "ObjectExpression":
                t3.type = "ObjectPattern";
                for (let e4 = 0, s4 = t3.properties.length, i4 = s4 - 1; e4 < s4; e4++) {
                  var r3;
                  const s5 = t3.properties[e4], a3 = e4 === i4;
                  this.toAssignableObjectExpressionProp(s5, a3), a3 && s5.type === "RestElement" && ((r3 = t3.extra) == null ? void 0 : r3.trailingComma) && this.raiseRestNotLast(t3.extra.trailingComma);
                }
                break;
              case "ObjectProperty":
                this.toAssignable(t3.value);
                break;
              case "SpreadElement": {
                this.checkToRestConversion(t3), t3.type = "RestElement";
                const e4 = t3.argument;
                this.toAssignable(e4);
                break;
              }
              case "ArrayExpression":
                t3.type = "ArrayPattern", this.toAssignableList(t3.elements, (s3 = t3.extra) == null ? void 0 : s3.trailingComma);
                break;
              case "AssignmentExpression":
                t3.operator !== "=" && this.raise(t3.left.end, f2.MissingEqInAssignment), t3.type = "AssignmentPattern", delete t3.operator, this.toAssignable(t3.left);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(i3);
            }
            return t3;
          }
          toAssignableObjectExpressionProp(t3, e3) {
            if (t3.type === "ObjectMethod") {
              const e4 = t3.kind === "get" || t3.kind === "set" ? f2.PatternHasAccessor : f2.PatternHasMethod;
              this.raise(t3.key.start, e4);
            } else
              t3.type !== "SpreadElement" || e3 ? this.toAssignable(t3) : this.raiseRestNotLast(t3.start);
          }
          toAssignableList(t3, e3) {
            let s3 = t3.length;
            if (s3) {
              const i3 = t3[s3 - 1];
              if ((i3 == null ? void 0 : i3.type) === "RestElement")
                --s3;
              else if ((i3 == null ? void 0 : i3.type) === "SpreadElement") {
                i3.type = "RestElement";
                const t4 = i3.argument;
                this.toAssignable(t4), t4.type !== "Identifier" && t4.type !== "MemberExpression" && t4.type !== "ArrayPattern" && t4.type !== "ObjectPattern" && this.unexpected(t4.start), e3 && this.raiseTrailingCommaAfterRest(e3), --s3;
              }
            }
            for (let e4 = 0; e4 < s3; e4++) {
              const s4 = t3[e4];
              s4 && (this.toAssignable(s4), s4.type === "RestElement" && this.raiseRestNotLast(s4.start));
            }
            return t3;
          }
          toReferencedList(t3, e3) {
            return t3;
          }
          toReferencedListDeep(t3, e3) {
            this.toReferencedList(t3, e3);
            for (let e4 = 0; e4 < t3.length; e4++) {
              const s3 = t3[e4];
              (s3 == null ? void 0 : s3.type) === "ArrayExpression" && this.toReferencedListDeep(s3.elements);
            }
          }
          parseSpread(t3, e3) {
            const s3 = this.startNode();
            return this.next(), s3.argument = this.parseMaybeAssign(false, t3, void 0, e3), this.finishNode(s3, "SpreadElement");
          }
          parseRestBinding() {
            const t3 = this.startNode();
            return this.next(), t3.argument = this.parseBindingAtom(), this.finishNode(t3, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case n2.bracketL: {
                const t3 = this.startNode();
                return this.next(), t3.elements = this.parseBindingList(n2.bracketR, 93, true), this.finishNode(t3, "ArrayPattern");
              }
              case n2.braceL:
                return this.parseObjectLike(n2.braceR, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(t3, e3, s3, i3) {
            const r3 = [];
            let a3 = true;
            for (; !this.eat(t3); )
              if (a3 ? a3 = false : this.expect(n2.comma), s3 && this.match(n2.comma))
                r3.push(null);
              else {
                if (this.eat(t3))
                  break;
                if (this.match(n2.ellipsis)) {
                  r3.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(e3), this.expect(t3);
                  break;
                }
                {
                  const t4 = [];
                  for (this.match(n2.at) && this.hasPlugin("decorators") && this.raise(this.state.start, f2.UnsupportedParameterDecorator); this.match(n2.at); )
                    t4.push(this.parseDecorator());
                  r3.push(this.parseAssignableListItem(i3, t4));
                }
              }
            return r3;
          }
          parseAssignableListItem(t3, e3) {
            const s3 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s3);
            const i3 = this.parseMaybeDefault(s3.start, s3.loc.start, s3);
            return e3.length && (s3.decorators = e3), i3;
          }
          parseAssignableListItemTypes(t3) {
            return t3;
          }
          parseMaybeDefault(t3, e3, s3) {
            var i3, r3, a3;
            if (e3 = (i3 = e3) != null ? i3 : this.state.startLoc, t3 = (r3 = t3) != null ? r3 : this.state.start, s3 = (a3 = s3) != null ? a3 : this.parseBindingAtom(), !this.eat(n2.eq))
              return s3;
            const o3 = this.startNodeAt(t3, e3);
            return o3.left = s3, o3.right = this.parseMaybeAssign(), this.finishNode(o3, "AssignmentPattern");
          }
          checkLVal(t3, e3 = 64, s3, i3, r3, a3 = false) {
            switch (t3.type) {
              case "Identifier":
                if (this.state.strict && (a3 ? M2(t3.name, this.inModule) : R2(t3.name)) && this.raise(t3.start, e3 === 64 ? f2.StrictEvalArguments : f2.StrictEvalArgumentsBinding, t3.name), s3) {
                  const e4 = "_".concat(t3.name);
                  s3[e4] ? this.raise(t3.start, f2.ParamDupe) : s3[e4] = true;
                }
                r3 && t3.name === "let" && this.raise(t3.start, f2.LetInLexicalBinding), 64 & e3 || this.scope.declareName(t3.name, e3, t3.start);
                break;
              case "MemberExpression":
                e3 !== 64 && this.raise(t3.start, f2.InvalidPropertyBindingPattern);
                break;
              case "ObjectPattern":
                for (let i4 = 0, a4 = t3.properties; i4 < a4.length; i4++) {
                  let t4 = a4[i4];
                  if (t4.type === "ObjectProperty")
                    t4 = t4.value;
                  else if (t4.type === "ObjectMethod")
                    continue;
                  this.checkLVal(t4, e3, s3, "object destructuring pattern", r3);
                }
                break;
              case "ArrayPattern":
                for (let i4 = 0, a4 = t3.elements; i4 < a4.length; i4++) {
                  const t4 = a4[i4];
                  t4 && this.checkLVal(t4, e3, s3, "array destructuring pattern", r3);
                }
                break;
              case "AssignmentPattern":
                this.checkLVal(t3.left, e3, s3, "assignment pattern");
                break;
              case "RestElement":
                this.checkLVal(t3.argument, e3, s3, "rest element");
                break;
              case "ParenthesizedExpression":
                this.checkLVal(t3.expression, e3, s3, "parenthesized expression");
                break;
              default:
                this.raise(t3.start, e3 === 64 ? f2.InvalidLhs : f2.InvalidLhsBinding, i3);
            }
          }
          checkToRestConversion(t3) {
            t3.argument.type !== "Identifier" && t3.argument.type !== "MemberExpression" && this.raise(t3.argument.start, f2.InvalidRestAssignmentPattern);
          }
          checkCommaAfterRest(t3) {
            this.match(n2.comma) && (this.lookaheadCharCode() === t3 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
          }
          raiseRestNotLast(t3) {
            throw this.raise(t3, f2.ElementAfterRest);
          }
          raiseTrailingCommaAfterRest(t3) {
            this.raise(t3, f2.RestTrailingComma);
          }
        } {
          checkProto(t3, e3, s3, i3) {
            if (t3.type === "SpreadElement" || t3.type === "ObjectMethod" || t3.computed || t3.shorthand)
              return;
            const r3 = t3.key;
            if ((r3.type === "Identifier" ? r3.name : r3.value) === "__proto__") {
              if (e3)
                return void this.raise(r3.start, f2.RecordNoProto);
              s3.used && (i3 ? i3.doubleProto === -1 && (i3.doubleProto = r3.start) : this.raise(r3.start, f2.DuplicateProto)), s3.used = true;
            }
          }
          shouldExitDescending(t3, e3) {
            return t3.type === "ArrowFunctionExpression" && t3.start === e3;
          }
          getExpression() {
            let t3 = 0;
            this.hasPlugin("topLevelAwait") && this.inModule && (t3 |= 2), this.scope.enter(1), this.prodParam.enter(t3), this.nextToken();
            const e3 = this.parseExpression();
            return this.match(n2.eof) || this.unexpected(), e3.comments = this.state.comments, e3.errors = this.state.errors, e3;
          }
          parseExpression(t3, e3) {
            const s3 = this.state.start, i3 = this.state.startLoc, r3 = this.parseMaybeAssign(t3, e3);
            if (this.match(n2.comma)) {
              const a3 = this.startNodeAt(s3, i3);
              for (a3.expressions = [r3]; this.eat(n2.comma); )
                a3.expressions.push(this.parseMaybeAssign(t3, e3));
              return this.toReferencedList(a3.expressions), this.finishNode(a3, "SequenceExpression");
            }
            return r3;
          }
          parseMaybeAssign(t3, e3, s3, i3) {
            const r3 = this.state.start, a3 = this.state.startLoc;
            if (this.isContextual("yield")) {
              if (this.prodParam.hasYield) {
                let e4 = this.parseYield(t3);
                return s3 && (e4 = s3.call(this, e4, r3, a3)), e4;
              }
              this.state.exprAllowed = false;
            }
            let o3;
            e3 ? o3 = false : (e3 = new xt2(), o3 = true), (this.match(n2.parenL) || this.match(n2.name)) && (this.state.potentialArrowAt = this.state.start);
            let h3 = this.parseMaybeConditional(t3, e3, i3);
            if (s3 && (h3 = s3.call(this, h3, r3, a3)), this.state.type.isAssign) {
              const s4 = this.startNodeAt(r3, a3), i4 = this.state.value;
              return s4.operator = i4, this.match(n2.eq) ? (s4.left = this.toAssignable(h3), e3.doubleProto = -1) : s4.left = h3, e3.shorthandAssign >= s4.left.start && (e3.shorthandAssign = -1), this.checkLVal(h3, void 0, void 0, "assignment expression"), this.next(), s4.right = this.parseMaybeAssign(t3), this.finishNode(s4, "AssignmentExpression");
            }
            return o3 && this.checkExpressionErrors(e3, true), h3;
          }
          parseMaybeConditional(t3, e3, s3) {
            const i3 = this.state.start, r3 = this.state.startLoc, a3 = this.state.potentialArrowAt, n3 = this.parseExprOps(t3, e3);
            return this.shouldExitDescending(n3, a3) ? n3 : this.parseConditional(n3, t3, i3, r3, s3);
          }
          parseConditional(t3, e3, s3, i3, r3) {
            if (this.eat(n2.question)) {
              const r4 = this.startNodeAt(s3, i3);
              return r4.test = t3, r4.consequent = this.parseMaybeAssign(), this.expect(n2.colon), r4.alternate = this.parseMaybeAssign(e3), this.finishNode(r4, "ConditionalExpression");
            }
            return t3;
          }
          parseExprOps(t3, e3) {
            const s3 = this.state.start, i3 = this.state.startLoc, r3 = this.state.potentialArrowAt, a3 = this.parseMaybeUnary(e3);
            return this.shouldExitDescending(a3, r3) ? a3 : this.parseExprOp(a3, s3, i3, -1, t3);
          }
          parseExprOp(t3, e3, s3, i3, r3) {
            let a3 = this.state.type.binop;
            if (!(a3 == null || r3 && this.match(n2._in)) && a3 > i3) {
              const o3 = this.state.type;
              if (o3 === n2.pipeline) {
                if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                  return t3;
                this.state.inPipeline = true, this.checkPipelineAtInfixOperator(t3, e3);
              }
              const h3 = this.startNodeAt(e3, s3);
              h3.left = t3, h3.operator = this.state.value, o3 !== n2.exponent || t3.type !== "UnaryExpression" || !this.options.createParenthesizedExpressions && t3.extra && t3.extra.parenthesized || this.raise(t3.argument.start, f2.UnexpectedTokenUnaryExponentiation);
              const c3 = o3 === n2.logicalOR || o3 === n2.logicalAND, p3 = o3 === n2.nullishCoalescing;
              if (p3 && (a3 = n2.logicalAND.binop), this.next(), o3 === n2.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.match(n2.name) && this.state.value === "await" && this.prodParam.hasAwait)
                throw this.raise(this.state.start, f2.UnexpectedAwaitAfterPipelineBody);
              h3.right = this.parseExprOpRightExpr(o3, a3, r3), this.finishNode(h3, c3 || p3 ? "LogicalExpression" : "BinaryExpression");
              const u3 = this.state.type;
              if (p3 && (u3 === n2.logicalOR || u3 === n2.logicalAND) || c3 && u3 === n2.nullishCoalescing)
                throw this.raise(this.state.start, f2.MixingCoalesceWithLogical);
              return this.parseExprOp(h3, e3, s3, i3, r3);
            }
            return t3;
          }
          parseExprOpRightExpr(t3, e3, s3) {
            const i3 = this.state.start, r3 = this.state.startLoc;
            switch (t3) {
              case n2.pipeline:
                switch (this.getPluginOption("pipelineOperator", "proposal")) {
                  case "smart":
                    return this.withTopicPermittingContext(() => this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(t3, e3, s3), i3, r3));
                  case "fsharp":
                    return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e3, s3));
                }
              default:
                return this.parseExprOpBaseRightExpr(t3, e3, s3);
            }
          }
          parseExprOpBaseRightExpr(t3, e3, s3) {
            const i3 = this.state.start, r3 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnary(), i3, r3, t3.rightAssociative ? e3 - 1 : e3, s3);
          }
          parseMaybeUnary(t3) {
            if (this.isContextual("await") && this.isAwaitAllowed())
              return this.parseAwait();
            const e3 = this.match(n2.incDec), s3 = this.startNode();
            if (this.state.type.prefix) {
              s3.operator = this.state.value, s3.prefix = true, this.match(n2._throw) && this.expectPlugin("throwExpressions");
              const i3 = this.match(n2._delete);
              if (this.next(), s3.argument = this.parseMaybeUnary(), this.checkExpressionErrors(t3, true), this.state.strict && i3) {
                const t4 = s3.argument;
                t4.type === "Identifier" ? this.raise(s3.start, f2.StrictDelete) : t4.type !== "MemberExpression" && t4.type !== "OptionalMemberExpression" || t4.property.type !== "PrivateName" || this.raise(s3.start, f2.DeletePrivateField);
              }
              if (!e3)
                return this.finishNode(s3, "UnaryExpression");
            }
            return this.parseUpdate(s3, e3, t3);
          }
          parseUpdate(t3, e3, s3) {
            if (e3)
              return this.checkLVal(t3.argument, void 0, void 0, "prefix operation"), this.finishNode(t3, "UpdateExpression");
            const i3 = this.state.start, r3 = this.state.startLoc;
            let a3 = this.parseExprSubscripts(s3);
            if (this.checkExpressionErrors(s3, false))
              return a3;
            for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
              const t4 = this.startNodeAt(i3, r3);
              t4.operator = this.state.value, t4.prefix = false, t4.argument = a3, this.checkLVal(a3, void 0, void 0, "postfix operation"), this.next(), a3 = this.finishNode(t4, "UpdateExpression");
            }
            return a3;
          }
          parseExprSubscripts(t3) {
            const e3 = this.state.start, s3 = this.state.startLoc, i3 = this.state.potentialArrowAt, r3 = this.parseExprAtom(t3);
            return this.shouldExitDescending(r3, i3) ? r3 : this.parseSubscripts(r3, e3, s3);
          }
          parseSubscripts(t3, e3, s3, i3) {
            const r3 = {optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t3), stop: false};
            do {
              const a3 = this.state.maybeInAsyncArrowHead;
              r3.maybeAsyncArrow && (this.state.maybeInAsyncArrowHead = true), t3 = this.parseSubscript(t3, e3, s3, i3, r3), r3.maybeAsyncArrow = false, this.state.maybeInAsyncArrowHead = a3;
            } while (!r3.stop);
            return t3;
          }
          parseSubscript(t3, e3, s3, i3, r3) {
            if (!i3 && this.eat(n2.doubleColon))
              return this.parseBind(t3, e3, s3, i3, r3);
            if (this.match(n2.backQuote))
              return this.parseTaggedTemplateExpression(t3, e3, s3, r3);
            let a3 = false;
            if (this.match(n2.questionDot)) {
              if (r3.optionalChainMember = a3 = true, i3 && this.lookaheadCharCode() === 40)
                return r3.stop = true, t3;
              this.next();
            }
            return !i3 && this.match(n2.parenL) ? this.parseCoverCallAndAsyncArrowHead(t3, e3, s3, r3, a3) : a3 || this.match(n2.bracketL) || this.eat(n2.dot) ? this.parseMember(t3, e3, s3, r3, a3) : (r3.stop = true, t3);
          }
          parseMember(t3, e3, s3, i3, r3) {
            const a3 = this.startNodeAt(e3, s3), o3 = this.eat(n2.bracketL);
            a3.object = t3, a3.computed = o3;
            const h3 = o3 ? this.parseExpression() : this.parseMaybePrivateName(true);
            return h3.type === "PrivateName" && (a3.object.type === "Super" && this.raise(e3, f2.SuperPrivateField), this.classScope.usePrivateName(h3.id.name, h3.start)), a3.property = h3, o3 && this.expect(n2.bracketR), i3.optionalChainMember ? (a3.optional = r3, this.finishNode(a3, "OptionalMemberExpression")) : this.finishNode(a3, "MemberExpression");
          }
          parseBind(t3, e3, s3, i3, r3) {
            const a3 = this.startNodeAt(e3, s3);
            return a3.object = t3, a3.callee = this.parseNoCallExpr(), r3.stop = true, this.parseSubscripts(this.finishNode(a3, "BindExpression"), e3, s3, i3);
          }
          parseCoverCallAndAsyncArrowHead(t3, e3, s3, i3, r3) {
            const a3 = this.state.maybeInArrowParameters, o3 = this.state.yieldPos, h3 = this.state.awaitPos;
            this.state.maybeInArrowParameters = true, this.state.yieldPos = -1, this.state.awaitPos = -1, this.next();
            let c3 = this.startNodeAt(e3, s3);
            return c3.callee = t3, i3.optionalChainMember && (c3.optional = r3), c3.arguments = r3 ? this.parseCallExpressionArguments(n2.parenR, false) : this.parseCallExpressionArguments(n2.parenR, i3.maybeAsyncArrow, t3.type === "Import", t3.type !== "Super", c3), this.finishCallExpression(c3, i3.optionalChainMember), i3.maybeAsyncArrow && this.shouldParseAsyncArrow() && !r3 ? (i3.stop = true, c3 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e3, s3), c3), this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = o3, this.state.awaitPos = h3) : (this.toReferencedListDeep(c3.arguments), o3 !== -1 && (this.state.yieldPos = o3), (this.isAwaitAllowed() || a3) && h3 === -1 || (this.state.awaitPos = h3)), this.state.maybeInArrowParameters = a3, c3;
          }
          parseTaggedTemplateExpression(t3, e3, s3, i3) {
            const r3 = this.startNodeAt(e3, s3);
            return r3.tag = t3, r3.quasi = this.parseTemplate(true), i3.optionalChainMember && this.raise(e3, f2.OptionalChainingNoTemplate), this.finishNode(r3, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(t3) {
            return t3.type === "Identifier" && t3.name === "async" && this.state.lastTokEnd === t3.end && !this.canInsertSemicolon() && t3.end - t3.start == 5 && t3.start === this.state.potentialArrowAt;
          }
          finishCallExpression(t3, e3) {
            if (t3.callee.type === "Import")
              if (t3.arguments.length === 2 && this.expectPlugin("moduleAttributes"), t3.arguments.length === 0 || t3.arguments.length > 2)
                this.raise(t3.start, f2.ImportCallArity, this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
              else
                for (let e4 = 0, s3 = t3.arguments; e4 < s3.length; e4++) {
                  const t4 = s3[e4];
                  t4.type === "SpreadElement" && this.raise(t4.start, f2.ImportCallSpreadArgument);
                }
            return this.finishNode(t3, e3 ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(t3, e3, s3, i3, r3) {
            const a3 = [];
            let o3, h3 = true;
            const c3 = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t3); ) {
              if (h3)
                h3 = false;
              else if (this.expect(n2.comma), this.match(t3)) {
                s3 && !this.hasPlugin("moduleAttributes") && this.raise(this.state.lastTokStart, f2.ImportCallArgumentTrailingComma), r3 && this.addExtra(r3, "trailingComma", this.state.lastTokStart), this.next();
                break;
              }
              this.match(n2.parenL) && !o3 && (o3 = this.state.start), a3.push(this.parseExprListItem(false, e3 ? new xt2() : void 0, e3 ? {start: 0} : void 0, i3));
            }
            return e3 && o3 && this.shouldParseAsyncArrow() && this.unexpected(), this.state.inFSharpPipelineDirectBody = c3, a3;
          }
          shouldParseAsyncArrow() {
            return this.match(n2.arrow) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(t3, e3) {
            var s3;
            return this.expect(n2.arrow), this.parseArrowExpression(t3, e3.arguments, true, (s3 = e3.extra) == null ? void 0 : s3.trailingComma), t3;
          }
          parseNoCallExpr() {
            const t3 = this.state.start, e3 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t3, e3, true);
          }
          parseExprAtom(t3) {
            this.state.type === n2.slash && this.readRegexp();
            const e3 = this.state.potentialArrowAt === this.state.start;
            let s3;
            switch (this.state.type) {
              case n2._super:
                return this.parseSuper();
              case n2._import:
                return s3 = this.startNode(), this.next(), this.match(n2.dot) ? this.parseImportMetaProperty(s3) : (this.match(n2.parenL) || this.raise(this.state.lastTokStart, f2.UnsupportedImport), this.finishNode(s3, "Import"));
              case n2._this:
                return s3 = this.startNode(), this.next(), this.finishNode(s3, "ThisExpression");
              case n2.name: {
                const t4 = this.state.containsEsc, s4 = this.parseIdentifier();
                if (!t4 && s4.name === "async" && !this.canInsertSemicolon()) {
                  if (this.match(n2._function)) {
                    const t5 = this.state.context.length - 1;
                    if (this.state.context[t5] !== x2.functionStatement)
                      throw new Error("Internal error");
                    return this.state.context[t5] = x2.functionExpression, this.next(), this.parseFunction(this.startNodeAtNode(s4), void 0, true);
                  }
                  if (this.match(n2.name))
                    return this.parseAsyncArrowUnaryFunction(s4);
                }
                return e3 && this.match(n2.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s4), [s4], false)) : s4;
              }
              case n2._do:
                return this.parseDo();
              case n2.regexp: {
                const t4 = this.state.value;
                return s3 = this.parseLiteral(t4.value, "RegExpLiteral"), s3.pattern = t4.pattern, s3.flags = t4.flags, s3;
              }
              case n2.num:
                return this.parseLiteral(this.state.value, "NumericLiteral");
              case n2.bigint:
                return this.parseLiteral(this.state.value, "BigIntLiteral");
              case n2.decimal:
                return this.parseLiteral(this.state.value, "DecimalLiteral");
              case n2.string:
                return this.parseLiteral(this.state.value, "StringLiteral");
              case n2._null:
                return s3 = this.startNode(), this.next(), this.finishNode(s3, "NullLiteral");
              case n2._true:
              case n2._false:
                return this.parseBooleanLiteral();
              case n2.parenL:
                return this.parseParenAndDistinguishExpression(e3);
              case n2.bracketBarL:
              case n2.bracketHashL:
                return this.parseArrayLike(this.state.type === n2.bracketBarL ? n2.bracketBarR : n2.bracketR, false, true, t3);
              case n2.bracketL:
                return this.parseArrayLike(n2.bracketR, true, false, t3);
              case n2.braceBarL:
              case n2.braceHashL:
                return this.parseObjectLike(this.state.type === n2.braceBarL ? n2.braceBarR : n2.braceR, false, true, t3);
              case n2.braceL:
                return this.parseObjectLike(n2.braceR, false, false, t3);
              case n2._function:
                return this.parseFunctionOrFunctionSent();
              case n2.at:
                this.parseDecorators();
              case n2._class:
                return s3 = this.startNode(), this.takeDecorators(s3), this.parseClass(s3, false);
              case n2._new:
                return this.parseNewOrNewTarget();
              case n2.backQuote:
                return this.parseTemplate(false);
              case n2.doubleColon: {
                s3 = this.startNode(), this.next(), s3.object = null;
                const t4 = s3.callee = this.parseNoCallExpr();
                if (t4.type === "MemberExpression")
                  return this.finishNode(s3, "BindExpression");
                throw this.raise(t4.start, f2.UnsupportedBind);
              }
              case n2.hash: {
                if (this.state.inPipeline)
                  return s3 = this.startNode(), this.getPluginOption("pipelineOperator", "proposal") !== "smart" && this.raise(s3.start, f2.PrimaryTopicRequiresSmartPipeline), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(s3.start, f2.PrimaryTopicNotAllowed), this.registerTopicReference(), this.finishNode(s3, "PipelinePrimaryTopicReference");
                const t4 = this.input.codePointAt(this.state.end);
                if (w2(t4) || t4 === 92) {
                  const t5 = this.state.start;
                  if (s3 = this.parseMaybePrivateName(true), this.match(n2._in))
                    this.expectPlugin("privateIn"), this.classScope.usePrivateName(s3.id.name, s3.start);
                  else {
                    if (!this.hasPlugin("privateIn"))
                      throw this.unexpected(t5);
                    this.raise(this.state.start, f2.PrivateInExpectedIn, s3.id.name);
                  }
                  return s3;
                }
              }
              case n2.relational:
                if (this.state.value === "<") {
                  const t4 = this.input.codePointAt(this.nextTokenStart());
                  (w2(t4) || t4 === 62) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
                }
              default:
                throw this.unexpected();
            }
          }
          parseAsyncArrowUnaryFunction(t3) {
            const e3 = this.startNodeAtNode(t3), s3 = this.state.maybeInArrowParameters, i3 = this.state.maybeInAsyncArrowHead, r3 = this.state.yieldPos, a3 = this.state.awaitPos;
            this.state.maybeInArrowParameters = true, this.state.maybeInAsyncArrowHead = true, this.state.yieldPos = -1, this.state.awaitPos = -1;
            const o3 = [this.parseIdentifier()];
            return this.hasPrecedingLineBreak() && this.raise(this.state.pos, f2.LineTerminatorBeforeArrow), this.expect(n2.arrow), this.checkYieldAwaitInDefaultParams(), this.state.maybeInArrowParameters = s3, this.state.maybeInAsyncArrowHead = i3, this.state.yieldPos = r3, this.state.awaitPos = a3, this.parseArrowExpression(e3, o3, true), e3;
          }
          parseDo() {
            this.expectPlugin("doExpressions");
            const t3 = this.startNode();
            this.next();
            const e3 = this.state.labels;
            return this.state.labels = [], t3.body = this.parseBlock(), this.state.labels = e3, this.finishNode(t3, "DoExpression");
          }
          parseSuper() {
            const t3 = this.startNode();
            return this.next(), !this.match(n2.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(t3.start, f2.UnexpectedSuper) : this.raise(t3.start, f2.SuperNotAllowed), this.match(n2.parenL) || this.match(n2.bracketL) || this.match(n2.dot) || this.raise(t3.start, f2.UnsupportedSuper), this.finishNode(t3, "Super");
          }
          parseBooleanLiteral() {
            const t3 = this.startNode();
            return t3.value = this.match(n2._true), this.next(), this.finishNode(t3, "BooleanLiteral");
          }
          parseMaybePrivateName(t3) {
            if (this.match(n2.hash)) {
              this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]), t3 || this.raise(this.state.pos, f2.UnexpectedPrivateField);
              const e3 = this.startNode();
              return this.next(), this.assertNoSpace("Unexpected space between # and identifier"), e3.id = this.parseIdentifier(true), this.finishNode(e3, "PrivateName");
            }
            return this.parseIdentifier(true);
          }
          parseFunctionOrFunctionSent() {
            const t3 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(n2.dot)) {
              const e3 = this.createIdentifier(this.startNodeAtNode(t3), "function");
              return this.next(), this.parseMetaProperty(t3, e3, "sent");
            }
            return this.parseFunction(t3);
          }
          parseMetaProperty(t3, e3, s3) {
            t3.meta = e3, e3.name === "function" && s3 === "sent" && (this.isContextual(s3) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
            const i3 = this.state.containsEsc;
            return t3.property = this.parseIdentifier(true), (t3.property.name !== s3 || i3) && this.raise(t3.property.start, f2.UnsupportedMetaProperty, e3.name, s3), this.finishNode(t3, "MetaProperty");
          }
          parseImportMetaProperty(t3) {
            const e3 = this.createIdentifier(this.startNodeAtNode(t3), "import");
            return this.next(), this.isContextual("meta") && (this.inModule || this.raiseWithData(e3.start, {code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"}, f2.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(t3, e3, "meta");
          }
          parseLiteral(t3, e3, s3, i3) {
            s3 = s3 || this.state.start, i3 = i3 || this.state.startLoc;
            const r3 = this.startNodeAt(s3, i3);
            return this.addExtra(r3, "rawValue", t3), this.addExtra(r3, "raw", this.input.slice(s3, this.state.end)), r3.value = t3, this.next(), this.finishNode(r3, e3);
          }
          parseParenAndDistinguishExpression(t3) {
            const e3 = this.state.start, s3 = this.state.startLoc;
            let i3;
            this.next();
            const r3 = this.state.maybeInArrowParameters, a3 = this.state.yieldPos, o3 = this.state.awaitPos, h3 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.yieldPos = -1, this.state.awaitPos = -1, this.state.inFSharpPipelineDirectBody = false;
            const c3 = this.state.start, p3 = this.state.startLoc, u3 = [], l3 = new xt2(), d3 = {start: 0};
            let m3, f3, D3 = true;
            for (; !this.match(n2.parenR); ) {
              if (D3)
                D3 = false;
              else if (this.expect(n2.comma, d3.start || null), this.match(n2.parenR)) {
                f3 = this.state.start;
                break;
              }
              if (this.match(n2.ellipsis)) {
                const t4 = this.state.start, e4 = this.state.startLoc;
                m3 = this.state.start, u3.push(this.parseParenItem(this.parseRestBinding(), t4, e4)), this.checkCommaAfterRest(41);
                break;
              }
              u3.push(this.parseMaybeAssign(false, l3, this.parseParenItem, d3));
            }
            const y3 = this.state.lastTokEnd, x3 = this.state.lastTokEndLoc;
            this.expect(n2.parenR), this.state.maybeInArrowParameters = r3, this.state.inFSharpPipelineDirectBody = h3;
            let g3 = this.startNodeAt(e3, s3);
            if (t3 && this.shouldParseArrow() && (g3 = this.parseArrow(g3))) {
              this.isAwaitAllowed() || this.state.maybeInAsyncArrowHead || (this.state.awaitPos = o3), this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = a3, this.state.awaitPos = o3;
              for (let t4 = 0; t4 < u3.length; t4++) {
                const e4 = u3[t4];
                e4.extra && e4.extra.parenthesized && this.unexpected(e4.extra.parenStart);
              }
              return this.parseArrowExpression(g3, u3, false), g3;
            }
            if (a3 !== -1 && (this.state.yieldPos = a3), o3 !== -1 && (this.state.awaitPos = o3), u3.length || this.unexpected(this.state.lastTokStart), f3 && this.unexpected(f3), m3 && this.unexpected(m3), this.checkExpressionErrors(l3, true), d3.start && this.unexpected(d3.start), this.toReferencedListDeep(u3, true), u3.length > 1 ? (i3 = this.startNodeAt(c3, p3), i3.expressions = u3, this.finishNodeAt(i3, "SequenceExpression", y3, x3)) : i3 = u3[0], !this.options.createParenthesizedExpressions)
              return this.addExtra(i3, "parenthesized", true), this.addExtra(i3, "parenStart", e3), i3;
            const E3 = this.startNodeAt(e3, s3);
            return E3.expression = i3, this.finishNode(E3, "ParenthesizedExpression"), E3;
          }
          shouldParseArrow() {
            return !this.canInsertSemicolon();
          }
          parseArrow(t3) {
            if (this.eat(n2.arrow))
              return t3;
          }
          parseParenItem(t3, e3, s3) {
            return t3;
          }
          parseNewOrNewTarget() {
            const t3 = this.startNode();
            if (this.next(), this.match(n2.dot)) {
              const e3 = this.createIdentifier(this.startNodeAtNode(t3), "new");
              this.next();
              const s3 = this.parseMetaProperty(t3, e3, "target");
              if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
                let t4 = f2.UnexpectedNewTarget;
                this.hasPlugin("classProperties") && (t4 += " or class properties"), this.raise(s3.start, t4);
              }
              return s3;
            }
            return this.parseNew(t3);
          }
          parseNew(t3) {
            return t3.callee = this.parseNoCallExpr(), t3.callee.type === "Import" ? this.raise(t3.callee.start, f2.ImportCallNotNewExpression) : t3.callee.type === "OptionalMemberExpression" || t3.callee.type === "OptionalCallExpression" ? this.raise(this.state.lastTokEnd, f2.OptionalChainingNoNew) : this.eat(n2.questionDot) && this.raise(this.state.start, f2.OptionalChainingNoNew), this.parseNewArguments(t3), this.finishNode(t3, "NewExpression");
          }
          parseNewArguments(t3) {
            if (this.eat(n2.parenL)) {
              const e3 = this.parseExprList(n2.parenR);
              this.toReferencedList(e3), t3.arguments = e3;
            } else
              t3.arguments = [];
          }
          parseTemplateElement(t3) {
            const e3 = this.startNode();
            return this.state.value === null && (t3 || this.raise(this.state.start + 1, f2.InvalidEscapeSequenceTemplate)), e3.value = {raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value}, this.next(), e3.tail = this.match(n2.backQuote), this.finishNode(e3, "TemplateElement");
          }
          parseTemplate(t3) {
            const e3 = this.startNode();
            this.next(), e3.expressions = [];
            let s3 = this.parseTemplateElement(t3);
            for (e3.quasis = [s3]; !s3.tail; )
              this.expect(n2.dollarBraceL), e3.expressions.push(this.parseExpression()), this.expect(n2.braceR), e3.quasis.push(s3 = this.parseTemplateElement(t3));
            return this.next(), this.finishNode(e3, "TemplateLiteral");
          }
          parseObjectLike(t3, e3, s3, i3) {
            s3 && this.expectPlugin("recordAndTuple");
            const r3 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const a3 = Object.create(null);
            let o3 = true;
            const h3 = this.startNode();
            for (h3.properties = [], this.next(); !this.eat(t3); ) {
              if (o3)
                o3 = false;
              else if (this.expect(n2.comma), this.match(t3)) {
                this.addExtra(h3, "trailingComma", this.state.lastTokStart), this.next();
                break;
              }
              const r4 = this.parsePropertyDefinition(e3, i3);
              e3 || this.checkProto(r4, s3, a3, i3), s3 && r4.type !== "ObjectProperty" && r4.type !== "SpreadElement" && this.raise(r4.start, f2.InvalidRecordProperty), r4.shorthand && this.addExtra(r4, "shorthand", true), h3.properties.push(r4);
            }
            this.state.inFSharpPipelineDirectBody = r3;
            let c3 = "ObjectExpression";
            return e3 ? c3 = "ObjectPattern" : s3 && (c3 = "RecordExpression"), this.finishNode(h3, c3);
          }
          maybeAsyncOrAccessorProp(t3) {
            return !t3.computed && t3.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(n2.bracketL) || this.match(n2.star));
          }
          parsePropertyDefinition(t3, e3) {
            let s3 = [];
            if (this.match(n2.at))
              for (this.hasPlugin("decorators") && this.raise(this.state.start, f2.UnsupportedPropertyDecorator); this.match(n2.at); )
                s3.push(this.parseDecorator());
            const i3 = this.startNode();
            let r3, a3, o3 = false, h3 = false, c3 = false;
            if (this.match(n2.ellipsis))
              return s3.length && this.unexpected(), t3 ? (this.next(), i3.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(i3, "RestElement")) : this.parseSpread();
            s3.length && (i3.decorators = s3, s3 = []), i3.method = false, (t3 || e3) && (r3 = this.state.start, a3 = this.state.startLoc), t3 || (o3 = this.eat(n2.star));
            const p3 = this.state.containsEsc;
            return this.parsePropertyName(i3, false), t3 || o3 || p3 || !this.maybeAsyncOrAccessorProp(i3) || (i3.key.name !== "async" || this.hasPrecedingLineBreak() ? i3.key.name !== "get" && i3.key.name !== "set" || (c3 = true, o3 = this.eat(n2.star), i3.kind = i3.key.name, this.parsePropertyName(i3, false)) : (h3 = true, o3 = this.eat(n2.star), this.parsePropertyName(i3, false))), this.parseObjPropValue(i3, r3, a3, o3, h3, t3, c3, e3), i3;
          }
          getGetterSetterExpectedParamCount(t3) {
            return t3.kind === "get" ? 0 : 1;
          }
          checkGetterSetterParams(t3) {
            const e3 = this.getGetterSetterExpectedParamCount(t3), s3 = t3.start;
            t3.params.length !== e3 && (t3.kind === "get" ? this.raise(s3, f2.BadGetterArity) : this.raise(s3, f2.BadSetterArity)), t3.kind === "set" && t3.params[t3.params.length - 1].type === "RestElement" && this.raise(s3, f2.BadSetterRestParameter);
          }
          parseObjectMethod(t3, e3, s3, i3, r3) {
            return r3 ? (e3 && this.unexpected(), this.parseMethod(t3, false, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(t3), t3) : s3 || e3 || this.match(n2.parenL) ? (i3 && this.unexpected(), t3.kind = "method", t3.method = true, this.parseMethod(t3, e3, s3, false, false, "ObjectMethod")) : void 0;
          }
          parseObjectProperty(t3, e3, s3, i3, r3) {
            return t3.shorthand = false, this.eat(n2.colon) ? (t3.value = i3 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, r3), this.finishNode(t3, "ObjectProperty")) : t3.computed || t3.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(t3.key.name, t3.key.start, true, false), i3 ? t3.value = this.parseMaybeDefault(e3, s3, t3.key.__clone()) : this.match(n2.eq) && r3 ? (r3.shorthandAssign === -1 && (r3.shorthandAssign = this.state.start), t3.value = this.parseMaybeDefault(e3, s3, t3.key.__clone())) : t3.value = t3.key.__clone(), t3.shorthand = true, this.finishNode(t3, "ObjectProperty"));
          }
          parseObjPropValue(t3, e3, s3, i3, r3, a3, n3, o3) {
            const h3 = this.parseObjectMethod(t3, i3, r3, a3, n3) || this.parseObjectProperty(t3, e3, s3, a3, o3);
            return h3 || this.unexpected(), h3;
          }
          parsePropertyName(t3, e3) {
            if (this.eat(n2.bracketL))
              t3.computed = true, t3.key = this.parseMaybeAssign(), this.expect(n2.bracketR);
            else {
              const s3 = this.state.inPropertyName;
              this.state.inPropertyName = true, t3.key = this.match(n2.num) || this.match(n2.string) || this.match(n2.bigint) || this.match(n2.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(e3), t3.key.type !== "PrivateName" && (t3.computed = false), this.state.inPropertyName = s3;
            }
            return t3.key;
          }
          initFunction(t3, e3) {
            t3.id = null, t3.generator = false, t3.async = !!e3;
          }
          parseMethod(t3, e3, s3, i3, r3, a3, n3 = false) {
            const o3 = this.state.yieldPos, h3 = this.state.awaitPos;
            this.state.yieldPos = -1, this.state.awaitPos = -1, this.initFunction(t3, s3), t3.generator = !!e3;
            const c3 = i3;
            return this.scope.enter(18 | (n3 ? 64 : 0) | (r3 ? 32 : 0)), this.prodParam.enter(et2(s3, t3.generator)), this.parseFunctionParams(t3, c3), this.parseFunctionBodyAndFinish(t3, a3, true), this.prodParam.exit(), this.scope.exit(), this.state.yieldPos = o3, this.state.awaitPos = h3, t3;
          }
          parseArrayLike(t3, e3, s3, i3) {
            s3 && this.expectPlugin("recordAndTuple");
            const r3 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const a3 = this.startNode();
            return this.next(), a3.elements = this.parseExprList(t3, !s3, i3, a3), e3 && !this.state.maybeInArrowParameters && this.toReferencedList(a3.elements), this.state.inFSharpPipelineDirectBody = r3, this.finishNode(a3, s3 ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(t3, e3, s3, i3) {
            this.scope.enter(6), this.prodParam.enter(et2(s3, false)), this.initFunction(t3, s3);
            const r3 = this.state.maybeInArrowParameters, a3 = this.state.yieldPos, n3 = this.state.awaitPos;
            return e3 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t3, e3, i3)), this.state.maybeInArrowParameters = false, this.state.yieldPos = -1, this.state.awaitPos = -1, this.parseFunctionBody(t3, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = r3, this.state.yieldPos = a3, this.state.awaitPos = n3, this.finishNode(t3, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(t3, e3, s3) {
            t3.params = this.toAssignableList(e3, s3);
          }
          parseFunctionBodyAndFinish(t3, e3, s3 = false) {
            this.parseFunctionBody(t3, false, s3), this.finishNode(t3, e3);
          }
          parseFunctionBody(t3, e3, s3 = false) {
            const i3 = e3 && !this.match(n2.braceL), r3 = this.state.inParameters;
            if (this.state.inParameters = false, i3)
              t3.body = this.parseMaybeAssign(), this.checkParams(t3, false, e3, false);
            else {
              const i4 = this.state.strict, r4 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), t3.body = this.parseBlock(true, false, (r5) => {
                const a3 = !this.isSimpleParamList(t3.params);
                if (r5 && a3) {
                  const e4 = t3.kind !== "method" && t3.kind !== "constructor" || !t3.key ? t3.start : t3.key.end;
                  this.raise(e4, f2.IllegalLanguageModeDirective);
                }
                const n3 = !i4 && this.state.strict;
                this.checkParams(t3, !(this.state.strict || e3 || s3 || a3), e3, n3), this.state.strict && t3.id && this.checkLVal(t3.id, 65, void 0, "function name", void 0, n3);
              }), this.prodParam.exit(), this.state.labels = r4;
            }
            this.state.inParameters = r3;
          }
          isSimpleParamList(t3) {
            for (let e3 = 0, s3 = t3.length; e3 < s3; e3++)
              if (t3[e3].type !== "Identifier")
                return false;
            return true;
          }
          checkParams(t3, e3, s3, i3 = true) {
            const r3 = Object.create(null);
            for (let s4 = 0; s4 < t3.params.length; s4++)
              this.checkLVal(t3.params[s4], 5, e3 ? null : r3, "function parameter list", void 0, i3);
          }
          parseExprList(t3, e3, s3, i3) {
            const r3 = [];
            let a3 = true;
            for (; !this.eat(t3); ) {
              if (a3)
                a3 = false;
              else if (this.expect(n2.comma), this.match(t3)) {
                i3 && this.addExtra(i3, "trailingComma", this.state.lastTokStart), this.next();
                break;
              }
              r3.push(this.parseExprListItem(e3, s3));
            }
            return r3;
          }
          parseExprListItem(t3, e3, s3, i3) {
            let r3;
            if (this.match(n2.comma))
              t3 || this.raise(this.state.pos, f2.UnexpectedToken, ","), r3 = null;
            else if (this.match(n2.ellipsis)) {
              const t4 = this.state.start, i4 = this.state.startLoc;
              r3 = this.parseParenItem(this.parseSpread(e3, s3), t4, i4);
            } else if (this.match(n2.question)) {
              this.expectPlugin("partialApplication"), i3 || this.raise(this.state.start, f2.UnexpectedArgumentPlaceholder);
              const t4 = this.startNode();
              this.next(), r3 = this.finishNode(t4, "ArgumentPlaceholder");
            } else
              r3 = this.parseMaybeAssign(false, e3, this.parseParenItem, s3);
            return r3;
          }
          parseIdentifier(t3) {
            const e3 = this.startNode(), s3 = this.parseIdentifierName(e3.start, t3);
            return this.createIdentifier(e3, s3);
          }
          createIdentifier(t3, e3) {
            return t3.name = e3, t3.loc.identifierName = e3, this.finishNode(t3, "Identifier");
          }
          parseIdentifierName(t3, e3) {
            let s3;
            if (this.match(n2.name))
              s3 = this.state.value;
            else {
              if (!this.state.type.keyword)
                throw this.unexpected();
              {
                s3 = this.state.type.keyword;
                const t4 = this.state.context;
                s3 !== "class" && s3 !== "function" || t4[t4.length - 1].token !== "function" || t4.pop();
              }
            }
            return e3 ? this.state.type = n2.name : this.checkReservedWord(s3, this.state.start, !!this.state.type.keyword, false), this.next(), s3;
          }
          checkReservedWord(t3, e3, s3, i3) {
            if (this.prodParam.hasYield && t3 === "yield")
              return void this.raise(e3, f2.YieldBindingIdentifier);
            if (t3 === "await") {
              if (this.prodParam.hasAwait)
                return void this.raise(e3, f2.AwaitBindingIdentifier);
              this.state.awaitPos === -1 && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed()) && (this.state.awaitPos = this.state.start);
            }
            if (this.scope.inClass && !this.scope.inNonArrowFunction && t3 === "arguments")
              return void this.raise(e3, f2.ArgumentsDisallowedInInitializer);
            if (s3 && function(t4) {
              return F2.has(t4);
            }(t3))
              return void this.raise(e3, f2.UnexpectedKeyword, t3);
            (this.state.strict ? i3 ? M2 : O2 : L2)(t3, this.inModule) && (this.prodParam.hasAwait || t3 !== "await" ? this.raise(e3, f2.UnexpectedReservedWord, t3) : this.raise(e3, f2.AwaitNotInAsyncFunction));
          }
          isAwaitAllowed() {
            return this.scope.inFunction ? this.prodParam.hasAwait : !!this.options.allowAwaitOutsideFunction || !!this.hasPlugin("topLevelAwait") && (this.inModule && this.prodParam.hasAwait);
          }
          parseAwait() {
            const t3 = this.startNode();
            return this.next(), this.state.inParameters ? this.raise(t3.start, f2.AwaitExpressionFormalParameter) : this.state.awaitPos === -1 && (this.state.awaitPos = t3.start), this.eat(n2.star) && this.raise(t3.start, f2.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.hasPrecedingLineBreak() || this.match(n2.plusMin) || this.match(n2.parenL) || this.match(n2.bracketL) || this.match(n2.backQuote) || this.match(n2.regexp) || this.match(n2.slash) || this.hasPlugin("v8intrinsic") && this.match(n2.modulo) ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (t3.argument = this.parseMaybeUnary()), this.finishNode(t3, "AwaitExpression");
          }
          parseYield(t3) {
            const e3 = this.startNode();
            return this.state.inParameters ? this.raise(e3.start, f2.YieldInParameter) : this.state.yieldPos === -1 && (this.state.yieldPos = e3.start), this.next(), this.match(n2.semi) || !this.match(n2.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak() ? (e3.delegate = false, e3.argument = null) : (e3.delegate = this.eat(n2.star), e3.argument = this.parseMaybeAssign(t3)), this.finishNode(e3, "YieldExpression");
          }
          checkPipelineAtInfixOperator(t3, e3) {
            this.getPluginOption("pipelineOperator", "proposal") === "smart" && t3.type === "SequenceExpression" && this.raise(e3, f2.PipelineHeadSequenceExpression);
          }
          parseSmartPipelineBody(t3, e3, s3) {
            const i3 = this.checkSmartPipelineBodyStyle(t3);
            return this.checkSmartPipelineBodyEarlyErrors(t3, i3, e3), this.parseSmartPipelineBodyInStyle(t3, i3, e3, s3);
          }
          checkSmartPipelineBodyEarlyErrors(t3, e3, s3) {
            if (this.match(n2.arrow))
              throw this.raise(this.state.start, f2.PipelineBodyNoArrow);
            e3 === "PipelineTopicExpression" && t3.type === "SequenceExpression" && this.raise(s3, f2.PipelineBodySequenceExpression);
          }
          parseSmartPipelineBodyInStyle(t3, e3, s3, i3) {
            const r3 = this.startNodeAt(s3, i3);
            switch (e3) {
              case "PipelineBareFunction":
                r3.callee = t3;
                break;
              case "PipelineBareConstructor":
                r3.callee = t3.callee;
                break;
              case "PipelineBareAwaitedFunction":
                r3.callee = t3.argument;
                break;
              case "PipelineTopicExpression":
                this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(s3, f2.PipelineTopicUnused), r3.expression = t3;
                break;
              default:
                throw new Error("Internal @babel/parser error: Unknown pipeline style (".concat(e3, ")"));
            }
            return this.finishNode(r3, e3);
          }
          checkSmartPipelineBodyStyle(t3) {
            return t3.type, this.isSimpleReference(t3) ? "PipelineBareFunction" : "PipelineTopicExpression";
          }
          isSimpleReference(t3) {
            switch (t3.type) {
              case "MemberExpression":
                return !t3.computed && this.isSimpleReference(t3.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          withTopicPermittingContext(t3) {
            const e3 = this.state.topicContext;
            this.state.topicContext = {maxNumOfResolvableTopics: 1, maxTopicIndex: null};
            try {
              return t3();
            } finally {
              this.state.topicContext = e3;
            }
          }
          withTopicForbiddingContext(t3) {
            const e3 = this.state.topicContext;
            this.state.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
            try {
              return t3();
            } finally {
              this.state.topicContext = e3;
            }
          }
          withSoloAwaitPermittingContext(t3) {
            const e3 = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return t3();
            } finally {
              this.state.soloAwait = e3;
            }
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          primaryTopicReferenceIsAllowedInCurrentTopicContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentTopicContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(t3, e3) {
            const s3 = this.state.start, i3 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const r3 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const a3 = this.parseExprOp(this.parseMaybeUnary(), s3, i3, t3, e3);
            return this.state.inFSharpPipelineDirectBody = r3, a3;
          }
        } {
          parseTopLevel(t3, e3) {
            if (e3.sourceType = this.options.sourceType, e3.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e3, true, true, n2.eof), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
              for (let t4 = 0, e4 = Array.from(this.scope.undefinedExports); t4 < e4.length; t4++) {
                const [s3] = e4[t4], i3 = this.scope.undefinedExports.get(s3);
                this.raise(i3, f2.ModuleExportUndefined, s3);
              }
            return t3.program = this.finishNode(e3, "Program"), t3.comments = this.state.comments, this.options.tokens && (t3.tokens = this.tokens), this.finishNode(t3, "File");
          }
          stmtToDirective(t3) {
            const e3 = t3.expression, s3 = this.startNodeAt(e3.start, e3.loc.start), i3 = this.startNodeAt(t3.start, t3.loc.start), r3 = this.input.slice(e3.start, e3.end), a3 = s3.value = r3.slice(1, -1);
            return this.addExtra(s3, "raw", r3), this.addExtra(s3, "rawValue", a3), i3.value = this.finishNodeAt(s3, "DirectiveLiteral", e3.end, e3.loc.end), this.finishNodeAt(i3, "Directive", t3.end, t3.loc.end);
          }
          parseInterpreterDirective() {
            if (!this.match(n2.interpreterDirective))
              return null;
            const t3 = this.startNode();
            return t3.value = this.state.value, this.next(), this.finishNode(t3, "InterpreterDirective");
          }
          isLet(t3) {
            if (!this.isContextual("let"))
              return false;
            const e3 = this.nextTokenStart(), s3 = this.input.charCodeAt(e3);
            if (s3 === 91)
              return true;
            if (t3)
              return false;
            if (s3 === 123)
              return true;
            if (w2(s3)) {
              let t4 = e3 + 1;
              for (; N2(this.input.charCodeAt(t4)); )
                ++t4;
              const s4 = this.input.slice(e3, t4);
              if (!B2.test(s4))
                return true;
            }
            return false;
          }
          parseStatement(t3, e3) {
            return this.match(n2.at) && this.parseDecorators(true), this.parseStatementContent(t3, e3);
          }
          parseStatementContent(t3, e3) {
            let s3 = this.state.type;
            const i3 = this.startNode();
            let r3;
            switch (this.isLet(t3) && (s3 = n2._var, r3 = "let"), s3) {
              case n2._break:
              case n2._continue:
                return this.parseBreakContinueStatement(i3, s3.keyword);
              case n2._debugger:
                return this.parseDebuggerStatement(i3);
              case n2._do:
                return this.parseDoStatement(i3);
              case n2._for:
                return this.parseForStatement(i3);
              case n2._function:
                if (this.lookaheadCharCode() === 46)
                  break;
                return t3 && (this.state.strict ? this.raise(this.state.start, f2.StrictFunction) : t3 !== "if" && t3 !== "label" && this.raise(this.state.start, f2.SloppyFunction)), this.parseFunctionStatement(i3, false, !t3);
              case n2._class:
                return t3 && this.unexpected(), this.parseClass(i3, true);
              case n2._if:
                return this.parseIfStatement(i3);
              case n2._return:
                return this.parseReturnStatement(i3);
              case n2._switch:
                return this.parseSwitchStatement(i3);
              case n2._throw:
                return this.parseThrowStatement(i3);
              case n2._try:
                return this.parseTryStatement(i3);
              case n2._const:
              case n2._var:
                return r3 = r3 || this.state.value, t3 && r3 !== "var" && this.raise(this.state.start, f2.UnexpectedLexicalDeclaration), this.parseVarStatement(i3, r3);
              case n2._while:
                return this.parseWhileStatement(i3);
              case n2._with:
                return this.parseWithStatement(i3);
              case n2.braceL:
                return this.parseBlock();
              case n2.semi:
                return this.parseEmptyStatement(i3);
              case n2._import: {
                const t4 = this.lookaheadCharCode();
                if (t4 === 40 || t4 === 46)
                  break;
              }
              case n2._export: {
                let t4;
                return this.options.allowImportExportEverywhere || e3 || this.raise(this.state.start, f2.UnexpectedImportExport), this.next(), s3 === n2._import ? (t4 = this.parseImport(i3), t4.type !== "ImportDeclaration" || t4.importKind && t4.importKind !== "value" || (this.sawUnambiguousESM = true)) : (t4 = this.parseExport(i3), (t4.type !== "ExportNamedDeclaration" || t4.exportKind && t4.exportKind !== "value") && (t4.type !== "ExportAllDeclaration" || t4.exportKind && t4.exportKind !== "value") && t4.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(i3), t4;
              }
              default:
                if (this.isAsyncFunction())
                  return t3 && this.raise(this.state.start, f2.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(i3, true, !t3);
            }
            const a3 = this.state.value, o3 = this.parseExpression();
            return s3 === n2.name && o3.type === "Identifier" && this.eat(n2.colon) ? this.parseLabeledStatement(i3, a3, o3, t3) : this.parseExpressionStatement(i3, o3);
          }
          assertModuleNodeAllowed(t3) {
            this.options.allowImportExportEverywhere || this.inModule || this.raiseWithData(t3.start, {code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"}, f2.ImportOutsideModule);
          }
          takeDecorators(t3) {
            const e3 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            e3.length && (t3.decorators = e3, this.resetStartLocationFromNode(t3, e3[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
          }
          canHaveLeadingDecorator() {
            return this.match(n2._class);
          }
          parseDecorators(t3) {
            const e3 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            for (; this.match(n2.at); ) {
              const t4 = this.parseDecorator();
              e3.push(t4);
            }
            if (this.match(n2._export))
              t3 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, f2.DecoratorExportClass);
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(this.state.start, f2.UnexpectedLeadingDecorator);
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators-legacy", "decorators"]);
            const t3 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              this.state.decoratorStack.push([]);
              const e3 = this.state.start, s3 = this.state.startLoc;
              let i3;
              if (this.eat(n2.parenL))
                i3 = this.parseExpression(), this.expect(n2.parenR);
              else
                for (i3 = this.parseIdentifier(false); this.eat(n2.dot); ) {
                  const t4 = this.startNodeAt(e3, s3);
                  t4.object = i3, t4.property = this.parseIdentifier(true), t4.computed = false, i3 = this.finishNode(t4, "MemberExpression");
                }
              t3.expression = this.parseMaybeDecoratorArguments(i3), this.state.decoratorStack.pop();
            } else
              t3.expression = this.parseExprSubscripts();
            return this.finishNode(t3, "Decorator");
          }
          parseMaybeDecoratorArguments(t3) {
            if (this.eat(n2.parenL)) {
              const e3 = this.startNodeAtNode(t3);
              return e3.callee = t3, e3.arguments = this.parseCallExpressionArguments(n2.parenR, false), this.toReferencedList(e3.arguments), this.finishNode(e3, "CallExpression");
            }
            return t3;
          }
          parseBreakContinueStatement(t3, e3) {
            const s3 = e3 === "break";
            return this.next(), this.isLineTerminator() ? t3.label = null : (t3.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t3, e3), this.finishNode(t3, s3 ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(t3, e3) {
            const s3 = e3 === "break";
            let i3;
            for (i3 = 0; i3 < this.state.labels.length; ++i3) {
              const e4 = this.state.labels[i3];
              if (t3.label == null || e4.name === t3.label.name) {
                if (e4.kind != null && (s3 || e4.kind === "loop"))
                  break;
                if (t3.label && s3)
                  break;
              }
            }
            i3 === this.state.labels.length && this.raise(t3.start, f2.IllegalBreakContinue, e3);
          }
          parseDebuggerStatement(t3) {
            return this.next(), this.semicolon(), this.finishNode(t3, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(n2.parenL);
            const t3 = this.parseExpression();
            return this.expect(n2.parenR), t3;
          }
          parseDoStatement(t3) {
            return this.next(), this.state.labels.push(Pt2), t3.body = this.withTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(n2._while), t3.test = this.parseHeaderExpression(), this.eat(n2.semi), this.finishNode(t3, "DoWhileStatement");
          }
          parseForStatement(t3) {
            this.next(), this.state.labels.push(Pt2);
            let e3 = -1;
            if (this.isAwaitAllowed() && this.eatContextual("await") && (e3 = this.state.lastTokStart), this.scope.enter(0), this.expect(n2.parenL), this.match(n2.semi))
              return e3 > -1 && this.unexpected(e3), this.parseFor(t3, null);
            const s3 = this.isLet();
            if (this.match(n2._var) || this.match(n2._const) || s3) {
              const i4 = this.startNode(), r4 = s3 ? "let" : this.state.value;
              return this.next(), this.parseVar(i4, true, r4), this.finishNode(i4, "VariableDeclaration"), (this.match(n2._in) || this.isContextual("of")) && i4.declarations.length === 1 ? this.parseForIn(t3, i4, e3) : (e3 > -1 && this.unexpected(e3), this.parseFor(t3, i4));
            }
            const i3 = new xt2(), r3 = this.parseExpression(true, i3);
            if (this.match(n2._in) || this.isContextual("of")) {
              this.toAssignable(r3);
              const s4 = this.isContextual("of") ? "for-of statement" : "for-in statement";
              return this.checkLVal(r3, void 0, void 0, s4), this.parseForIn(t3, r3, e3);
            }
            return this.checkExpressionErrors(i3, true), e3 > -1 && this.unexpected(e3), this.parseFor(t3, r3);
          }
          parseFunctionStatement(t3, e3, s3) {
            return this.next(), this.parseFunction(t3, 1 | (s3 ? 0 : 2), e3);
          }
          parseIfStatement(t3) {
            return this.next(), t3.test = this.parseHeaderExpression(), t3.consequent = this.parseStatement("if"), t3.alternate = this.eat(n2._else) ? this.parseStatement("if") : null, this.finishNode(t3, "IfStatement");
          }
          parseReturnStatement(t3) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, f2.IllegalReturn), this.next(), this.isLineTerminator() ? t3.argument = null : (t3.argument = this.parseExpression(), this.semicolon()), this.finishNode(t3, "ReturnStatement");
          }
          parseSwitchStatement(t3) {
            this.next(), t3.discriminant = this.parseHeaderExpression();
            const e3 = t3.cases = [];
            let s3, i3;
            for (this.expect(n2.braceL), this.state.labels.push(bt2), this.scope.enter(0); !this.match(n2.braceR); )
              if (this.match(n2._case) || this.match(n2._default)) {
                const t4 = this.match(n2._case);
                s3 && this.finishNode(s3, "SwitchCase"), e3.push(s3 = this.startNode()), s3.consequent = [], this.next(), t4 ? s3.test = this.parseExpression() : (i3 && this.raise(this.state.lastTokStart, f2.MultipleDefaultsInSwitch), i3 = true, s3.test = null), this.expect(n2.colon);
              } else
                s3 ? s3.consequent.push(this.parseStatement(null)) : this.unexpected();
            return this.scope.exit(), s3 && this.finishNode(s3, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t3, "SwitchStatement");
          }
          parseThrowStatement(t3) {
            return this.next(), o2.test(this.input.slice(this.state.lastTokEnd, this.state.start)) && this.raise(this.state.lastTokEnd, f2.NewlineAfterThrow), t3.argument = this.parseExpression(), this.semicolon(), this.finishNode(t3, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const t3 = this.parseBindingAtom(), e3 = t3.type === "Identifier";
            return this.scope.enter(e3 ? 8 : 0), this.checkLVal(t3, 9, null, "catch clause"), t3;
          }
          parseTryStatement(t3) {
            if (this.next(), t3.block = this.parseBlock(), t3.handler = null, this.match(n2._catch)) {
              const e3 = this.startNode();
              this.next(), this.match(n2.parenL) ? (this.expect(n2.parenL), e3.param = this.parseCatchClauseParam(), this.expect(n2.parenR)) : (e3.param = null, this.scope.enter(0)), e3.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t3.handler = this.finishNode(e3, "CatchClause");
            }
            return t3.finalizer = this.eat(n2._finally) ? this.parseBlock() : null, t3.handler || t3.finalizer || this.raise(t3.start, f2.NoCatchOrFinally), this.finishNode(t3, "TryStatement");
          }
          parseVarStatement(t3, e3) {
            return this.next(), this.parseVar(t3, false, e3), this.semicolon(), this.finishNode(t3, "VariableDeclaration");
          }
          parseWhileStatement(t3) {
            return this.next(), t3.test = this.parseHeaderExpression(), this.state.labels.push(Pt2), t3.body = this.withTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(t3, "WhileStatement");
          }
          parseWithStatement(t3) {
            return this.state.strict && this.raise(this.state.start, f2.StrictWith), this.next(), t3.object = this.parseHeaderExpression(), t3.body = this.withTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(t3, "WithStatement");
          }
          parseEmptyStatement(t3) {
            return this.next(), this.finishNode(t3, "EmptyStatement");
          }
          parseLabeledStatement(t3, e3, s3, i3) {
            for (let t4 = 0, i4 = this.state.labels; t4 < i4.length; t4++) {
              i4[t4].name === e3 && this.raise(s3.start, f2.LabelRedeclaration, e3);
            }
            const r3 = this.state.type.isLoop ? "loop" : this.match(n2._switch) ? "switch" : null;
            for (let e4 = this.state.labels.length - 1; e4 >= 0; e4--) {
              const s4 = this.state.labels[e4];
              if (s4.statementStart !== t3.start)
                break;
              s4.statementStart = this.state.start, s4.kind = r3;
            }
            return this.state.labels.push({name: e3, kind: r3, statementStart: this.state.start}), t3.body = this.parseStatement(i3 ? i3.indexOf("label") === -1 ? i3 + "label" : i3 : "label"), this.state.labels.pop(), t3.label = s3, this.finishNode(t3, "LabeledStatement");
          }
          parseExpressionStatement(t3, e3) {
            return t3.expression = e3, this.semicolon(), this.finishNode(t3, "ExpressionStatement");
          }
          parseBlock(t3 = false, e3 = true, s3) {
            const i3 = this.startNode();
            return this.expect(n2.braceL), e3 && this.scope.enter(0), this.parseBlockBody(i3, t3, false, n2.braceR, s3), e3 && this.scope.exit(), this.finishNode(i3, "BlockStatement");
          }
          isValidDirective(t3) {
            return t3.type === "ExpressionStatement" && t3.expression.type === "StringLiteral" && !t3.expression.extra.parenthesized;
          }
          parseBlockBody(t3, e3, s3, i3, r3) {
            const a3 = t3.body = [], n3 = t3.directives = [];
            this.parseBlockOrModuleBlockBody(a3, e3 ? n3 : void 0, s3, i3, r3);
          }
          parseBlockOrModuleBlockBody(t3, e3, s3, i3, r3) {
            const a3 = [], n3 = this.state.strict;
            let o3 = false, h3 = false;
            for (; !this.match(i3); ) {
              !h3 && this.state.octalPositions.length && a3.push(...this.state.octalPositions);
              const i4 = this.parseStatement(null, s3);
              if (e3 && !h3 && this.isValidDirective(i4)) {
                const t4 = this.stmtToDirective(i4);
                e3.push(t4), o3 || t4.value.value !== "use strict" || (o3 = true, this.setStrict(true));
              } else
                h3 = true, t3.push(i4);
            }
            if (this.state.strict && a3.length)
              for (let t4 = 0; t4 < a3.length; t4++) {
                const e4 = a3[t4];
                this.raise(e4, f2.StrictOctalLiteral);
              }
            r3 && r3.call(this, o3), n3 || this.setStrict(false), this.next();
          }
          parseFor(t3, e3) {
            return t3.init = e3, this.expect(n2.semi), t3.test = this.match(n2.semi) ? null : this.parseExpression(), this.expect(n2.semi), t3.update = this.match(n2.parenR) ? null : this.parseExpression(), this.expect(n2.parenR), t3.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t3, "ForStatement");
          }
          parseForIn(t3, e3, s3) {
            const i3 = this.match(n2._in);
            return this.next(), i3 ? s3 > -1 && this.unexpected(s3) : t3.await = s3 > -1, e3.type !== "VariableDeclaration" || e3.declarations[0].init == null || i3 && !this.state.strict && e3.kind === "var" && e3.declarations[0].id.type === "Identifier" ? e3.type === "AssignmentPattern" && this.raise(e3.start, f2.InvalidLhs, "for-loop") : this.raise(e3.start, f2.ForInOfLoopInitializer, i3 ? "for-in" : "for-of"), t3.left = e3, t3.right = i3 ? this.parseExpression() : this.parseMaybeAssign(), this.expect(n2.parenR), t3.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t3, i3 ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(t3, e3, s3) {
            const i3 = t3.declarations = [], r3 = this.hasPlugin("typescript");
            for (t3.kind = s3; ; ) {
              const t4 = this.startNode();
              if (this.parseVarId(t4, s3), this.eat(n2.eq) ? t4.init = this.parseMaybeAssign(e3) : (s3 !== "const" || this.match(n2._in) || this.isContextual("of") ? t4.id.type === "Identifier" || e3 && (this.match(n2._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, f2.DeclarationMissingInitializer, "Complex binding patterns") : r3 || this.unexpected(), t4.init = null), i3.push(this.finishNode(t4, "VariableDeclarator")), !this.eat(n2.comma))
                break;
            }
            return t3;
          }
          parseVarId(t3, e3) {
            t3.id = this.parseBindingAtom(), this.checkLVal(t3.id, e3 === "var" ? 5 : 9, void 0, "variable declaration", e3 !== "var");
          }
          parseFunction(t3, e3 = 0, s3 = false) {
            const i3 = 1 & e3, r3 = 2 & e3, a3 = !(!i3 || 4 & e3);
            this.initFunction(t3, s3), this.match(n2.star) && r3 && this.raise(this.state.start, f2.GeneratorInSingleStatementContext), t3.generator = this.eat(n2.star), i3 && (t3.id = this.parseFunctionId(a3));
            const o3 = this.state.maybeInArrowParameters, h3 = this.state.yieldPos, c3 = this.state.awaitPos;
            return this.state.maybeInArrowParameters = false, this.state.yieldPos = -1, this.state.awaitPos = -1, this.scope.enter(2), this.prodParam.enter(et2(s3, t3.generator)), i3 || (t3.id = this.parseFunctionId()), this.parseFunctionParams(t3), this.withTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(t3, i3 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), i3 && !r3 && this.registerFunctionStatementId(t3), this.state.maybeInArrowParameters = o3, this.state.yieldPos = h3, this.state.awaitPos = c3, t3;
          }
          parseFunctionId(t3) {
            return t3 || this.match(n2.name) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(t3, e3) {
            const s3 = this.state.inParameters;
            this.state.inParameters = true, this.expect(n2.parenL), t3.params = this.parseBindingList(n2.parenR, 41, false, e3), this.state.inParameters = s3, this.checkYieldAwaitInDefaultParams();
          }
          registerFunctionStatementId(t3) {
            t3.id && this.scope.declareName(t3.id.name, this.state.strict || t3.generator || t3.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, t3.id.start);
          }
          parseClass(t3, e3, s3) {
            this.next(), this.takeDecorators(t3);
            const i3 = this.state.strict;
            return this.state.strict = true, this.parseClassId(t3, e3, s3), this.parseClassSuper(t3), t3.body = this.parseClassBody(!!t3.superClass, i3), this.finishNode(t3, e3 ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(n2.eq) || this.match(n2.semi) || this.match(n2.braceR);
          }
          isClassMethod() {
            return this.match(n2.parenL);
          }
          isNonstaticConstructor(t3) {
            return !(t3.computed || t3.static || t3.key.name !== "constructor" && t3.key.value !== "constructor");
          }
          parseClassBody(t3, e3) {
            this.classScope.enter();
            const s3 = {hadConstructor: false};
            let i3 = [];
            const r3 = this.startNode();
            if (r3.body = [], this.expect(n2.braceL), this.withTopicForbiddingContext(() => {
              for (; !this.match(n2.braceR); ) {
                if (this.eat(n2.semi)) {
                  if (i3.length > 0)
                    throw this.raise(this.state.lastTokEnd, f2.DecoratorSemicolon);
                  continue;
                }
                if (this.match(n2.at)) {
                  i3.push(this.parseDecorator());
                  continue;
                }
                const e4 = this.startNode();
                i3.length && (e4.decorators = i3, this.resetStartLocationFromNode(e4, i3[0]), i3 = []), this.parseClassMember(r3, e4, s3, t3), e4.kind === "constructor" && e4.decorators && e4.decorators.length > 0 && this.raise(e4.start, f2.DecoratorConstructor);
              }
            }), this.state.strict = e3, this.next(), i3.length)
              throw this.raise(this.state.start, f2.TrailingDecorator);
            return this.classScope.exit(), this.finishNode(r3, "ClassBody");
          }
          maybeClassModifier(t3) {
            return !t3.computed && t3.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(n2.bracketL) || this.match(n2.star) || this.match(n2.hash));
          }
          parseClassMemberFromModifier(t3, e3) {
            const s3 = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const i3 = e3;
              return i3.kind = "method", i3.computed = false, i3.key = s3, i3.static = false, this.pushClassMethod(t3, i3, false, false, false, false), true;
            }
            if (this.isClassProperty()) {
              const i3 = e3;
              return i3.computed = false, i3.key = s3, i3.static = false, t3.body.push(this.parseClassProperty(i3)), true;
            }
            return false;
          }
          parseClassMember(t3, e3, s3, i3) {
            const r3 = this.isContextual("static");
            r3 && this.parseClassMemberFromModifier(t3, e3) || this.parseClassMemberWithIsStatic(t3, e3, s3, r3, i3);
          }
          parseClassMemberWithIsStatic(t3, e3, s3, i3, r3) {
            const a3 = e3, o3 = e3, h3 = e3, c3 = e3, p3 = a3, u3 = a3;
            if (e3.static = i3, this.eat(n2.star))
              return p3.kind = "method", this.parseClassElementName(p3), p3.key.type === "PrivateName" ? void this.pushClassPrivateMethod(t3, o3, true, false) : (this.isNonstaticConstructor(a3) && this.raise(a3.key.start, f2.ConstructorIsGenerator), void this.pushClassMethod(t3, a3, true, false, false, false));
            const l3 = this.state.containsEsc, d3 = this.parseClassElementName(e3), m3 = d3.type === "PrivateName", D3 = d3.type === "Identifier", y3 = this.state.start;
            if (this.parsePostMemberNameModifiers(u3), this.isClassMethod()) {
              if (p3.kind = "method", m3)
                return void this.pushClassPrivateMethod(t3, o3, false, false);
              const e4 = this.isNonstaticConstructor(a3);
              let i4 = false;
              e4 && (a3.kind = "constructor", s3.hadConstructor && !this.hasPlugin("typescript") && this.raise(d3.start, f2.DuplicateConstructor), s3.hadConstructor = true, i4 = r3), this.pushClassMethod(t3, a3, false, false, e4, i4);
            } else if (this.isClassProperty())
              m3 ? this.pushClassPrivateProperty(t3, c3) : this.pushClassProperty(t3, h3);
            else if (!D3 || d3.name !== "async" || l3 || this.isLineTerminator())
              !D3 || d3.name !== "get" && d3.name !== "set" || l3 || this.match(n2.star) && this.isLineTerminator() ? this.isLineTerminator() ? m3 ? this.pushClassPrivateProperty(t3, c3) : this.pushClassProperty(t3, h3) : this.unexpected() : (p3.kind = d3.name, this.parseClassElementName(a3), p3.key.type === "PrivateName" ? this.pushClassPrivateMethod(t3, o3, false, false) : (this.isNonstaticConstructor(a3) && this.raise(a3.key.start, f2.ConstructorIsAccessor), this.pushClassMethod(t3, a3, false, false, false, false)), this.checkGetterSetterParams(a3));
            else {
              const e4 = this.eat(n2.star);
              u3.optional && this.unexpected(y3), p3.kind = "method", this.parseClassElementName(p3), this.parsePostMemberNameModifiers(u3), p3.key.type === "PrivateName" ? this.pushClassPrivateMethod(t3, o3, e4, true) : (this.isNonstaticConstructor(a3) && this.raise(a3.key.start, f2.ConstructorIsAsync), this.pushClassMethod(t3, a3, e4, true, false, false));
            }
          }
          parseClassElementName(t3) {
            const e3 = this.parsePropertyName(t3, true);
            return t3.computed || !t3.static || e3.name !== "prototype" && e3.value !== "prototype" || this.raise(e3.start, f2.StaticPrototype), e3.type === "PrivateName" && e3.id.name === "constructor" && this.raise(e3.start, f2.ConstructorClassPrivateField), e3;
          }
          pushClassProperty(t3, e3) {
            e3.computed || e3.key.name !== "constructor" && e3.key.value !== "constructor" || this.raise(e3.key.start, f2.ConstructorClassField), t3.body.push(this.parseClassProperty(e3));
          }
          pushClassPrivateProperty(t3, e3) {
            this.expectPlugin("classPrivateProperties", e3.key.start);
            const s3 = this.parseClassPrivateProperty(e3);
            t3.body.push(s3), this.classScope.declarePrivateName(s3.key.id.name, 0, s3.key.start);
          }
          pushClassMethod(t3, e3, s3, i3, r3, a3) {
            t3.body.push(this.parseMethod(e3, s3, i3, r3, a3, "ClassMethod", true));
          }
          pushClassPrivateMethod(t3, e3, s3, i3) {
            this.expectPlugin("classPrivateMethods", e3.key.start);
            const r3 = this.parseMethod(e3, s3, i3, false, false, "ClassPrivateMethod", true);
            t3.body.push(r3);
            const a3 = r3.kind === "get" ? r3.static ? 6 : 2 : r3.kind === "set" ? r3.static ? 5 : 1 : 0;
            this.classScope.declarePrivateName(r3.key.id.name, a3, r3.key.start);
          }
          parsePostMemberNameModifiers(t3) {
          }
          parseAccessModifier() {
          }
          parseClassPrivateProperty(t3) {
            return this.scope.enter(80), this.prodParam.enter(0), t3.value = this.eat(n2.eq) ? this.parseMaybeAssign() : null, this.semicolon(), this.prodParam.exit(), this.scope.exit(), this.finishNode(t3, "ClassPrivateProperty");
          }
          parseClassProperty(t3) {
            return t3.typeAnnotation || this.expectPlugin("classProperties"), this.scope.enter(80), this.prodParam.enter(0), this.match(n2.eq) ? (this.expectPlugin("classProperties"), this.next(), t3.value = this.parseMaybeAssign()) : t3.value = null, this.semicolon(), this.prodParam.exit(), this.scope.exit(), this.finishNode(t3, "ClassProperty");
          }
          parseClassId(t3, e3, s3, i3 = 139) {
            this.match(n2.name) ? (t3.id = this.parseIdentifier(), e3 && this.checkLVal(t3.id, i3, void 0, "class name")) : s3 || !e3 ? t3.id = null : this.unexpected(null, f2.MissingClassName);
          }
          parseClassSuper(t3) {
            t3.superClass = this.eat(n2._extends) ? this.parseExprSubscripts() : null;
          }
          parseExport(t3) {
            const e3 = this.maybeParseExportDefaultSpecifier(t3), s3 = !e3 || this.eat(n2.comma), i3 = s3 && this.eatExportStar(t3), r3 = i3 && this.maybeParseExportNamespaceSpecifier(t3), a3 = s3 && (!r3 || this.eat(n2.comma)), o3 = e3 || i3;
            if (i3 && !r3)
              return e3 && this.unexpected(), this.parseExportFrom(t3, true), this.finishNode(t3, "ExportAllDeclaration");
            const h3 = this.maybeParseExportNamedSpecifiers(t3);
            if (e3 && s3 && !i3 && !h3 || r3 && a3 && !h3)
              throw this.unexpected(null, n2.braceL);
            let c3;
            if (o3 || h3 ? (c3 = false, this.parseExportFrom(t3, o3)) : c3 = this.maybeParseExportDeclaration(t3), o3 || h3 || c3)
              return this.checkExport(t3, true, false, !!t3.source), this.finishNode(t3, "ExportNamedDeclaration");
            if (this.eat(n2._default))
              return t3.declaration = this.parseExportDefaultExpression(), this.checkExport(t3, true, true), this.finishNode(t3, "ExportDefaultDeclaration");
            throw this.unexpected(null, n2.braceL);
          }
          eatExportStar(t3) {
            return this.eat(n2.star);
          }
          maybeParseExportDefaultSpecifier(t3) {
            if (this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom");
              const e3 = this.startNode();
              return e3.exported = this.parseIdentifier(true), t3.specifiers = [this.finishNode(e3, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(t3) {
            if (this.isContextual("as")) {
              t3.specifiers || (t3.specifiers = []);
              const e3 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
              return this.next(), e3.exported = this.parseIdentifier(true), t3.specifiers.push(this.finishNode(e3, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(t3) {
            return !!this.match(n2.braceL) && (t3.specifiers || (t3.specifiers = []), t3.specifiers.push(...this.parseExportSpecifiers()), t3.source = null, t3.declaration = null, true);
          }
          maybeParseExportDeclaration(t3) {
            if (this.shouldParseExportDeclaration()) {
              if (this.isContextual("async")) {
                const t4 = this.nextTokenStart();
                this.isUnparsedContextual(t4, "function") || this.unexpected(t4, n2._function);
              }
              return t3.specifiers = [], t3.source = null, t3.declaration = this.parseExportDeclaration(t3), true;
            }
            return false;
          }
          isAsyncFunction() {
            if (!this.isContextual("async"))
              return false;
            const t3 = this.nextTokenStart();
            return !o2.test(this.input.slice(this.state.pos, t3)) && this.isUnparsedContextual(t3, "function");
          }
          parseExportDefaultExpression() {
            const t3 = this.startNode(), e3 = this.isAsyncFunction();
            if (this.match(n2._function) || e3)
              return this.next(), e3 && this.next(), this.parseFunction(t3, 5, e3);
            if (this.match(n2._class))
              return this.parseClass(t3, true, true);
            if (this.match(n2.at))
              return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, f2.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(t3, true, true);
            if (this.match(n2._const) || this.match(n2._var) || this.isLet())
              throw this.raise(this.state.start, f2.UnsupportedDefaultExport);
            {
              const t4 = this.parseMaybeAssign();
              return this.semicolon(), t4;
            }
          }
          parseExportDeclaration(t3) {
            return this.parseStatement(null);
          }
          isExportDefaultSpecifier() {
            if (this.match(n2.name)) {
              const t4 = this.state.value;
              if (t4 === "async" && !this.state.containsEsc || t4 === "let")
                return false;
              if ((t4 === "type" || t4 === "interface") && !this.state.containsEsc) {
                const t5 = this.lookahead();
                if (t5.type === n2.name && t5.value !== "from" || t5.type === n2.braceL)
                  return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(n2._default))
              return false;
            const t3 = this.nextTokenStart(), e3 = this.isUnparsedContextual(t3, "from");
            if (this.input.charCodeAt(t3) === 44 || this.match(n2.name) && e3)
              return true;
            if (this.match(n2._default) && e3) {
              const e4 = this.input.charCodeAt(this.nextTokenStartSince(t3 + 4));
              return e4 === 34 || e4 === 39;
            }
            return false;
          }
          parseExportFrom(t3, e3) {
            this.eatContextual("from") ? (t3.source = this.parseImportSource(), this.checkExport(t3)) : e3 ? this.unexpected() : t3.source = null, this.semicolon();
          }
          shouldParseExportDeclaration() {
            if (this.match(n2.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
              if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
                return true;
              this.unexpected(this.state.start, f2.DecoratorBeforeExport);
            }
            return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
          }
          checkExport(t3, e3, s3, i3) {
            if (e3) {
              if (s3) {
                if (this.checkDuplicateExports(t3, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var r3;
                  const e4 = t3.declaration;
                  e4.type !== "Identifier" || e4.name !== "from" || e4.end - e4.start != 4 || ((r3 = e4.extra) == null ? void 0 : r3.parenthesized) || this.raise(e4.start, f2.ExportDefaultFromAsIdentifier);
                }
              } else if (t3.specifiers && t3.specifiers.length)
                for (let e4 = 0, s4 = t3.specifiers; e4 < s4.length; e4++) {
                  const t4 = s4[e4];
                  this.checkDuplicateExports(t4, t4.exported.name), !i3 && t4.local && (this.checkReservedWord(t4.local.name, t4.local.start, true, false), this.scope.checkLocalExport(t4.local));
                }
              else if (t3.declaration) {
                if (t3.declaration.type === "FunctionDeclaration" || t3.declaration.type === "ClassDeclaration") {
                  const e4 = t3.declaration.id;
                  if (!e4)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(t3, e4.name);
                } else if (t3.declaration.type === "VariableDeclaration")
                  for (let e4 = 0, s4 = t3.declaration.declarations; e4 < s4.length; e4++) {
                    const t4 = s4[e4];
                    this.checkDeclaration(t4.id);
                  }
              }
            }
            if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) {
              const e4 = t3.declaration && (t3.declaration.type === "ClassDeclaration" || t3.declaration.type === "ClassExpression");
              if (!t3.declaration || !e4)
                throw this.raise(t3.start, f2.UnsupportedDecoratorExport);
              this.takeDecorators(t3.declaration);
            }
          }
          checkDeclaration(t3) {
            if (t3.type === "Identifier")
              this.checkDuplicateExports(t3, t3.name);
            else if (t3.type === "ObjectPattern")
              for (let e3 = 0, s3 = t3.properties; e3 < s3.length; e3++) {
                const t4 = s3[e3];
                this.checkDeclaration(t4);
              }
            else if (t3.type === "ArrayPattern")
              for (let e3 = 0, s3 = t3.elements; e3 < s3.length; e3++) {
                const t4 = s3[e3];
                t4 && this.checkDeclaration(t4);
              }
            else
              t3.type === "ObjectProperty" ? this.checkDeclaration(t3.value) : t3.type === "RestElement" ? this.checkDeclaration(t3.argument) : t3.type === "AssignmentPattern" && this.checkDeclaration(t3.left);
          }
          checkDuplicateExports(t3, e3) {
            this.state.exportedIdentifiers.indexOf(e3) > -1 && this.raise(t3.start, e3 === "default" ? f2.DuplicateDefaultExport : f2.DuplicateExport, e3), this.state.exportedIdentifiers.push(e3);
          }
          parseExportSpecifiers() {
            const t3 = [];
            let e3 = true;
            for (this.expect(n2.braceL); !this.eat(n2.braceR); ) {
              if (e3)
                e3 = false;
              else if (this.expect(n2.comma), this.eat(n2.braceR))
                break;
              const s3 = this.startNode();
              s3.local = this.parseIdentifier(true), s3.exported = this.eatContextual("as") ? this.parseIdentifier(true) : s3.local.__clone(), t3.push(this.finishNode(s3, "ExportSpecifier"));
            }
            return t3;
          }
          parseImport(t3) {
            if (t3.specifiers = [], !this.match(n2.string)) {
              const e4 = !this.maybeParseDefaultImportSpecifier(t3) || this.eat(n2.comma), s3 = e4 && this.maybeParseStarImportSpecifier(t3);
              e4 && !s3 && this.parseNamedImportSpecifiers(t3), this.expectContextual("from");
            }
            t3.source = this.parseImportSource();
            const e3 = this.maybeParseModuleAttributes();
            return e3 && (t3.attributes = e3), this.semicolon(), this.finishNode(t3, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(n2.string) || this.unexpected(), this.parseExprAtom();
          }
          shouldParseDefaultImport(t3) {
            return this.match(n2.name);
          }
          parseImportSpecifierLocal(t3, e3, s3, i3) {
            e3.local = this.parseIdentifier(), this.checkLVal(e3.local, 9, void 0, i3), t3.specifiers.push(this.finishNode(e3, s3));
          }
          maybeParseModuleAttributes() {
            if (!this.match(n2._with) || this.hasPrecedingLineBreak())
              return this.hasPlugin("moduleAttributes") ? [] : null;
            this.expectPlugin("moduleAttributes"), this.next();
            const t3 = [], e3 = new Set();
            do {
              const s3 = this.startNode();
              if (s3.key = this.parseIdentifier(true), s3.key.name !== "type" && this.raise(s3.key.start, f2.ModuleAttributeDifferentFromType, s3.key.name), e3.has(s3.key.name) && this.raise(s3.key.start, f2.ModuleAttributesWithDuplicateKeys, s3.key.name), e3.add(s3.key.name), this.expect(n2.colon), !this.match(n2.string))
                throw this.unexpected(this.state.start, f2.ModuleAttributeInvalidValue);
              s3.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s3, "ImportAttribute"), t3.push(s3);
            } while (this.eat(n2.comma));
            return t3;
          }
          maybeParseDefaultImportSpecifier(t3) {
            return !!this.shouldParseDefaultImport(t3) && (this.parseImportSpecifierLocal(t3, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
          }
          maybeParseStarImportSpecifier(t3) {
            if (this.match(n2.star)) {
              const e3 = this.startNode();
              return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(t3, e3, "ImportNamespaceSpecifier", "import namespace specifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(t3) {
            let e3 = true;
            for (this.expect(n2.braceL); !this.eat(n2.braceR); ) {
              if (e3)
                e3 = false;
              else {
                if (this.eat(n2.colon))
                  throw this.raise(this.state.start, f2.DestructureNamedImport);
                if (this.expect(n2.comma), this.eat(n2.braceR))
                  break;
              }
              this.parseImportSpecifier(t3);
            }
          }
          parseImportSpecifier(t3) {
            const e3 = this.startNode();
            e3.imported = this.parseIdentifier(true), this.eatContextual("as") ? e3.local = this.parseIdentifier() : (this.checkReservedWord(e3.imported.name, e3.start, true, true), e3.local = e3.imported.__clone()), this.checkLVal(e3.local, 9, void 0, "import specifier"), t3.specifiers.push(this.finishNode(e3, "ImportSpecifier"));
          }
        } {
          constructor(t3, e3) {
            super(t3 = function(t4) {
              const e4 = {};
              for (let s4 = 0, i3 = Object.keys(ut2); s4 < i3.length; s4++) {
                const r3 = i3[s4];
                e4[r3] = t4 && t4[r3] != null ? t4[r3] : ut2[r3];
              }
              return e4;
            }(t3), e3);
            const s3 = this.getScopeHandler();
            this.options = t3, this.inModule = this.options.sourceType === "module", this.scope = new s3(this.raise.bind(this), this.inModule), this.prodParam = new tt2(), this.classScope = new Tt2(this.raise.bind(this)), this.plugins = function(t4) {
              const e4 = new Map();
              for (let s4 = 0; s4 < t4.length; s4++) {
                const i3 = t4[s4], [r3, a3] = Array.isArray(i3) ? i3 : [i3, {}];
                e4.has(r3) || e4.set(r3, a3 || {});
              }
              return e4;
            }(this.options.plugins), this.filename = t3.sourceFilename;
          }
          getScopeHandler() {
            return Y2;
          }
          parse() {
            let t3 = 0;
            this.hasPlugin("topLevelAwait") && this.inModule && (t3 |= 2), this.scope.enter(1), this.prodParam.enter(t3);
            const e3 = this.startNode(), s3 = this.startNode();
            return this.nextToken(), e3.errors = null, this.parseTopLevel(e3, s3), e3.errors = this.state.errors, e3;
          }
        }
        function wt2(t3, e3) {
          let s3 = At2;
          return (t3 == null ? void 0 : t3.plugins) && (!function(t4) {
            if (at2(t4, "decorators")) {
              if (at2(t4, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              const e4 = nt2(t4, "decorators", "decoratorsBeforeExport");
              if (e4 == null)
                throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
              if (typeof e4 != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
            if (at2(t4, "flow") && at2(t4, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (at2(t4, "placeholders") && at2(t4, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (at2(t4, "pipelineOperator") && !ot2.includes(nt2(t4, "pipelineOperator", "proposal")))
              throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + ot2.map((t5) => "'".concat(t5, "'")).join(", "));
            if (at2(t4, "moduleAttributes") && nt2(t4, "moduleAttributes", "version") !== "may-2020")
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            if (at2(t4, "recordAndTuple") && !ht2.includes(nt2(t4, "recordAndTuple", "syntaxType")))
              throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + ht2.map((t5) => "'".concat(t5, "'")).join(", "));
          }(t3.plugins), s3 = function(t4) {
            const e4 = pt2.filter((e5) => at2(t4, e5)), s4 = e4.join("/");
            let i3 = Nt2[s4];
            if (!i3) {
              i3 = At2;
              for (let t5 = 0; t5 < e4.length; t5++) {
                const s5 = e4[t5];
                i3 = ct2[s5](i3);
              }
              Nt2[s4] = i3;
            }
            return i3;
          }(t3.plugins)), new s3(t3, e3);
        }
        const Nt2 = {};
        e2.parse = function(t3, e3) {
          var s3;
          if (((s3 = e3) == null ? void 0 : s3.sourceType) !== "unambiguous")
            return wt2(e3, t3).parse();
          e3 = Object.assign({}, e3);
          try {
            e3.sourceType = "module";
            const s4 = wt2(e3, t3), i3 = s4.parse();
            if (s4.sawUnambiguousESM)
              return i3;
            if (s4.ambiguousScriptDifferentAst)
              try {
                return e3.sourceType = "script", wt2(e3, t3).parse();
              } catch (t4) {
              }
            else
              i3.program.sourceType = "script";
            return i3;
          } catch (s4) {
            try {
              return e3.sourceType = "script", wt2(e3, t3).parse();
            } catch (t4) {
            }
            throw s4;
          }
        }, e2.parseExpression = function(t3, e3) {
          const s3 = wt2(e3, t3);
          return s3.options.strictMode && (s3.state.strict = true), s3.getExpression();
        }, e2.tokTypes = n2;
      });
      const {hasPragma: qe} = ee, {locStart: Ve, locEnd: ze} = re;
      function He(e2, ...s2) {
        return (i2, r2, a2) => {
          const n2 = Ue, o2 = a2 && a2.__babelSourceType === "script" ? "script" : "module";
          let h2;
          try {
            h2 = function(t2, e3) {
              let s3;
              for (let i3 = 0; i3 < e3.length; i3++)
                try {
                  return $e(t2(e3[i3]));
                } catch (t3) {
                  s3 || (s3 = t3);
                }
              throw s3;
            }((t2) => n2[e2](i2, t2), function(t2, e3, s3) {
              if (!t2)
                return e3;
              const i3 = [];
              for (const t3 of e3)
                for (const e4 of s3)
                  i3.push([...t3, e4]);
              return i3;
            }(i2.includes("|>"), s2, [["pipelineOperator", {proposal: "smart"}], ["pipelineOperator", {proposal: "minimal"}], ["pipelineOperator", {proposal: "fsharp"}]]).map((t2) => function({sourceType: t3, extraPlugins: e3 = []}) {
              return {sourceType: t3, allowAwaitOutsideFunction: true, allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "classProperties", "exportDefaultFrom", "functionBind", "functionSent", "classPrivateProperties", "throwExpressions", "classPrivateMethods", "v8intrinsic", "partialApplication", ["decorators", {decoratorsBeforeExport: false}], "privateIn", ["moduleAttributes", {version: "may-2020"}], ["recordAndTuple", {syntaxType: "hash"}], "decimal", ...e3], tokens: true, ranges: true};
            }({sourceType: o2, extraPlugins: t2})));
          } catch (e3) {
            throw t(e3.message.replace(/ \(.*\)/, ""), e3.loc ? {start: {line: e3.loc.line, column: e3.loc.column + 1}} : {start: {line: 0, column: 0}});
          }
          return je(h2, Object.assign({}, a2, {originalText: i2}));
        };
      }
      const Ge = He("parse", ["jsx", "flow"]), We = He("parse", ["jsx", ["flow", {all: true, enums: true}]]), Xe = He("parse", ["jsx", "typescript"], ["typescript"]), Ke = He("parseExpression", ["jsx"]);
      function $e(t2) {
        if (t2.errors) {
          for (const e2 of t2.errors)
            if (typeof e2.message == "string" && (e2.message.startsWith("Did not expect a type annotation here.") || e2.message.startsWith("The only accepted module attribute is `type`")))
              throw e2;
        }
        return t2;
      }
      function Je(e2, s2) {
        switch (e2.type) {
          case "ArrayExpression":
            return e2.elements.forEach(i2);
          case "ObjectExpression":
            return e2.properties.forEach(i2);
          case "ObjectProperty":
            if (e2.computed)
              throw r2("computed");
            if (e2.shorthand)
              throw r2("shorthand");
            return [e2.key, e2.value].forEach(i2);
          case "UnaryExpression":
            switch (e2.operator) {
              case "+":
              case "-":
                return i2(e2.argument);
              default:
                throw r2("operator");
            }
          case "Identifier":
            if (s2 && s2.type === "ObjectProperty" && s2.key === e2)
              return;
            throw r2();
          case "NullLiteral":
          case "BooleanLiteral":
          case "NumericLiteral":
          case "StringLiteral":
            return;
          default:
            throw r2();
        }
        function i2(t2) {
          return Je(t2, e2);
        }
        function r2(s3) {
          const i3 = s3 ? "".concat(e2.type, " with ").concat(s3, "=").concat(JSON.stringify(e2[s3])) : e2.type;
          return t("".concat(i3, " is not allowed in JSON."), {start: {line: e2.loc.start.line, column: e2.loc.start.column + 1}});
        }
      }
      const Ye = {parse: Ge, astFormat: "estree", hasPragma: qe, locStart: Ve, locEnd: ze}, Qe = Object.assign({}, Ye, {parse: We}), Ze = Object.assign({}, Ye, {parse: Xe}), ts = Object.assign({}, Ye, {parse: Ke});
      return {parsers: {babel: Ye, "babel-flow": Qe, "babel-ts": Ze, json: Object.assign({}, ts, {hasPragma: () => true}), json5: ts, "json-stringify": {parse: function(t2, e2, s2) {
        const i2 = Ke(t2, e2, s2);
        return i2.comments.forEach(Je), Je(i2), i2;
      }, astFormat: "estree-json", locStart: Ve, locEnd: ze}, __js_expression: ts, __vue_expression: ts, __vue_event_binding: Ye}};
    });
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS((exports, module) => {
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    (function() {
      var undefined;
      var VERSION = "4.17.20";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        \u00C0: "A",
        \u00C1: "A",
        \u00C2: "A",
        \u00C3: "A",
        \u00C4: "A",
        \u00C5: "A",
        \u00E0: "a",
        \u00E1: "a",
        \u00E2: "a",
        \u00E3: "a",
        \u00E4: "a",
        \u00E5: "a",
        \u00C7: "C",
        \u00E7: "c",
        \u00D0: "D",
        \u00F0: "d",
        \u00C8: "E",
        \u00C9: "E",
        \u00CA: "E",
        \u00CB: "E",
        \u00E8: "e",
        \u00E9: "e",
        \u00EA: "e",
        \u00EB: "e",
        \u00CC: "I",
        \u00CD: "I",
        \u00CE: "I",
        \u00CF: "I",
        \u00EC: "i",
        \u00ED: "i",
        \u00EE: "i",
        \u00EF: "i",
        \u00D1: "N",
        \u00F1: "n",
        \u00D2: "O",
        \u00D3: "O",
        \u00D4: "O",
        \u00D5: "O",
        \u00D6: "O",
        \u00D8: "O",
        \u00F2: "o",
        \u00F3: "o",
        \u00F4: "o",
        \u00F5: "o",
        \u00F6: "o",
        \u00F8: "o",
        \u00D9: "U",
        \u00DA: "U",
        \u00DB: "U",
        \u00DC: "U",
        \u00F9: "u",
        \u00FA: "u",
        \u00FB: "u",
        \u00FC: "u",
        \u00DD: "Y",
        \u00FD: "y",
        \u00FF: "y",
        \u00C6: "Ae",
        \u00E6: "ae",
        \u00DE: "Th",
        \u00FE: "th",
        \u00DF: "ss",
        \u0100: "A",
        \u0102: "A",
        \u0104: "A",
        \u0101: "a",
        \u0103: "a",
        \u0105: "a",
        \u0106: "C",
        \u0108: "C",
        \u010A: "C",
        \u010C: "C",
        \u0107: "c",
        \u0109: "c",
        \u010B: "c",
        \u010D: "c",
        \u010E: "D",
        \u0110: "D",
        \u010F: "d",
        \u0111: "d",
        \u0112: "E",
        \u0114: "E",
        \u0116: "E",
        \u0118: "E",
        \u011A: "E",
        \u0113: "e",
        \u0115: "e",
        \u0117: "e",
        \u0119: "e",
        \u011B: "e",
        \u011C: "G",
        \u011E: "G",
        \u0120: "G",
        \u0122: "G",
        \u011D: "g",
        \u011F: "g",
        \u0121: "g",
        \u0123: "g",
        \u0124: "H",
        \u0126: "H",
        \u0125: "h",
        \u0127: "h",
        \u0128: "I",
        \u012A: "I",
        \u012C: "I",
        \u012E: "I",
        \u0130: "I",
        \u0129: "i",
        \u012B: "i",
        \u012D: "i",
        \u012F: "i",
        \u0131: "i",
        \u0134: "J",
        \u0135: "j",
        \u0136: "K",
        \u0137: "k",
        \u0138: "k",
        \u0139: "L",
        \u013B: "L",
        \u013D: "L",
        \u013F: "L",
        \u0141: "L",
        \u013A: "l",
        \u013C: "l",
        \u013E: "l",
        \u0140: "l",
        \u0142: "l",
        \u0143: "N",
        \u0145: "N",
        \u0147: "N",
        \u014A: "N",
        \u0144: "n",
        \u0146: "n",
        \u0148: "n",
        \u014B: "n",
        \u014C: "O",
        \u014E: "O",
        \u0150: "O",
        \u014D: "o",
        \u014F: "o",
        \u0151: "o",
        \u0154: "R",
        \u0156: "R",
        \u0158: "R",
        \u0155: "r",
        \u0157: "r",
        \u0159: "r",
        \u015A: "S",
        \u015C: "S",
        \u015E: "S",
        \u0160: "S",
        \u015B: "s",
        \u015D: "s",
        \u015F: "s",
        \u0161: "s",
        \u0162: "T",
        \u0164: "T",
        \u0166: "T",
        \u0163: "t",
        \u0165: "t",
        \u0167: "t",
        \u0168: "U",
        \u016A: "U",
        \u016C: "U",
        \u016E: "U",
        \u0170: "U",
        \u0172: "U",
        \u0169: "u",
        \u016B: "u",
        \u016D: "u",
        \u016F: "u",
        \u0171: "u",
        \u0173: "u",
        \u0174: "W",
        \u0175: "w",
        \u0176: "Y",
        \u0177: "y",
        \u0178: "Y",
        \u0179: "Z",
        \u017B: "Z",
        \u017D: "Z",
        \u017A: "z",
        \u017C: "z",
        \u017E: "z",
        \u0132: "IJ",
        \u0133: "ij",
        \u0152: "Oe",
        \u0153: "oe",
        \u0149: "'n",
        \u017F: "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined) {
            result = result === undefined ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined, symIterator = Symbol2 ? Symbol2.iterator : undefined, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined;
        }
        lodash2.templateSettings = {
          escape: reEscape,
          evaluate: reEvaluate,
          interpolate: reInterpolate,
          variable: "",
          imports: {
            _: lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            hash: new Hash(),
            map: new (Map2 || ListCache)(),
            string: new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
          var isCommon = newValue === undefined;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return {criteria, index: ++index, value};
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined;
              if (newValue === undefined) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            configurable: true,
            enumerable: false,
            value: constant(string),
            writable: true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
            if (newValue === undefined) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined && other === undefined) {
              return defaultValue;
            }
            if (value !== undefined) {
              result2 = value;
            }
            if (other !== undefined) {
              if (result2 === undefined) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined;
            }
            start = toFinite(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          ary2 = ary2 === undefined ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return {start, end};
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined;
          return array && array.length ? baseUniq(array, undefined, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            func: thru,
            args: [interceptor],
            thisArg: undefined
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
          return {done, value};
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              func: thru,
              args: [reverse],
              thisArg: undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }
          function flush() {
            return timerId === undefined ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            leading,
            maxWait: wait,
            trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined;
          var result2 = customizer ? customizer(value, other) : undefined;
          return result2 === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, "");
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined, customDefaultsMerge);
          return apply(mergeWith, undefined, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined : baseGet(object, path);
          return result2 === undefined ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined;
          }
          while (++index < length) {
            var value = object == null ? undefined : object[toKey(path[index])];
            if (value === undefined) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined) {
            upper = lower;
            lower = undefined;
          }
          if (upper !== undefined) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined;
          }
          if (floating === undefined) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined;
            }
          }
          if (lower === undefined && upper === undefined) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined;
          }
          limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrim, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrimEnd, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined : pattern;
          if (pattern === undefined) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({func, args: arguments, thisArg: object});
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce;
        lodash2.defaults = defaults;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite2;
        lodash2.isFunction = isFunction;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber;
        lodash2.isObject = isObject;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), {chain: false});
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                size: nativeMin(n, MAX_ARRAY_LENGTH),
                type: methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              iteratee: getIteratee(iteratee2, 3),
              type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined});
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({name: methodName, func: lodashFunc});
          }
        });
        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
          name: "wrapper",
          func: undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  });

  // lib/EvalWorker.worker.ts
  const esbuild_wasm = __toModule(require_browser());
  const standalone = __toModule(require_standalone());
  const parser_babel = __toModule(require_parser_babel());
  const lodash = require_lodash();
  let service;
  let isStartingService;
  let cb = null;
  async function getService() {
    if (!service && !isStartingService) {
      isStartingService = true;
      service = await esbuild_wasm.startService({
        wasmURL: "/eval/esbuild.wasm",
        worker: true
      });
      if (cb) {
        cb(service);
      }
    } else if (!service) {
      return new Promise((resolve) => {
        cb = resolve;
      });
    } else {
      return service;
    }
  }
  getService();
  function evalCode(code, ast) {
    return function() {
      this.module = {
        exports: {},
        require: function(id) {
          if (id === "lodash") {
            return lodash;
          } else {
            throw "RequireError module not found " + id;
          }
        }
      };
      eval.apply(this, [
        `var require = this.module.require; var module = this.module;
` + code
      ]);
      let output = "";
      switch (typeof this.module.exports.default) {
        case "number":
        case "string":
          output = this.module.exports.default.toString();
          break;
        case "function":
          output = this.module.exports.default.toString();
          break;
      }
      let header = "";
      for (let child of ast.children) {
        if (child.keyword === "export") {
          header += `export function ${child.name}(${child.value}) {
// Placeholder function that will be run & replaced at buildtime
        }

`;
        }
      }
      if (header.length > 0) {
        output = header + output;
      }
      return output;
    }();
  }
  const processCode = async function(code, ast) {
    const service2 = await getService();
    const result = await service2.transform(code, {
      target: "esnext",
      loader: "tsx",
      format: "cjs"
    });
    var source = result.code;
    if (source instanceof Uint8Array) {
      source = new TextDecoder().decode(source, {stream: false});
    }
    let runtime, error;
    try {
      if (result.code.length) {
        runtime = evalCode(source, ast);
      }
    } catch (exception) {
      error = exception;
    }
    if (runtime) {
      try {
        runtime = standalone.format(runtime, {plugins: [parser_babel.default]});
      } catch (exception) {
        throw exception;
      }
    }
    return {
      transformedCode: result.code,
      code: runtime,
      error,
      warnings: result.warnings
    };
  };
  self.addEventListener("message", ({data}) => {
    if (data.code) {
      processCode(data.code, data.ast).then((result) => self.postMessage(result), (err) => {
        console.error(err);
      });
    }
  });
})();
