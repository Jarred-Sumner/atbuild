import { AtBuild, requireFromString } from "../atbuild";
import { build } from "esbuild";
import path from "path";
import esbuildPlugin from "../esbuildPlugin";
import fs from "fs";
import {
  baseTypings,
  generateTypings,
} from "../typings-plugin/generateTypings";
const schema = {
  type: "object",
  properties: {
    typescript: {
      type: "boolean",
    },
    tsconfig: {
      type: "object",
      additionalProperties: true,
    },
  },
  additionalProperties: true,
};

let _esbuildInput = {
  format: "cjs",
  target: [`node${process.versions.node.split(".")[0]}`],
  outfile: "out.js",
  metafile: "meta.json",
  sourcemap: "inline",
  entryPoints: [""],
  platform: "node",
  resolveExtensions: [".ts", ".js", ".tsx", ".jsx", ".jsb", ".@js"],
  bundle: true,
  write: false,
  plugins: [esbuildPlugin],
};
let textDecoder = new TextDecoder("utf-8");

let temporaryCodeMap = new Map();
let readCompilationFs;

function readTemporaryAsset(name) {
  if (temporaryCodeMap.has(name)) {
    return temporaryCodeMap.get(name);
  } else if (readCompilationFs) {
    return readCompilationFs(name, "utf8");
  }
}

function formatContent(content) {
  return (
    `
// 🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖
//                          Auto-generated by AtBuild
//                               at ${Date.now()}
// 🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖🤖



` + content
  );
}

async function writeFile(name, content) {
  temporaryCodeMap.delete(name);
  if (content) {
    return fs.promises.writeFile(
      name.replace(path.extname(name.replace(".d.ts", "")), ""),
      formatContent(content),
      "utf-8"
    );
  } else if (fs.existsSync(name)) {
    fs.promises.writeFile(
      name.replace(path.extname(name.replace(".d.ts", "")), ""),
      "",
      "utf-8"
    );
  }
}
async function emitTypeDeclarationFile(resourcePath, code, typings) {
  temporaryCodeMap.set(resourcePath + ".ts", code);
  generateTypings(
    [resourcePath + ".ts"],
    typings,
    readTemporaryAsset,
    writeFile
  );
}

function handleESBuildResult(
  { outputFiles, warnings },
  input,
  callback,
  resourcePath,
  addDependency,
  ignoreDependency,
  typings
) {
  let source, meta;
  for (let outputFile of outputFiles) {
    if (outputFile.path.endsWith(input)) {
      source = textDecoder.decode(outputFile.contents);
    } else if (outputFile.path.endsWith("meta.json")) {
      meta = JSON.parse(textDecoder.decode(outputFile.contents));
    }
  }

  for (let key in meta.inputs) {
    if (key !== ignoreDependency) {
      addDependency(key);
    }
  }

  let code;
  try {
    code = requireFromString(source, input).default;
  } catch (exception) {
    callback(exception);
    return;
  }

  if (typings) {
    emitTypeDeclarationFile(resourcePath, code, typings);
  }

  if (process.env.WRITE_ATBUILD_TO_DISK) {
    fs.promises.writeFile(
      resourcePath.replace(
        path.extname(resourcePath),
        typings ? ".out.ts" : "out.js"
      ),
      code
    );
  }

  callback(null, code, {
    version: "3",
    sources: [resourcePath],
    file: resourcePath,
    sourcesContent: [],
    mappings: "",
  });
}

let typings = null,
  enableTypings = false;
export default function loader(_code) {
  const callback = this.async();

  if (this.getOptions) {
    const opts = this.getOptions(schema);

    if (typeof opts.tsconfig === "object") {
      typings = { ...opts.tsconfig.compilerOptions, ...baseTypings };
      enableTypings = true;
    } else if (opts.typescript || opts.tsconfig) {
      enableTypings = true;
      typings = baseTypings;
    } else {
      enableTypings = false;
    }
  }

  let esbuildInput = { ..._esbuildInput };

  esbuildInput.entryPoints = [this.resourcePath];
  esbuildInput.outfile = this.resourcePath + ".js";
  readCompilationFs = this._compilation.inputFileSystem.readFileSync;
  build(esbuildInput).then(
    (res) =>
      handleESBuildResult(
        res,
        esbuildInput.outfile,
        callback,
        this.resourcePath,
        this.addDependency,
        esbuildInput.entryPoints[0],
        enableTypings ? typings : null
      ),
    (err) => {
      console.error(err);
      debugger;

      callback(err);
    }
  );
}
