import {
  build as _build,
  startService,
  transform as _transform,
} from "esbuild";
import fs from "fs";
import { getOptions } from "loader-utils";
import path from "path";
import { requireFromString } from "../atbuild";
import esbuildPlugin from "../esbuildPlugin/fullPlugin";
import lightEsbuildPlugin from "../esbuildPlugin/lightPlugin";
import { buildAST, quickTest, transformAST } from "../light";
import {
  baseTypings,
  generateTypings,
} from "../typings-plugin/generateTypings";

let service;
let runCount = 0;

let build = _build;
let transform = _transform;

const schema = {
  type: "object",
  properties: {
    typescript: {
      type: "boolean",
    },
    tsconfig: {
      type: "object",
      additionalProperties: true,
    },
    jsExtensions: {
      type: "array",
      items: [
        {
          type: "string",
        },
      ],
      additionalItems: true,
    },
    atBuildExtensions: {
      type: "array",
      items: [
        {
          type: "string",
        },
      ],
      additionalItems: true,
    },
  },
  additionalProperties: true,
};

let _esbuildInput = {
  format: "cjs",
  target: [`node${process.versions.node.split(".")[0]}`],
  outfile: "out.js",
  metafile: "meta.json",
  sourcemap: "inline",
  platform: "node",
  resolveExtensions: [".ts", ".js", ".tsx", ".jsx", ".jsb", ".@js", ".atbuild"],
  bundle: true,
  write: false,
  plugins: [esbuildPlugin, lightEsbuildPlugin],
};

const stringifiedTsconfigs = {};

let textDecoder = new TextDecoder("utf-8");

let temporaryCodeMap = new Map();
let readCompilationFs;

function readTemporaryAsset(name) {
  if (temporaryCodeMap.has(name)) {
    return temporaryCodeMap.get(name);
  } else if (readCompilationFs) {
    return readCompilationFs(name, "utf8");
  }
}

async function runBuild(
  esbuildInput,
  callback,
  resourcePath,
  addDependency,
  typings,
  tsconfig,
  outputFormat,
  writeFile,
  onEmpty
) {
  if (runCount > 0 && !service) {
    service = await startService({
      worker: true,
    });

    build = service.build;
    transform = service.transform;

    process.on("beforeExit", () => {
      if (service) {
        service.stop();
      }
    });

    process.on("SIGABRT", () => {
      if (service) {
        service.stop();
      }
    });
  }

  return build(esbuildInput).then(
    (res) =>
      handleESBuildResult(
        res,
        esbuildInput.outfile,
        callback,
        resourcePath,
        addDependency,
        resourcePath,
        typings,
        tsconfig,
        outputFormat,
        writeFile,
        onEmpty
      ),
    (err) => {
      console.error(err);
      debugger;

      callback(err);
    }
  );
}

function formatContent(content) {
  return (
    `// 
//                          Auto-generated by AtBuild
//                               at ${Date.now()}
// 

` + content
  );
}

async function writeFile(name, content) {
  const outExt = path.extname(name.replace(".d.ts", ""));
  const outName = name.replace(outExt, "");

  temporaryCodeMap.delete(name);

  if (outExt.length === 0) {
    return;
  } else if (content) {
    fs.promises.writeFile(outName, formatContent(content), "utf-8");
  } else if (fs.existsSync(name)) {
    fs.promises.writeFile(outName, "", "utf-8");
  }
}
export async function emitTypeDeclarationFile(
  resourcePath,
  code,
  typings,
  writeFile
) {
  temporaryCodeMap.set(resourcePath + ".ts", code);
  generateTypings(
    [resourcePath + ".ts"],
    typings,
    readTemporaryAsset,
    writeFile
  );
}

export async function handleESBuildResult(
  _response,
  input,
  callback,
  resourcePath,
  addDependency,
  ignoreDependency,
  typings,
  tsconfig,
  outputFormat = "esm",
  writeFile,
  onEmpty
) {
  const { outputFiles, warnings, errors } = _response;
  if (errors && errors.length) {
    callback(new Error(errors[0]));
    return;
  }

  let source, meta;
  for (let outputFile of outputFiles) {
    if (outputFile.path.endsWith(input)) {
      source = textDecoder.decode(outputFile.contents);
    } else if (outputFile.path.endsWith("meta.json")) {
      meta = JSON.parse(textDecoder.decode(outputFile.contents));
    }
  }

  if (meta) {
    for (let key in meta.inputs) {
      if (key !== ignoreDependency) {
        addDependency(key);
      }
    }
  }

  if (!source || !source.length) {
    for (let outputFile of outputFiles) {
      outputFile.contents = textDecoder.decode(outputFile.contents);
    }
    callback(
      new Error(
        `---Bundling ${input} failed---.\n${JSON.stringify(
          outputFiles.map((o) => o.path),
          null,
          2
        )}\n\n---Bundling ${input} failed---`
      )
    );
    return;
  }

  let code;

  try {
    code = requireFromString(source, input).default;
  } catch (exception) {
    callback(exception);
    return;
  }

  if (typeof code === "function") {
    code = code.toString();
  }

  if (
    onEmpty &&
    (typeof code === "undefined" ||
      (typeof code === "string" && code.length === 0))
  ) {
    onEmpty();
    return;
  }
  // console.log(typings, "types?");
  if (typings) {
    emitTypeDeclarationFile(resourcePath, code, typings, writeFile);
    let result;

    try {
      result = await transform(code, {
        loader: "tsx",
        format: outputFormat,
        sourcefile: resourcePath + ".tsx",
        sourcemap: false,
      });
    } catch (exception) {
      callback(exception);
      return;
    }

    code = result.code;

    if (process.env.WRITE_ATBUILD_TO_DISK) {
      await fs.promises.writeFile(
        resourcePath.replace(
          path.extname(resourcePath),
          typings ? ".out.ts" : "out.js"
        ),
        code
      );
    }

    callback(null, code, {
      version: "3",
      sources: [resourcePath],
      file: resourcePath,
      sourcesContent: [],
      mappings: "",
    });
  } else {
    if (process.env.WRITE_ATBUILD_TO_DISK) {
      await fs.promises.writeFile(
        resourcePath.replace(
          path.extname(resourcePath),
          typings ? ".out.ts" : "out.js"
        ),
        code
      );
    }

    callback(null, code, {
      version: "3",
      sources: [resourcePath],
      file: resourcePath,
      sourcesContent: [],
      mappings: "",
    });
  }
}

let typings = null,
  tsconfig = null,
  enableTypings = false,
  fileExtension = "",
  opts;

let optionsGetter = getOptions;
const modes = {
  light: 0,
  full: 1,
};

const extensionForMode = [".atbuild", ""];

export const DEFAULT_JS_EXTENSIONS = [".js", ".ts", ".jsx", ".tsx"];
export const DEFAULT_ATBUILD_EXTENSIONS = [".jsb", ".@js", ".tsb", ".@ts"];

export function runWithOptions(
  _code,
  opts,
  resourcePath,
  readFile,
  getCallback,
  addDependency,
  outputFormat,
  writeFile,
  _mode = "auto"
) {
  let mode = _mode;
  let jsExtensions = opts.jsExtensions || DEFAULT_JS_EXTENSIONS;
  let atBuildExtensions = opts.atBuildExtensions || DEFAULT_ATBUILD_EXTENSIONS;
  fileExtension = path.extname(resourcePath);

  switch (mode) {
    case "light": {
      if (quickTest(_code)) {
        mode = modes.light;
      } else {
        return _code;
      }
      break;
    }

    case "full": {
      mode = modes.full;
      break;
    }

    default:
    case "auto": {
      if (
        fileExtension.length &&
        jsExtensions.includes(fileExtension) &&
        quickTest(_code)
      ) {
        mode = modes.light;
      } else if (
        fileExtension.length &&
        atBuildExtensions.includes(fileExtension)
      ) {
        mode = modes.full;
      } else {
        return _code;
      }
      break;
    }
  }

  if (typeof opts.tsconfig === "object") {
    typings = { ...opts.tsconfig.compilerOptions, ...baseTypings };

    enableTypings = true;
    delete typings.moduleResolution;
    if (!stringifiedTsconfigs[opts.tsconfig]) {
      stringifiedTsconfigs[opts.tsconfig] = tsconfig = JSON.stringify({
        ...opts.tsconfig,
        compilerOptions: typings,
      });
    } else {
      tsconfig = stringifiedTsconfigs[opts.tsconfig];
    }
  } else if (opts.typescript || opts.tsconfig) {
    enableTypings = true;
    typings = baseTypings;
    if (!stringifiedTsconfigs[baseTypings]) {
      stringifiedTsconfigs[baseTypings] = tsconfig = JSON.stringify({
        compilerOptions: typings,
      });
    } else {
      tsconfig = stringifiedTsconfigs[baseTypings];
    }
  } else {
    enableTypings = false;
  }

  let esbuildInput = {
    ..._esbuildInput,
    format: "cjs",
  };
  let emptyHandler;

  switch (mode) {
    case modes.full: {
      esbuildInput.entryPoints = [resourcePath];
      esbuildInput.outfile = resourcePath + ".js";

      // console.log("[Processing]", resourcePath, "as", mode);

      // esbuildInput.outdir = path.dirname(resourcePath);
      // esbuildInput = resourcePath + ".js",
      break;
    }
    case modes.light: {
      let ast = buildAST(_code);
      // console.log(!ast || ast.buildNodeCount === 0, "SKIP?");
      if (!ast || ast.buildNodeCount === 0) {
        return _code;
      }

      emptyHandler = () => callback(null, _code);
      esbuildInput.stdin = {
        contents: transformAST(ast, _code),

        // These are all optional:
        resolveDir: path.dirname(resourcePath),
        sourcefile: path.basename(resourcePath) + ".js",
        loader: fileExtension.includes("ts") ? "tsx" : "jsx",
      };
      esbuildInput.outfile = resourcePath + ".js";
      // console.log(
      //   "[Processing]",
      //   resourcePath,
      //   "as",
      //   mode,
      //   esbuildInput.stdin.contents
      // );

      if (
        !(esbuildInput.stdin.contents && esbuildInput.stdin.contents.length)
      ) {
        return _code;
      }
      esbuildInput.stdin.contents = esbuildInput.stdin.contents.replace(
        "module.namespaceCollisionHack",
        ""
      );
      break;
    }
  }

  readCompilationFs = readFile;

  const callback = getCallback();
  const result = runBuild(
    esbuildInput,
    callback,
    esbuildInput.outfile,
    addDependency,
    enableTypings ? typings : null,
    tsconfig,
    outputFormat,
    writeFile,
    emptyHandler
  );

  return result;
}

export default function loader(_code) {
  if (this.getOptions) {
    opts = this.getOptions(schema);
  } else {
    opts = getOptions(this);
  }

  const result = runWithOptions(
    _code,
    opts,
    this.resourcePath,
    this._compilation.inputFileSystem.readFileSync,
    this.async,
    this.addDependency,
    opts.format || "esm",
    opts.writeFile || writeFile
  );

  if (typeof result === "object" && result.then) {
    return;
  }

  return result;
}
