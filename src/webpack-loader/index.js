import { AtBuild, requireFromString } from "../atbuild";
import {
  build as _build,
  transform as _transform,
  transformSync,
  startService,
} from "esbuild";
import path from "path";
import esbuildPlugin from "../esbuildPlugin/fullPlugin";
import lightEsbuildPlugin from "../esbuildPlugin/lightPlugin";
import fs from "fs";
import {
  baseTypings,
  generateTypings,
} from "../typings-plugin/generateTypings";
import { getOptions } from "loader-utils";
import { quickTest } from "../light";
import { transformAST, buildAST } from "../light";

let service;
let runCount = 0;

let build = _build;
let transform = _transform;

const schema = {
  type: "object",
  properties: {
    typescript: {
      type: "boolean",
    },
    tsconfig: {
      type: "object",
      additionalProperties: true,
    },
    jsExtensions: {
      type: "array",
      items: [
        {
          type: "string",
        },
      ],
      additionalItems: true,
    },
    atBuildExtensions: {
      type: "array",
      items: [
        {
          type: "string",
        },
      ],
      additionalItems: true,
    },
  },
  additionalProperties: true,
};

let _esbuildInput = {
  format: "cjs",
  target: [`node${process.versions.node.split(".")[0]}`],
  outfile: "out.js",
  metafile: "meta.json",
  sourcemap: "inline",
  platform: "node",
  resolveExtensions: [".ts", ".js", ".tsx", ".jsx", ".jsb", ".@js", ".atbuild"],
  bundle: true,
  write: false,
  plugins: [esbuildPlugin, lightEsbuildPlugin],
};

const stringifiedTsconfigs = {};

let textDecoder = new TextDecoder("utf-8");

let temporaryCodeMap = new Map();
let readCompilationFs;

function readTemporaryAsset(name) {
  if (temporaryCodeMap.has(name)) {
    return temporaryCodeMap.get(name);
  } else if (readCompilationFs) {
    return readCompilationFs(name, "utf8");
  }
}

async function runBuild(
  esbuildInput,
  callback,
  resourcePath,
  addDependency,
  typings,
  tsconfig,
  outputFormat,
  writeFile
) {
  if (runCount > 0 && !service) {
    service = await startService({
      worker: true,
    });

    build = service.build;
    transform = service.transform;

    process.on("beforeExit", () => {
      if (service) {
        service.stop();
      }
    });

    process.on("SIGABRT", () => {
      if (service) {
        service.stop();
      }
    });
  }

  return build(esbuildInput).then(
    (res) =>
      handleESBuildResult(
        res,
        esbuildInput.outfile,
        callback,
        resourcePath,
        addDependency,
        resourcePath,
        typings,
        tsconfig,
        outputFormat,
        writeFile
      ),
    (err) => {
      console.error(err);
      debugger;

      callback(err);
    }
  );
}

function formatContent(content) {
  return (
    `// 
//                          Auto-generated by AtBuild
//                               at ${Date.now()}
// 

` + content
  );
}

async function writeFile(name, content) {
  const outExt = path.extname(name.replace(".d.ts", ""));
  const outName = name.replace(outExt, "");

  temporaryCodeMap.delete(name);

  if (outExt.length === 0) {
    return;
  } else if (content) {
    fs.promises.writeFile(outName, formatContent(content), "utf-8");
  } else if (fs.existsSync(name)) {
    fs.promises.writeFile(outName, "", "utf-8");
  }
}
export async function emitTypeDeclarationFile(
  resourcePath,
  code,
  typings,
  writeFile
) {
  temporaryCodeMap.set(resourcePath + ".ts", code);
  generateTypings(
    [resourcePath + ".ts"],
    typings,
    readTemporaryAsset,
    writeFile
  );
}

export async function handleESBuildResult(
  { outputFiles, warnings },
  input,
  callback,
  resourcePath,
  addDependency,
  ignoreDependency,
  typings,
  tsconfig,
  outputFormat = "esm",
  writeFile
) {
  let source, meta;
  for (let outputFile of outputFiles) {
    if (outputFile.path.endsWith(input)) {
      source = textDecoder.decode(outputFile.contents);
    } else if (outputFile.path.endsWith("meta.json")) {
      meta = JSON.parse(textDecoder.decode(outputFile.contents));
    }
  }

  for (let key in meta.inputs) {
    if (key !== ignoreDependency) {
      addDependency(key);
    }
  }

  let code;

  try {
    code = requireFromString(source, input).default;
  } catch (exception) {
    callback(exception);
    return;
  }

  if (typings) {
    emitTypeDeclarationFile(resourcePath, code, typings, writeFile);
    let result;

    try {
      result = await transform(code, {
        loader: "tsx",
        format: outputFormat,
        sourcefile: resourcePath + ".tsx",
        sourcemap: false,
      });
    } catch (exception) {
      callback(exception);
      return;
    }

    code = result.code;

    if (process.env.WRITE_ATBUILD_TO_DISK) {
      await fs.promises.writeFile(
        resourcePath.replace(
          path.extname(resourcePath),
          typings ? ".out.ts" : "out.js"
        ),
        code
      );
    }

    callback(null, code, {
      version: "3",
      sources: [resourcePath],
      file: resourcePath,
      sourcesContent: [],
      mappings: "",
    });
  } else {
    if (process.env.WRITE_ATBUILD_TO_DISK) {
      await fs.promises.writeFile(
        resourcePath.replace(
          path.extname(resourcePath),
          typings ? ".out.ts" : "out.js"
        ),
        code
      );
    }

    callback(null, code, {
      version: "3",
      sources: [resourcePath],
      file: resourcePath,
      sourcesContent: [],
      mappings: "",
    });
  }
}

let typings = null,
  tsconfig = null,
  enableTypings = false,
  fileExtension = "",
  opts;

let optionsGetter = getOptions;
const modes = {
  light: 0,
  full: 1,
};

const extensionForMode = [".atbuild", ""];

const DEFAULT_JS_EXTENSIONS = [".js", ".ts", ".jsx", ".tsx"];
const DEFAULT_ATBUILD_EXTENSIONS = [".jsb", ".@js"];

export function runWithOptions(
  _code,
  opts,
  resourcePath,
  readFile,
  getCallback,
  addDependency,
  outputFormat,
  writeFile,
  _mode = "auto"
) {
  let mode = _mode;
  let jsExtensions = opts.jsExtensions || DEFAULT_JS_EXTENSIONS;
  let atBuildExtensions = opts.atBuildExtensions || DEFAULT_ATBUILD_EXTENSIONS;
  fileExtension = path.extname(resourcePath);

  switch (mode) {
    case "light": {
      if (quickTest(_code)) {
        mode = modes.light;
      } else {
        return _code;
      }
      break;
    }

    case "full": {
      mode = modes.full;
      break;
    }

    default:
    case "auto": {
      if (
        fileExtension.length &&
        jsExtensions.includes(fileExtension) &&
        quickTest(_code)
      ) {
        mode = modes.light;
      } else if (
        fileExtension.length &&
        atBuildExtensions.includes(fileExtension)
      ) {
        mode = modes.full;
      } else {
        return _code;
      }
      break;
    }
  }

  if (typeof opts.tsconfig === "object") {
    typings = { ...opts.tsconfig.compilerOptions, ...baseTypings };

    enableTypings = true;
    delete typings.moduleResolution;
    if (!stringifiedTsconfigs[opts.tsconfig]) {
      stringifiedTsconfigs[opts.tsconfig] = tsconfig = JSON.stringify({
        ...opts.tsconfig,
        compilerOptions: typings,
      });
    } else {
      tsconfig = stringifiedTsconfigs[opts.tsconfig];
    }
  } else if (opts.typescript || opts.tsconfig) {
    enableTypings = true;
    typings = baseTypings;
    if (!stringifiedTsconfigs[baseTypings]) {
      stringifiedTsconfigs[baseTypings] = tsconfig = JSON.stringify({
        compilerOptions: typings,
      });
    } else {
      tsconfig = stringifiedTsconfigs[baseTypings];
    }
  } else {
    enableTypings = false;
  }

  let esbuildInput = {
    ..._esbuildInput,
    format: "cjs",
  };

  switch (mode) {
    case modes.full: {
      esbuildInput.entryPoints = [resourcePath];
      // esbuildInput.outdir = path.dirname(resourcePath);
      // esbuildInput = resourcePath + ".js",
      break;
    }
    case modes.light: {
      esbuildInput.stdin = {
        contents: transformAST(buildAST(_code), _code),

        // These are all optional:
        resolveDir: path.dirname(resourcePath),
        sourcefile: path.basename(resourcePath) + ".js",
        loader: "js",
      };
      esbuildInput.outfile = resourcePath + ".js";

      if (
        !(esbuildInput.stdin.contents && esbuildInput.stdin.contents.length)
      ) {
        return _code;
      }
      esbuildInput.stdin.contents = esbuildInput.stdin.contents.replace(
        "module.namespaceCollisionHack",
        ""
      );
      break;
    }
  }

  readCompilationFs = readFile;

  const callback = getCallback();
  const result = runBuild(
    esbuildInput,
    callback,
    resourcePath,
    addDependency,
    enableTypings ? typings : null,
    tsconfig,
    outputFormat,
    writeFile
  );

  return result;
}

export default function loader(_code) {
  if (this.getOptions) {
    optionsGetter = this.getOptions;
  }

  opts = optionsGetter(schema);

  const result = runWithOptions(
    _code,
    opts,
    this.resourcePath,
    this._compilation.inputFileSystem.readFileSync,
    this.async,
    this.addDependency,
    opts.format || "esm",
    opts.writeFile || writeFile
  );

  if (typeof result === "object" && result.then) {
    return;
  }

  return result;
}
