{
  "version": 3,
  "sources": ["../src/light/utils.ts", "../src/light.ts"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, {get: all[name], enumerable: true});\n};\n__export(exports, {\n  CHARACTER_TYPES: () => CHARACTER_TYPES,\n  CharacterType: () => CharacterType\n});\nvar CharacterType;\n(function(CharacterType2) {\n  CharacterType2[CharacterType2[\"expressionStart\"] = 1] = \"expressionStart\";\n  CharacterType2[CharacterType2[\"alphanumeric\"] = 2] = \"alphanumeric\";\n  CharacterType2[CharacterType2[\"isOpeningParenthese\"] = 3] = \"isOpeningParenthese\";\n  CharacterType2[CharacterType2[\"isClosingParenthese\"] = 4] = \"isClosingParenthese\";\n  CharacterType2[CharacterType2[\"other\"] = 0] = \"other\";\n})(CharacterType || (CharacterType = {}));\nconst CHARACTER_TYPES = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n", "import { CharacterType, CHARACTER_TYPES } from \"./light/utils\";\n\nconst RUNTIME_MATCHER = /(^|\\W|\"|'|;)(\\$\\w*)?\\(((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\))/g;\nconst BUILD_TIME_LINE_MATCHER = /\\/\\/\\s*\\$\\s*(ATBUILD)?/;\nconst MULTILINE_BUILD_TIME_MATCHER = /^\\s*\\/\\/\\s*((\\$\\$)|(ATBUILD))\\s*?/;\n\nconst RUNTIME_MATCHER_TEST_ONLY = new RegExp(RUNTIME_MATCHER);\nconst BUILD_TIME_LINE_MATCHER_TEST_ONLY = new RegExp(BUILD_TIME_LINE_MATCHER);\nconst MULTILINE_BUILD_TIME_MATCHER_TEST_ONLY = new RegExp(\n  MULTILINE_BUILD_TIME_MATCHER\n);\n\nenum RuntimeCursorState {\n  findStart = 0,\n  findClosingParenthese = 1,\n  findOpeningParenthese = 2,\n}\n\nexport enum ASTNodeType {\n  runtimeLineStart = 0,\n  runtimeLineEnd = 1,\n  buildTimeCode = 2,\n  runtimeCode = 3,\n  buildTimeLine = 4,\n  multilineBuildTimeLine = 5,\n  runtimeLine = 6,\n}\n\nexport type ASTNode = {\n  type: ASTNodeType;\n  value: string;\n  line: number;\n};\n\nconst astNodeBase: ASTNode = {\n  type: ASTNodeType.buildTimeCode,\n  value: \"\",\n  line: 0,\n};\n\nexport class ASTNodeList extends Array<ASTNode> {\n  buildNodeCount = 0;\n  runtimeLineCount = 0;\n  maxLine = 0;\n}\n\nexport function quickTest(source: string) {\n  return source.includes(\"$\");\n}\n\nexport function buildAST(source: string, emptyFunctionNameReplacer = \"\") {\n  const nodes = new ASTNodeList();\n\n  let lines = String(source).split(\"\\n\");\n  let isMultiline = false,\n    result = null,\n    lineToMatch: string = \"\",\n    offset = 0,\n    funcArgs = \"\",\n    interpolatedCodeNode: ASTNode,\n    runtimeLineStartNode: ASTNode = null,\n    index = 0,\n    runtimeCodeNode: ASTNode = null,\n    runtimeCodeLineEndNode: ASTNode = null,\n    remainderRunTimeCodeNode: ASTNode = null,\n    runtimeLine: ASTNode = null,\n    hasBuildTimeNode = false,\n    node: ASTNode = astNodeBase,\n    linePosition = 0;\n  let i = 0;\n  for (i = 0; i < lines.length; i++) {\n    if (lines[i].trim().length === 0) {\n      continue;\n    }\n\n    if (MULTILINE_BUILD_TIME_MATCHER_TEST_ONLY.test(lines[i])) {\n      isMultiline = !isMultiline;\n\n      node = Object.create(astNodeBase);\n\n      node.type = ASTNodeType.multilineBuildTimeLine;\n      node.value = lines[i];\n      node.line = i;\n\n      nodes.push(node);\n      nodes.buildNodeCount++;\n    } else if (isMultiline) {\n      node = Object.create(astNodeBase);\n\n      node.type = ASTNodeType.multilineBuildTimeLine;\n      nodes.buildNodeCount++;\n      node.value = lines[i];\n      node.line = i;\n\n      nodes.push(node);\n    } else if (BUILD_TIME_LINE_MATCHER_TEST_ONLY.test(lines[i])) {\n      node = Object.create(astNodeBase);\n\n      node.type = ASTNodeType.buildTimeLine;\n      nodes.buildNodeCount++;\n      node.value = lines[i];\n      node.line = i;\n      nodes.push(node);\n    } else {\n      hasBuildTimeNode = false;\n      runtimeCodeNode = Object.create(astNodeBase);\n\n      runtimeCodeNode.type = ASTNodeType.runtimeLine;\n      runtimeCodeNode.value = lines[i];\n      runtimeCodeNode.line = i;\n\n      offset = 0;\n      nodes.runtimeLineCount++;\n      lineToMatch = lines[i];\n\n      // This is a handrolled, non ECMAScript compliant JavaScript Function Call Detector\u2122\n      // It should detect function calls like so\n      // - $(\"anything-in-here should run in the build script!\")\n      // - $FooFunction()\n      // - $FooFunction(\"\")\n      // - $FooFunction(\"\", \"\")\n      // - $BarFunction(\"\", \"\") $FooFunction(\"\", \"\")\n      // - \"runtimeCode\" $BarFunction(\"\", \"\") \"runtimeCode\" $FooFunction(\"\", \"\") \"runtimeCode\"\n\n      // It should not detect things like:\n      // - if (bacon) {}\n      // - if(bacon) {}\n      // - while(!bacon) {}\n      // function bacon() {}\n\n      // It does not need to care about nested function calls so long as it knows where the last closing parentheses is.\n\n      // The algorithm is as follows:\n      // 1. Find a $\n      // 2. Go forward until we reach either:\n      //    - An opening parenthese\n      //      - Indices from start of $ to position is the function name\n      //    - A space, subtraction, addition, var, //, or semicolon\n      //     - Reset depth\n      //      - Goto 1.\n      // 3. Go forward until we reach a closing parenthese matching depth\n      //    - If we reach an opening parenthese, increment depth.\n      //    - If we reach a closing parenthese prior to correct depth, decrement depth and continue.\n      //    - Once reached, goto 1\n\n      let depth = 0,\n        characterType = 0,\n        state: RuntimeCursorState = RuntimeCursorState.findStart,\n        expressionStartPosition = 0,\n        lineNodePosition = Math.max(nodes.length - 1, 0),\n        lineNodeOffset = 0,\n        isFirstInsert = true,\n        needsEmptyFunctionReplacer = 0;\n      for (\n        linePosition = 0;\n        linePosition < lineToMatch.length;\n        linePosition++\n      ) {\n        characterType =\n          CHARACTER_TYPES[lineToMatch.charCodeAt(linePosition)] | 0;\n\n        //\n        if (\n          characterType === CharacterType.expressionStart &&\n          state === RuntimeCursorState.findStart\n        ) {\n          depth = 0;\n          expressionStartPosition = linePosition;\n          state = RuntimeCursorState.findOpeningParenthese;\n\n          // Full match found\n          // The happy state.\n        } else if (\n          characterType === CharacterType.isClosingParenthese &&\n          state === RuntimeCursorState.findClosingParenthese &&\n          depth === 0\n        ) {\n          if (isFirstInsert) {\n            let _runtimeCodeNode = runtimeCodeNode;\n            _runtimeCodeNode.type = ASTNodeType.runtimeLineStart;\n            _runtimeCodeNode.value = \"\";\n\n            runtimeCodeNode = Object.create(astNodeBase);\n            runtimeCodeNode.type = ASTNodeType.runtimeCode;\n            runtimeCodeNode.value = lines[i];\n            _runtimeCodeNode.line = runtimeCodeNode.line = i;\n\n            nodes.push(_runtimeCodeNode, runtimeCodeNode);\n            lineNodePosition = nodes.length - 1;\n            isFirstInsert = false;\n          }\n\n          nodes[lineNodePosition].value = nodes[\n            lineNodePosition\n          ].value.substring(0, expressionStartPosition - lineNodeOffset);\n\n          node = Object.create(astNodeBase);\n          node.type = ASTNodeType.buildTimeCode;\n          node.value =\n            emptyFunctionNameReplacer +\n            lineToMatch.substring(\n              expressionStartPosition + needsEmptyFunctionReplacer,\n              (lineNodeOffset = linePosition + 1)\n            );\n\n          runtimeCodeNode = Object.create(astNodeBase);\n          runtimeCodeNode.type = ASTNodeType.runtimeCode;\n          runtimeCodeNode.value = lineToMatch.substring(\n            lineNodeOffset,\n            lineToMatch.length\n          );\n\n          runtimeCodeNode.line = node.line = i;\n\n          nodes.push(node, runtimeCodeNode);\n          lineNodePosition += 2;\n          state = expressionStartPosition = depth = 0;\n\n          nodes.buildNodeCount++;\n        } else if (\n          characterType === CharacterType.isClosingParenthese &&\n          state === RuntimeCursorState.findClosingParenthese &&\n          depth !== 0\n        ) {\n          depth--;\n        } else if (\n          characterType === CharacterType.isOpeningParenthese &&\n          state === RuntimeCursorState.findClosingParenthese\n        ) {\n          depth++;\n\n          // it matches $Foo( or $(\n        } else if (\n          characterType === CharacterType.isOpeningParenthese &&\n          state === RuntimeCursorState.findOpeningParenthese &&\n          depth === 0\n        ) {\n          state = RuntimeCursorState.findClosingParenthese;\n          needsEmptyFunctionReplacer =\n            expressionStartPosition + 1 === linePosition ? 1 : 0;\n          // Reset back to findStart. This is a space or delimiter of some kind.\n        } else if (\n          state === RuntimeCursorState.findOpeningParenthese &&\n          characterType === CharacterType.other\n        ) {\n          state = RuntimeCursorState.findStart;\n          depth = expressionStartPosition = 0;\n        }\n      }\n\n      if (!isFirstInsert) {\n        runtimeCodeLineEndNode = Object.create(astNodeBase);\n\n        runtimeCodeLineEndNode.line = i;\n        runtimeCodeLineEndNode.type = ASTNodeType.runtimeLineEnd;\n\n        nodes.push(runtimeCodeLineEndNode);\n      }\n    }\n  }\n  nodes.maxLine = i;\n  return nodes;\n}\n\nexport function transformAST(nodes: ASTNodeList) {\n  let code = \"var __CODE__ = [];\\n\\n\";\n  const maxLineNumber = nodes.maxLine;\n  let lines = new Array(maxLineNumber + 3);\n  lines.fill(\"\");\n\n  for (let node of nodes) {\n    switch (node.type) {\n      case ASTNodeType.buildTimeLine:\n        lines[node.line] += node.value + \"\\n\";\n        break;\n\n      case ASTNodeType.multilineBuildTimeLine: {\n        lines[node.line] += node.value + \"\\n\\n\";\n        break;\n      }\n\n      case ASTNodeType.buildTimeCode: {\n        lines[node.line] += \"${\" + node.value + \"}\";\n        break;\n      }\n      case ASTNodeType.runtimeCode: {\n        // prettier-ignore\n        lines[node.line] += node.value\n        break;\n      }\n\n      case ASTNodeType.runtimeLineStart: {\n        lines[node.line] += \"__CODE__.push(`\";\n        break;\n      }\n\n      case ASTNodeType.runtimeLineEnd: {\n        lines[node.line] += \"`);\\n\\n\";\n        break;\n      }\n      case ASTNodeType.runtimeLine: {\n        lines[node.line] += \"__CODE__.push(`\" + node.value + \"`);\\n\\n\";\n        break;\n      }\n    }\n  }\n  lines.unshift(code);\n\n  lines[lines.length - 1] = `module.exports.default = __CODE__.join(\"\");`;\n\n  return lines.join(\"\");\n}\n\nexport function transform(source: string) {\n  const nodes = buildAST(source);\n\n  if (nodes.buildNodeCount > 0) {\n    return transformAST(nodes);\n  } else {\n    return null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
