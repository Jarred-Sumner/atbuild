{
  "version": 3,
  "sources": ["../src/light/utils.ts", "../src/light.ts"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, {get: all[name], enumerable: true});\n};\n__export(exports, {\n  CHARACTER_TYPES: () => CHARACTER_TYPES,\n  CharacterType: () => CharacterType\n});\nvar CharacterType;\n(function(CharacterType2) {\n  CharacterType2[CharacterType2[\"expressionStart\"] = 1] = \"expressionStart\";\n  CharacterType2[CharacterType2[\"alphanumeric\"] = 2] = \"alphanumeric\";\n  CharacterType2[CharacterType2[\"isOpeningParenthese\"] = 3] = \"isOpeningParenthese\";\n  CharacterType2[CharacterType2[\"isClosingParenthese\"] = 4] = \"isClosingParenthese\";\n  CharacterType2[CharacterType2[\"other\"] = 0] = \"other\";\n})(CharacterType || (CharacterType = {}));\nconst CHARACTER_TYPES = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n", "import { CharacterType, CHARACTER_TYPES } from \"./light/utils\";\n\nconst RUNTIME_MATCHER = /(^|\\W|\"|'|;)(\\$\\w*)?\\(((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\))/g;\nconst BUILD_TIME_LINE_MATCHER = /\\/\\/\\s*\\$\\s*(ATBUILD)?/;\nconst MULTILINE_BUILD_TIME_MATCHER = /^\\s*\\/\\/\\s*((\\$\\$)|(ATBUILD))\\s*?/;\n\nconst RUNTIME_MATCHER_TEST_ONLY = new RegExp(RUNTIME_MATCHER);\nconst BUILD_TIME_LINE_MATCHER_TEST_ONLY = new RegExp(BUILD_TIME_LINE_MATCHER);\nconst MULTILINE_BUILD_TIME_MATCHER_TEST_ONLY = new RegExp(\n  MULTILINE_BUILD_TIME_MATCHER\n);\n\nconst IGNORE_FILE_STRING = \"// atbuild-ignore-file\";\n\nenum RuntimeCursorState {\n  findStart = 0,\n  findClosingParenthese = 1,\n  findOpeningParenthese = 2,\n}\n\nexport enum ASTNodeType {\n  runtimeLineStart = 0,\n  runtimeLineEnd = 1,\n  buildTimeCode = 2,\n  runtimeCode = 3,\n  buildTimeLine = 4,\n  multilineBuildTimeLine = 5,\n  runtimeLine = 6,\n}\n\nexport type ASTNode = {\n  type: ASTNodeType;\n  value: string;\n  line: number;\n};\n\nconst astNodeBase: ASTNode = {\n  type: ASTNodeType.buildTimeCode,\n  value: \"\",\n  line: 0,\n};\n\nexport class ASTNodeList extends Array<ASTNode> {\n  buildNodeCount = 0;\n  runtimeLineCount = 0;\n  maxLine = 0;\n}\n\nexport function quickTest(source: string) {\n  return source.includes(\"$\") && !source.startsWith(IGNORE_FILE_STRING);\n}\n\nexport function buildAST(source: string, emptyFunctionNameReplacer = \"\") {\n  const nodes = new ASTNodeList();\n\n  let lines = String(source).split(\"\\n\");\n  let isMultiline = false,\n    result = null,\n    lineToMatch: string = \"\",\n    offset = 0,\n    funcArgs = \"\",\n    interpolatedCodeNode: ASTNode,\n    runtimeLineStartNode: ASTNode = null,\n    index = 0,\n    runtimeCodeNode: ASTNode = null,\n    runtimeCodeLineEndNode: ASTNode = null,\n    remainderRunTimeCodeNode: ASTNode = null,\n    runtimeLine: ASTNode = null,\n    hasBuildTimeNode = false,\n    node: ASTNode = astNodeBase,\n    linePosition = 0;\n  let i = 0;\n  if (!source.startsWith(IGNORE_FILE_STRING)) {\n    for (i = 0; i < lines.length; i++) {\n      if (lines[i].trim().length === 0) {\n        continue;\n      }\n\n      if (MULTILINE_BUILD_TIME_MATCHER_TEST_ONLY.test(lines[i])) {\n        isMultiline = !isMultiline;\n\n        node = Object.create(astNodeBase);\n\n        node.type = ASTNodeType.multilineBuildTimeLine;\n        node.value = lines[i];\n        node.line = i;\n\n        nodes.push(node);\n        nodes.buildNodeCount++;\n      } else if (isMultiline) {\n        node = Object.create(astNodeBase);\n\n        node.type = ASTNodeType.multilineBuildTimeLine;\n        nodes.buildNodeCount++;\n        node.value = lines[i];\n        node.line = i;\n\n        nodes.push(node);\n      } else if (BUILD_TIME_LINE_MATCHER_TEST_ONLY.test(lines[i])) {\n        node = Object.create(astNodeBase);\n\n        node.type = ASTNodeType.buildTimeLine;\n        nodes.buildNodeCount++;\n        node.value = lines[i];\n        node.line = i;\n        nodes.push(node);\n      } else {\n        hasBuildTimeNode = false;\n        runtimeCodeNode = Object.create(astNodeBase);\n\n        runtimeCodeNode.type = ASTNodeType.runtimeLine;\n        runtimeCodeNode.value = lines[i];\n        runtimeCodeNode.line = i;\n\n        offset = 0;\n        nodes.runtimeLineCount++;\n        lineToMatch = lines[i];\n\n        // This is a handrolled, non ECMAScript compliant JavaScript Function Call Detector\u2122\n        // It should detect function calls like so\n        // - $(\"anything-in-here should run in the build script!\")\n        // - $FooFunction()\n        // - $FooFunction(\"\")\n        // - $FooFunction(\"\", \"\")\n        // - $BarFunction(\"\", \"\") $FooFunction(\"\", \"\")\n        // - \"runtimeCode\" $BarFunction(\"\", \"\") \"runtimeCode\" $FooFunction(\"\", \"\") \"runtimeCode\"\n\n        // It should not detect things like:\n        // - if (bacon) {}\n        // - if(bacon) {}\n        // - while(!bacon) {}\n        // function bacon() {}\n\n        // It does not need to care about nested function calls so long as it knows where the last closing parentheses is.\n\n        // The algorithm is as follows:\n        // 1. Find a $\n        // 2. Go forward until we reach either:\n        //    - An opening parenthese\n        //      - Indices from start of $ to position is the function name\n        //    - A space, subtraction, addition, var, //, or semicolon\n        //     - Reset depth\n        //      - Goto 1.\n        // 3. Go forward until we reach a closing parenthese matching depth\n        //    - If we reach an opening parenthese, increment depth.\n        //    - If we reach a closing parenthese prior to correct depth, decrement depth and continue.\n        //    - Once reached, goto 1\n\n        let depth = 0,\n          characterType = 0,\n          state: RuntimeCursorState = RuntimeCursorState.findStart,\n          expressionStartPosition = 0,\n          lineNodePosition = Math.max(nodes.length - 1, 0),\n          lineNodeOffset = 0,\n          isFirstInsert = true,\n          needsEmptyFunctionReplacer = 0;\n\n        for (\n          linePosition = 0;\n          linePosition < lineToMatch.length;\n          linePosition++\n        ) {\n          characterType =\n            CHARACTER_TYPES[lineToMatch.charCodeAt(linePosition)] | 0;\n\n          //\n          if (\n            characterType === CharacterType.expressionStart &&\n            state === RuntimeCursorState.findStart\n          ) {\n            depth = 0;\n            expressionStartPosition = linePosition;\n            state = RuntimeCursorState.findOpeningParenthese;\n\n            // Full match found\n            // The happy state.\n          } else if (\n            characterType === CharacterType.isClosingParenthese &&\n            state === RuntimeCursorState.findClosingParenthese &&\n            depth === 0\n          ) {\n            if (isFirstInsert) {\n              let _runtimeCodeNode = runtimeCodeNode;\n              _runtimeCodeNode.type = ASTNodeType.runtimeLineStart;\n              _runtimeCodeNode.value = \"\";\n\n              runtimeCodeNode = Object.create(astNodeBase);\n              runtimeCodeNode.type = ASTNodeType.runtimeCode;\n              runtimeCodeNode.value = lines[i];\n              _runtimeCodeNode.line = runtimeCodeNode.line = i;\n\n              nodes.push(_runtimeCodeNode, runtimeCodeNode);\n              lineNodePosition = nodes.length - 1;\n              isFirstInsert = false;\n            }\n\n            nodes[lineNodePosition].value = nodes[\n              lineNodePosition\n            ].value.substring(0, expressionStartPosition - lineNodeOffset);\n\n            node = Object.create(astNodeBase);\n            node.type = ASTNodeType.buildTimeCode;\n            node.value =\n              emptyFunctionNameReplacer +\n              lineToMatch.substring(\n                expressionStartPosition + needsEmptyFunctionReplacer,\n                (lineNodeOffset = linePosition + 1)\n              );\n\n            runtimeCodeNode = Object.create(astNodeBase);\n            runtimeCodeNode.type = ASTNodeType.runtimeCode;\n            runtimeCodeNode.value = lineToMatch.substring(\n              lineNodeOffset,\n              lineToMatch.length\n            );\n\n            runtimeCodeNode.line = node.line = i;\n\n            nodes.push(node, runtimeCodeNode);\n            lineNodePosition += 2;\n            state = expressionStartPosition = depth = 0;\n\n            nodes.buildNodeCount++;\n          } else if (\n            characterType === CharacterType.isClosingParenthese &&\n            state === RuntimeCursorState.findClosingParenthese &&\n            depth !== 0\n          ) {\n            depth--;\n          } else if (\n            characterType === CharacterType.isOpeningParenthese &&\n            state === RuntimeCursorState.findClosingParenthese\n          ) {\n            depth++;\n\n            // it matches $Foo( or $(\n          } else if (\n            characterType === CharacterType.isOpeningParenthese &&\n            state === RuntimeCursorState.findOpeningParenthese &&\n            depth === 0\n          ) {\n            state = RuntimeCursorState.findClosingParenthese;\n            needsEmptyFunctionReplacer =\n              expressionStartPosition + 1 === linePosition ? 1 : 0;\n            // Reset back to findStart. This is a space or delimiter of some kind.\n          } else if (\n            state === RuntimeCursorState.findOpeningParenthese &&\n            characterType === CharacterType.other\n          ) {\n            state = RuntimeCursorState.findStart;\n            depth = expressionStartPosition = 0;\n          }\n        }\n\n        if (!isFirstInsert) {\n          runtimeCodeLineEndNode = Object.create(astNodeBase);\n\n          runtimeCodeLineEndNode.line = i;\n          runtimeCodeLineEndNode.type = ASTNodeType.runtimeLineEnd;\n\n          nodes.push(runtimeCodeLineEndNode);\n        } else {\n          nodes.push(runtimeCodeNode);\n        }\n      }\n    }\n  }\n  nodes.maxLine = i;\n  return nodes;\n}\n\nexport function transformAST(nodes: ASTNodeList) {\n  let code = \"var __CODE__ = '';\\n\\n\";\n  const maxLineNumber = nodes.maxLine;\n  let lines = new Array(maxLineNumber + 3);\n  lines.fill(\"\");\n\n  for (let node of nodes) {\n    switch (node.type) {\n      case ASTNodeType.buildTimeLine:\n        lines[node.line] += node.value + \"\\n\";\n        break;\n\n      case ASTNodeType.multilineBuildTimeLine: {\n        lines[node.line] += node.value + \"\\n\\n\";\n        break;\n      }\n\n      case ASTNodeType.buildTimeCode: {\n        lines[node.line] += \"${\" + node.value.replace(/`/gm, \"\\\\`\") + \"}\";\n        break;\n      }\n      case ASTNodeType.runtimeCode: {\n        // prettier-ignore\n        lines[node.line] += node.value.replace(/`/gm, \"\\\\`\").replace(/\\$\\{/gm, \"\\\\${\")\n        break;\n      }\n\n      case ASTNodeType.runtimeLineStart: {\n        lines[node.line] += \"__CODE__ += (`\";\n        break;\n      }\n\n      case ASTNodeType.runtimeLineEnd: {\n        lines[node.line] += \"`);\\n\\n\";\n        break;\n      }\n      case ASTNodeType.runtimeLine: {\n        lines[node.line] +=\n          \"__CODE__ += (`\" +\n          node.value.replace(/`/gm, \"\\\\`\").replace(/\\$\\{/gm, \"\\\\${\") +\n          \"`);\\n\\n\";\n        break;\n      }\n    }\n  }\n  lines.unshift(code);\n\n  lines[\n    lines.length - 1\n  ] = `module.exports.default = __CODE__;\\n__CODE__ = \"\";`;\n  return lines.join(\"\");\n}\n\nexport function transform(source: string) {\n  const nodes = buildAST(source);\n\n  if (nodes.buildNodeCount > 0) {\n    return transformAST(nodes);\n  } else {\n    return null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
