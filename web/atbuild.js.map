{
  "version": 3,
  "sources": ["../src/atbuild.ts", "../src/fullAst.ts", "../src/fullAst.ts"],
  "sourcesContent": ["import { buildAST, transformAST } from \"./fullAst\";\n\nlet fs;\n\nconst HEADER_STRING =\n  \"/* eslint-disable */\" +\n  \"\\n\" +\n  \"// @ts-nocheck\" +\n  \"\\n\" +\n  \"// @ts-ignore\\n\" +\n  \"// @noflow\\n\" +\n  '\"use strict\";\\n\\n';\n\nconst getMaxLine = function (currentLine, node) {\n  return Math.max(currentLine, node.lineNumber);\n};\n\nexport let requireFromString;\n\nlet bundle;\n\nif (process.env.WEB) {\n  requireFromString = (code) =>\n    eval(\n      `\n  () => {\n    var exports = {default: null};\n` +\n        code.replace(\"module.exports\", \"exports\") +\n        `\n  }()\n`\n    );\n} else {\n  requireFromString = require(\"./requireFromString\").requireFromString;\n  fs = require(\"fs\");\n}\n\nexport class AtBuild {\n  static buildAST(code: string, filename?: string) {\n    return buildAST(code, filename);\n  }\n\n  static transformAST = transformAST;\n\n  static *findNodesAtLine(nodes, lineNumber) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (node.lineNumber === lineNumber) {\n        yield node;\n      }\n    }\n  }\n\n  static ASTResponseType = {\n    BuildtimeCode: 0,\n    RuntimeCode: 1,\n  };\n\n  static evalFile(path, header) {\n    return this.eval(fs.readFileSync(path), path, header, module.parent);\n  }\n\n  static async evalFileAsync(path, header) {\n    return await this.evalAsync(\n      fs.readFileSync(path),\n      path,\n      header,\n      module.parent\n    );\n  }\n\n  static _eval(\n    code,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    let source = requireFromString(code, filepath, requireFunc);\n    if (addHeader) {\n      source = HEADER_STRING + source;\n    }\n\n    return source;\n  }\n\n  static eval(\n    code: string,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    const ast = AtBuild.buildAST(code);\n    const processed = AtBuild.transformAST(ast, code);\n    const res = this._eval(processed, filepath, addHeader, requireFunc);\n    if (res && res.default) {\n      return res.default;\n    } else {\n      return res;\n    }\n  }\n\n  static async evalAsync(\n    code: string,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    const ast = AtBuild.buildAST(code);\n    const processed = AtBuild.transformAST(ast, code);\n\n    let source = await requireFromString(processed, filepath, requireFunc);\n    if (addHeader) {\n      source = HEADER_STRING + source;\n    }\n\n    return source;\n  }\n}\n\nexport default function $(arg: any) {\n  return arg;\n}\n\nexport { buildAST, transformAST };\n", "enum CharacterType {\n  ignore = 0,\n  newline = 13, // \\n\n  whitespace = 1, //\n\n  alphanumeric = 3, // [a-zA-Z0-9]\n  control = 4, // @\n  scopeOpener = 5, // {\n  scopeCloser = 6, // }\n  variableMapOpener = 7, // <\n  variableMapCloser = 8, // >\n  variableMapSeparator = 9, // ,\n  inlineOpener = 10, // (\n  inlineCloser = 11, // )\n  escape = 12, // \\\n  replacerStart = 2, // $\n  quote = 12,\n}\n\nexport enum Scope {\n  none = 0,\n  inline = 1,\n  multiline = 2,\n}\n\nenum ParseOperation {\n  findControl = 0,\n  determineKeyword = 1,\n  determineKeywordAttribute = 2,\n  closeVariableMap = 3,\n  closeInline = 4,\n  determineReplacer = 5,\n  closeScope = 6,\n  determineName = 7,\n  closeName = 8,\n}\n\nexport enum ASTNodeKeyword {\n  source = 0,\n  run = 1,\n  build = 2,\n  export = 3,\n  inline = 4,\n  replacer = 5,\n  root = 6,\n  interpolate = 7,\n}\n\nexport interface ASTNode {\n  parent?: ASTNode;\n  children?: ASTNode[];\n  variableMapping: string[];\n  keyword: ASTNodeKeyword;\n  name?: string;\n  scope: Scope;\n  value?: string;\n  lineStart: number;\n  functionDeclarationSuffix: string;\n  lineEnd: number;\n  colStart: number;\n  colEnd: number;\n  from: number;\n  to: number;\n}\n\nlet astNodeBase: ASTNode = {\n  children: [],\n  variableMapping: [],\n  scope: Scope.none,\n  keyword: ASTNodeKeyword.source,\n  name: \"\",\n  value: \"\",\n  functionDeclarationSuffix: \"\",\n  lineStart: 0,\n  lineEnd: 0,\n  colStart: 0,\n  colEnd: 0,\n  from: 0,\n  to: 0,\n};\n\nconst ScopeNames = {\n  [Scope.inline]: \"inline\",\n  [Scope.none]: null,\n  [Scope.multiline]: \"multiline\",\n};\n\nconst KeywordName = {\n  [ASTNodeKeyword.source]: \"source\",\n  [ASTNodeKeyword.run]: \"run\",\n  [ASTNodeKeyword.build]: \"build\",\n  [ASTNodeKeyword.export]: \"export\",\n  [ASTNodeKeyword.inline]: \"inline\",\n  [ASTNodeKeyword.replacer]: \"$\",\n  [ASTNodeKeyword.root]: \"root\",\n};\n\nconst _toJSON = (item) => item.toJSON();\n\nastNodeBase.toJSON = function () {\n  const {\n    parent,\n    _parent,\n    scope,\n    keyword,\n    children,\n    colStart,\n    lineStart,\n    lineEnd,\n    colEnd,\n    ...json\n  } = this as ASTNode;\n  return {\n    ...json,\n    children: children.map(_toJSON),\n    scope: ScopeNames[scope],\n    keyword: KeywordName[keyword],\n    column: {\n      start: colStart,\n      end: colEnd,\n    },\n    line: {\n      start: lineStart,\n      end: lineEnd,\n    },\n  };\n};\n\nif (typeof WeakRef !== \"undefined\") {\n  Object.defineProperty(astNodeBase, \"parent\", {\n    get() {\n      return this._parent && this._parent.deref();\n    },\n\n    set(parent) {\n      if (parent) {\n        return (this._parent = new WeakRef(parent));\n      } else {\n        return (this._parent = null);\n      }\n    },\n  });\n}\n\nif (process.env.NODE_ENV === \"test\") {\n  Object.defineProperty(astNodeBase, \"k\", {\n    get() {\n      return ASTNodeKeyword[this.keyword];\n    },\n  });\n\n  astNodeBase.original = function (source) {\n    return source.substring(this.from, this.to);\n  };\n}\n\nconst charTypes = new Uint8Array(255);\nconst emptyCharTypes = new Uint8Array(255);\nconst incrementLineNumber = new Uint8Array(255);\n\nenum ControlIdentifier {\n  invalid = 0,\n  inline = 1,\n  export = 2,\n  build = 3,\n  run = 4,\n  closeScope = 5,\n  interpolate = 6,\n}\n\nconst Keywords = {\n  run: {\n    start: \"run\",\n    scope: true,\n    inline: true,\n    variableMapper: true,\n    name: false,\n    arguments: false,\n    prefixCode: \"r\".charCodeAt(0),\n  },\n  build: {\n    start: \"build\",\n    scope: true,\n    inline: true,\n    variableMapper: true,\n    name: false,\n    arguments: false,\n    prefixCode: \"b\".charCodeAt(0),\n  },\n  export: {\n    start: \"export\",\n    scope: true,\n    inline: false,\n    variableMapper: false,\n    name: true,\n    arguments: true,\n    prefixCode: \"e\".charCodeAt(0),\n  },\n  inline: {\n    start: \"inline\",\n    scope: false,\n    inline: true,\n    variableMapper: true,\n    name: false,\n    arguments: false,\n    prefixCode: \"i\".charCodeAt(0),\n  },\n};\n\nconst controlIdentifierTypes = new Uint8Array(255);\n\nconst controlIdentifierSkipLength = new Uint8Array(8);\nconst operationsByControlIdentifier = new Uint8Array(8);\n\nconst keywordNames = new Array(6);\n\nfunction getControlIdentifier(code: string, position: number) {\n  if (code[position + 1] === \"e\" && code[position + 2] === \"n\") {\n    return ControlIdentifier.closeScope;\n  } else {\n    return controlIdentifierTypes[code.charCodeAt(position + 1)];\n  }\n}\n\nemptyCharTypes.fill(0);\nemptyCharTypes[CharacterType.whitespace] = 1;\nemptyCharTypes[CharacterType.newline] = 1;\ncontrolIdentifierTypes[Keywords.inline.prefixCode] = ControlIdentifier.inline;\ncontrolIdentifierTypes[Keywords.run.prefixCode] = ControlIdentifier.run;\ncontrolIdentifierTypes[Keywords.build.prefixCode] = ControlIdentifier.build;\ncontrolIdentifierTypes[Keywords.export.prefixCode] = ControlIdentifier.export;\ncontrolIdentifierTypes[\"(\".charCodeAt(0)] = ControlIdentifier.interpolate;\n\ncharTypes[`\"`.charCodeAt(0)] = CharacterType.quote;\ncharTypes[`'`.charCodeAt(0)] = CharacterType.quote;\ncharTypes[\"`\".charCodeAt(0)] = CharacterType.quote;\n\ncontrolIdentifierSkipLength[ControlIdentifier.inline] = \"inline\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.run] = \"run\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.build] = \"build\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.interpolate] = \"(\".length;\ncontrolIdentifierSkipLength[\n  ControlIdentifier.export\n] = \"export function\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.closeScope] = \"end\".length;\n\nkeywordNames[ControlIdentifier.inline] = \"inline\";\nkeywordNames[ControlIdentifier.run] = \"run\";\nkeywordNames[ControlIdentifier.build] = \"build\";\nkeywordNames[ControlIdentifier.export] = \"export function\";\nkeywordNames[ControlIdentifier.closeScope] = \"end\";\nkeywordNames[ControlIdentifier.interpolate] = \"(\";\n\noperationsByControlIdentifier.fill(ParseOperation.determineKeywordAttribute);\noperationsByControlIdentifier[0] = ParseOperation.findControl;\noperationsByControlIdentifier[ControlIdentifier.export] =\n  ParseOperation.determineName;\noperationsByControlIdentifier[ControlIdentifier.interpolate] =\n  ParseOperation.closeInline;\n\nconst keywordTypes = new Uint8Array(8);\nkeywordTypes[ControlIdentifier.inline] = ASTNodeKeyword.inline;\nkeywordTypes[ControlIdentifier.run] = ASTNodeKeyword.run;\nkeywordTypes[ControlIdentifier.build] = ASTNodeKeyword.build;\nkeywordTypes[ControlIdentifier.interpolate] = ASTNodeKeyword.interpolate;\nkeywordTypes[ControlIdentifier.export] = ASTNodeKeyword.export;\n\nincrementLineNumber[CharacterType.newline] = 1;\n\nconst backtrackAmount = new Int8Array(16);\nbacktrackAmount[CharacterType.newline] = -1;\nbacktrackAmount[CharacterType.whitespace] = -1;\n\nfor (let code = 0; code < 256; code++) {\n  if ((code > 64 && code < 91) || (code > 96 && code < 123)) {\n    charTypes[code] = CharacterType.alphanumeric;\n  } else if (code === \"$\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.replacerStart;\n  } else if (code === \"\\n\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.newline;\n  } else if (code === \" \".charCodeAt(0)) {\n    charTypes[code] = CharacterType.whitespace;\n  } else if (code === \"@\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.control;\n  } else if (code === \"(\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.inlineOpener;\n  } else if (code === \")\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.inlineCloser;\n  } else if (code === \"<\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.variableMapOpener;\n  } else if (code === \",\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.variableMapSeparator;\n  } else if (code === \">\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.variableMapCloser;\n  } else {\n  }\n}\n\nenum ParseErrorType {\n  invalidKeyword = 0,\n  invalidExportFunction = 1,\n  strayOpenBrace = 2,\n}\n\nconst ParseErrorNames = {\n  [ParseErrorType.strayOpenBrace]: \"Invalid {\",\n  [ParseErrorType.invalidKeyword]: \"Invalid keyword\",\n  [ParseErrorType.invalidExportFunction]: \"Invalid export function\",\n};\n\nclass AtbuildParseError extends Error {\n  constructor(type: ParseErrorType, name: string, message: string) {\n    super(message);\n    this.name = name;\n    this.type = type;\n  }\n  type: ParseErrorType;\n}\n\nexport function buildAST(code: string, filename: string = \"file.tsb\"): ASTNode {\n  const root: ASTNode = Object.create(astNodeBase);\n  let sourceNode: ASTNode;\n  let position = 0,\n    cursor: CharacterType = CharacterType.ignore,\n    operation = ParseOperation.findControl,\n    controlIdentifierType = ControlIdentifier.invalid,\n    prevCursor: CharacterType = cursor,\n    line = 0,\n    column = 0,\n    skipLength = 0,\n    parent: ASTNode = root,\n    replacerNode: ASTNode,\n    keywordNode: ASTNode,\n    inlineDepthCount = 0,\n    scopeDepthCount = 0,\n    inlineStart = 0,\n    nameStart = 0,\n    variableMapOpenerStart = 0,\n    variableMapArgumentStart = 0,\n    lastNode: ASTNode,\n    endOfPreviousLine = 0,\n    keywordNameMatch = false,\n    endOfPreviousLineColumn = 0,\n    isLineEmpty = 1,\n    inlineEnd = 0,\n    replacerStart = 0;\n\n  // sourceNode.parent = parent;\n  root.children = [];\n  root.keyword = ASTNodeKeyword.root;\n\n  for (position = 0; position < code.length; position++, prevCursor = cursor) {\n    cursor = charTypes[code.charCodeAt(position)];\n    if (incrementLineNumber[cursor]) {\n      endOfPreviousLine = position - 1;\n      endOfPreviousLineColumn = column;\n      line++;\n      column = -1;\n      isLineEmpty = 1;\n    } else {\n    }\n\n    isLineEmpty = Math.min(isLineEmpty, emptyCharTypes[cursor]);\n\n    column++;\n\n    if (\n      operation === ParseOperation.findControl &&\n      cursor === CharacterType.control\n    ) {\n      // Look at the letter after \"@\"\n      // Is it \"r\"? Its a run keyword. \"e\"? export. etc.\n      controlIdentifierType = getControlIdentifier(code, position);\n\n      skipLength = controlIdentifierSkipLength[controlIdentifierType] | 0;\n      keywordNameMatch =\n        keywordNames[controlIdentifierType] ===\n        code.substring(position + 1, position + skipLength + 1);\n\n      // Handle scoped imports\n      // If you import \"@babylonjs\" inside a .tsb file, it would think its a control character\n      // But, its just a package name\n      // The more reliable way to do this would be running a full JS parser.\n      // But, we're not going to bother.\n      // Instead, we say\n      // Is there a quote before the control character?\n      // If so, just ignore it.\n      if (\n        (controlIdentifierType === ControlIdentifier.invalid ||\n          !keywordNameMatch) &&\n        prevCursor === CharacterType.quote\n      ) {\n        continue;\n      }\n\n      // assert its what we expect.\n      if (\n        controlIdentifierType === ControlIdentifier.invalid ||\n        !keywordNameMatch\n      ) {\n        throw new AtbuildParseError(\n          ParseErrorType.invalidKeyword,\n          `Invalid @ keyword in ${filename}:${line}:${column - 1}`,\n          `Invalid @ keyword in ${filename}:${line}:${\n            column - 1\n          }. Must be @run, @build, @export function $, @inline, @(buildCode), or @end. Received \"${code\n            .substring(position)\n            .split(\" \")[0]\n            .slice(0, 10)\n            .replace(\"\\n\", \"\\\\n\")}\"\\n`\n        );\n      } else if (controlIdentifierType === ControlIdentifier.closeScope) {\n        keywordNode.to = position;\n        keywordNode.lineEnd = line - 1;\n        keywordNode.colEnd = endOfPreviousLineColumn;\n        keywordNode.scope = Scope.multiline;\n\n        // parent.children.push(keywordNode);\n\n        if (sourceNode) {\n          sourceNode.to = parent.to = keywordNode.to;\n          sourceNode.lineEnd = parent.lineEnd = line - 1;\n          sourceNode.colEnd = parent.colEnd = endOfPreviousLineColumn;\n          sourceNode.parent = parent;\n          // sourceNode.value = code.substring(sourceNode.from, sourceNode.to);\n          if (\n            sourceNode.value.length &&\n            !keywordNode.children.includes(sourceNode)\n          ) {\n            keywordNode.children.push(sourceNode);\n          }\n          sourceNode = null;\n        }\n        keywordNode = parent || root;\n        parent = keywordNode.parent || root;\n\n        scopeDepthCount = 0;\n\n        operation = ParseOperation.findControl;\n\n        // lastNode = sourceNode = Object.create(astNodeBase);\n        // sourceNode.children = [];\n        // sourceNode.keyword = ASTNodeKeyword.source;\n        // sourceNode.from = position + 1; //+ backtrackAmount[prevCursor];\n        // sourceNode.lineStart = line;\n        // sourceNode.colStart = column;\n        // sourceNode.parent = parent;\n        // lastNode = keywordNode;\n      } else {\n        operation = operationsByControlIdentifier[controlIdentifierType];\n        if (sourceNode) {\n          sourceNode.colEnd = column;\n          sourceNode.lineEnd = line;\n          sourceNode.to = position;\n          sourceNode = null;\n          //sourceNode.value = code.substring(sourceNode.from, position);\n        }\n\n        variableMapOpenerStart = variableMapArgumentStart = inlineStart = 0;\n\n        keywordNode = Object.create(astNodeBase);\n        keywordNode.children = [];\n        keywordNode.from = position;\n        keywordNode.colStart = column;\n        keywordNode.lineStart = line;\n\n        keywordNode.keyword = keywordTypes[controlIdentifierType];\n        if (keywordNode.keyword === ASTNodeKeyword.export) {\n          keywordNode.parent = parent = root;\n        } else {\n          keywordNode.parent = parent;\n        }\n\n        if (operation === ParseOperation.closeInline) {\n          // @(bacon)\n          // ^ === position\n          //   ^ === desired position\n          inlineStart = position + 2;\n\n          sourceNode = Object.create(astNodeBase);\n          sourceNode.lineStart = line;\n          sourceNode.from = inlineStart;\n          sourceNode.parent = keywordNode;\n          sourceNode.colStart = column;\n        }\n      }\n\n      // Skip ahead\n      position += skipLength;\n\n      // @run <a\n      //      ^ cursor is here\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.variableMapOpener\n    ) {\n      variableMapOpenerStart = position;\n      variableMapArgumentStart = position + 1;\n      operation = ParseOperation.closeVariableMap;\n      // @run <date, toast> (boom)\n      //           ^ cursor is here\n      lastNode = keywordNode;\n    } else if (\n      operation === ParseOperation.closeVariableMap &&\n      cursor === CharacterType.variableMapSeparator\n    ) {\n      lastNode = keywordNode;\n      variableMapArgumentStart = position + 1;\n      (keywordNode.variableMapping || (keywordNode.variableMapping = [])).push(\n        code.substring(variableMapArgumentStart, position).trim()\n      );\n    } else if (\n      operation === ParseOperation.closeVariableMap &&\n      cursor === CharacterType.variableMapCloser\n    ) {\n      lastNode = keywordNode;\n      // if non-empty variable map, add the variable in\n      if (position - 1 !== variableMapArgumentStart) {\n        (\n          keywordNode.variableMapping || (keywordNode.variableMapping = [])\n        ).push(code.substring(variableMapArgumentStart, position - 1).trim());\n      }\n\n      operation = ParseOperation.determineKeywordAttribute;\n      variableMapOpenerStart = variableMapArgumentStart = inlineStart = 0;\n      // @export function $Foo(bacon) {\n      //                      ^ cursor is here\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.inlineOpener &&\n      keywordNode.keyword === ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      inlineStart = position;\n      operation = ParseOperation.closeInline;\n      inlineDepthCount = 0;\n      keywordNode.scope = Scope.multiline;\n\n      // @run (bacon(\n      //            ^ cursor is here\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.newline &&\n      (keywordNode.keyword === ASTNodeKeyword.build ||\n        keywordNode.keyword === ASTNodeKeyword.run) &&\n      keywordNode.scope === Scope.none\n    ) {\n      operation = ParseOperation.findControl;\n      lastNode = keywordNode;\n      keywordNode.scope = Scope.multiline;\n      parent.children.push(keywordNode);\n      parent = keywordNode;\n      // sourceNode = null;\n      sourceNode = null;\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.inlineOpener &&\n      keywordNode.keyword !== ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      inlineStart = position;\n      operation = ParseOperation.closeInline;\n      inlineDepthCount = 0;\n      keywordNode.scope = Scope.inline;\n      sourceNode = Object.create(astNodeBase);\n      sourceNode.from = position + 1;\n      sourceNode.parent = keywordNode;\n      sourceNode.colStart = column;\n      sourceNode.lineStart = line;\n\n      // @run (bacon(\n      //            ^ cursor is here\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineOpener\n    ) {\n      lastNode = keywordNode;\n      inlineDepthCount++;\n      // @run (bacon()\n      //             ^ cursor is here\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineCloser &&\n      inlineDepthCount > 0\n    ) {\n      lastNode = keywordNode;\n      inlineDepthCount--;\n      // @run (bacon())\n      //              ^ cursor is here\n      // This is the end of the node.\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineCloser &&\n      inlineDepthCount === 0 &&\n      keywordNode.keyword !== ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      keywordNode.lineEnd = keywordNode.lineStart = line;\n      keywordNode.to = position;\n      keywordNode.colEnd = column;\n      keywordNode.parent = parent;\n      keywordNode.scope = Scope.inline;\n\n      if (sourceNode) {\n        sourceNode.to = position;\n        // sourceNode.value = code.substring(sourceNode.from, sourceNode.to);\n        sourceNode.parent = keywordNode;\n        keywordNode.children = [sourceNode];\n        sourceNode = null;\n      }\n\n      (parent.children || (parent.children = [])).push(keywordNode);\n      keywordNode = parent;\n\n      operation = ParseOperation.findControl;\n      sourceNode = Object.create(astNodeBase);\n\n      sourceNode.from = position + 1;\n      sourceNode.parent = keywordNode;\n      keywordNode.children.push(sourceNode);\n      // sourceNode = null;\n\n      // @export function $BitField (bacon) {\n      //                                  ^ cursor is here\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineCloser &&\n      inlineDepthCount === 0 &&\n      keywordNode.keyword === ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      keywordNode.value = code.substring(inlineStart + 1, position);\n      keywordNode.lineStart = line;\n      // Everything after this is the source of the function\n      operation = ParseOperation.findControl;\n      root.children.push(keywordNode);\n      keywordNode.parent = root;\n      inlineEnd = position + 1;\n      parent = keywordNode;\n\n      // @run {\n      //      ^ cursor is here\n      // This is the start of a new scope.\n    } else if (\n      cursor === CharacterType.newline &&\n      parent.keyword === ASTNodeKeyword.export &&\n      line - 1 === parent.lineStart\n    ) {\n      parent.functionDeclarationSuffix = code.substring(inlineEnd, position);\n      if (\n        parent.functionDeclarationSuffix.length &&\n        parent.functionDeclarationSuffix.lastIndexOf(\"{\") ===\n          parent.functionDeclarationSuffix.length - 1\n      ) {\n        throw new AtbuildParseError(\n          ParseErrorType.strayOpenBrace,\n          `Unnecessary { at ${\n            line - 1\n          }:${endOfPreviousLineColumn} in ${filename}`,\n          `@export function should not have \"{\" or \"}\" at the start or end, it will be added at build-time. Use @end at the end.`\n        );\n      }\n    } else if (\n      operation === ParseOperation.findControl &&\n      cursor === CharacterType.replacerStart\n    ) {\n      replacerStart = position;\n      operation = ParseOperation.determineReplacer;\n      lastNode = keywordNode;\n      // const bacon = $variable;\n      //                        ^ cursor is here.\n    } else if (\n      operation === ParseOperation.determineReplacer &&\n      cursor !== CharacterType.alphanumeric &&\n      position - replacerStart > 0 &&\n      sourceNode\n    ) {\n      replacerNode = Object.create(astNodeBase);\n      replacerNode.value = code.substring(replacerStart, position);\n      replacerNode.from = replacerStart;\n      replacerNode.to = position - 1;\n      replacerNode.parent = sourceNode;\n      (sourceNode.children || (sourceNode.children = [])).push(replacerNode);\n      operation = ParseOperation.findControl;\n      lastNode = sourceNode;\n    } else if (\n      operation === ParseOperation.determineName &&\n      cursor !== CharacterType.alphanumeric &&\n      cursor !== CharacterType.whitespace &&\n      cursor !== CharacterType.replacerStart\n    ) {\n      throw new AtbuildParseError(\n        ParseErrorType.invalidExportFunction,\n        `Invalid @export function`,\n        `\"@export function\" must have a name that starts with \"$\" on the same line (${line}:${column} in ${filename})`\n      );\n      // @export function $CreateBitField\n      //                  ^ cursor is here.\n    } else if (\n      operation === ParseOperation.determineName &&\n      cursor === CharacterType.replacerStart\n    ) {\n      nameStart = position;\n      operation = ParseOperation.closeName;\n      lastNode = keywordNode;\n      // @export function $CreateBitField (\n      //                                  ^ cursor is here.\n    } else if (\n      operation === ParseOperation.closeName &&\n      (cursor === CharacterType.whitespace || cursor === CharacterType.newline)\n    ) {\n      operation = ParseOperation.closeName;\n      keywordNode.name = code.substring(nameStart, position);\n      // Look for function arguments\n      operation = ParseOperation.determineKeywordAttribute;\n      lastNode = keywordNode;\n    }\n    // @export function $CreateBitField(\n    //                                 ^ cursor is here.\n    else if (\n      operation === ParseOperation.closeName &&\n      cursor === CharacterType.inlineOpener\n    ) {\n      operation = ParseOperation.closeName;\n      keywordNode.name = code.substring(nameStart, position);\n      // Look for function arguments\n      operation = ParseOperation.closeInline;\n      inlineStart = position;\n      lastNode = keywordNode;\n    } else if (\n      operation === ParseOperation.findControl &&\n      cursor !== CharacterType.whitespace &&\n      cursor !== CharacterType.newline &&\n      !isLineEmpty &&\n      !sourceNode &&\n      !(\n        keywordNode &&\n        keywordNode.keyword === ASTNodeKeyword.export &&\n        line === keywordNode.lineStart\n      )\n    ) {\n      lastNode = sourceNode = Object.create(astNodeBase);\n      sourceNode.children = [];\n      sourceNode.keyword = ASTNodeKeyword.source;\n      sourceNode.from = position;\n      sourceNode.lineStart = line;\n      sourceNode.colStart = column;\n      sourceNode.parent = parent;\n      parent.children.push(sourceNode);\n    }\n  }\n\n  if (sourceNode && sourceNode.parent === root) {\n    sourceNode.to = root.to = position;\n  }\n\n  // if (sourceNode) {\n  //   sourceNode.to = Math.min(position - 1, sourceNode.to);\n  // }\n\n  // if (keywordNode) {\n  //   keywordNode.to = Math.min(position - 1, keywordNode.to);\n  // }\n\n  // if (parent) {\n  //   parent.to = Math.min(position - 1, parent.to);\n  // }\n\n  // if (sourceNode) {\n  //   sourceNode.value = code.substring(sourceNode.from, sourceNode.to);\n  //   if (\n  //     sourceNode.parent &&\n  //     sourceNode.parent.children &&\n  //     !sourceNode.parent.children.includes(sourceNode)\n  //   ) {\n  //     sourceNode.parent.children.push(sourceNode);\n  //   } else if (!sourceNode.parent.children) {\n  //     sourceNode.parent.children.push(sourceNode);\n  //   }\n  // }\n\n  return root;\n}\n\nexport function transformAST(root: ASTNode, code: string): string {\n  let source = `var _this = {[\"${PARTIAL_SOURCE_CODE_VARIABLE}\"]: \"\"};\\n`;\n  let needsRootSource = false;\n  for (let i = 0; i < root.children.length; i++) {\n    if (\n      !needsRootSource &&\n      root.children[i].keyword !== ASTNodeKeyword.export\n    ) {\n      needsRootSource = true;\n    }\n\n    source += visit(root.children[i], i, root, true, code);\n  }\n\n  if (needsRootSource) {\n    if (\n      !(\n        source[source.length - 1] === \";\" ||\n        (source[source.length - 2] === \";\" &&\n          source[source.length - 1] === \"\\n\")\n      )\n    ) {\n      source += \";\";\n    }\n\n    source += `\\nmodule.exports.default = ${SOURCE_CODE_VARIABLE};\\n${SOURCE_CODE_VARIABLE} = \"\";\\n`;\n  }\n\n  return source;\n}\n\nconst PARTIAL_SOURCE_CODE_VARIABLE = \"___source___\";\nconst SOURCE_CODE_VARIABLE = `_this.${PARTIAL_SOURCE_CODE_VARIABLE}`;\n\nconst REPLACERS_VARIABLE = \"___replacers___\";\n\nfunction quotedVariableMapping(value: string, index: number) {\n  return `\"${value}\"`;\n}\n\nfunction visit(\n  node: ASTNode,\n  i: number,\n  parent: ASTNode | null,\n  trailingNewline = true,\n  input: string\n): string {\n  let functionName = `${ASTNodeKeyword[node.keyword]}___${node.lineStart}_${\n    node.colStart\n  }__${node.lineEnd}_${node.colEnd}`;\n  let source = \"\";\n\n  switch (node.keyword) {\n    case ASTNodeKeyword.interpolate: {\n      switch (parent.keyword) {\n        case ASTNodeKeyword.build:\n        case ASTNodeKeyword.export:\n        case ASTNodeKeyword.root: {\n          node.keyword = ASTNodeKeyword.run;\n          return visit(node, i, parent, trailingNewline, input);\n        }\n        case ASTNodeKeyword.run: {\n          node.keyword = ASTNodeKeyword.build;\n          return visit(node, i, parent, trailingNewline, input);\n        }\n\n        default:\n          throw \"Invalid input\";\n      }\n    }\n\n    case ASTNodeKeyword.build: {\n      if (node.scope === Scope.inline) {\n        if (node.parent && node.parent.keyword === ASTNodeKeyword.run) {\n          source += `${SOURCE_CODE_VARIABLE} += (`;\n        }\n        // source += `(function ${functionName}(${SOURCE_CODE_VARIABLE})  { return (`;\n        if (node.children) {\n          for (let child of node.children) {\n            source += visit(child, i + 1, node, false, input);\n          }\n        }\n        // const variableMapping = (node.variableMapping || [])\n        //   .map(quotedVariableMapping)\n        //   .join(\", \");\n        // source += `);})(${SOURCE_CODE_VARIABLE}, [${variableMapping}])`;\n      } else if (\n        node.scope === Scope.multiline &&\n        parent.keyword !== ASTNodeKeyword.root\n      ) {\n        // source += `(function build__${i}(){${node.value || \"\"}\\n`;\n        if (node.children) {\n          for (let child of node.children) {\n            source += visit(child, i + 1, node, trailingNewline, input);\n          }\n        }\n\n        // source += `\\n`;\n      } else if (\n        node.scope === Scope.multiline &&\n        parent.keyword === ASTNodeKeyword.root\n      ) {\n        if (node.children) {\n          for (let child of node.children) {\n            source += visit(child, i + 1, node, trailingNewline, input);\n          }\n        }\n      } else {\n        throw \"Not implemented\";\n      }\n\n      if (\n        node.scope === Scope.inline &&\n        parent &&\n        parent.keyword === ASTNodeKeyword.run\n      ) {\n        source += `);`;\n      }\n\n      break;\n    }\n\n    case ASTNodeKeyword.export: {\n      source += `\\n;var ${node.name} = (module.exports.${\n        node.name\n      } = (function ${node.name}(${node.value.trim().split(\",\").join(\", \")})${\n        node.functionDeclarationSuffix\n      } {\n        let originalThis = _this;\n\n        if (!this || typeof this[\"${PARTIAL_SOURCE_CODE_VARIABLE}\"] === 'undefined') {\n          _this = {\n            [\"${PARTIAL_SOURCE_CODE_VARIABLE}\"]: \"\"\n          }\n        } else {\n          _this = this;\n        }\n\n        const buildEval = (function ${functionName}() {\\n`;\n      if (node.children) {\n        for (let child of node.children) {\n          source += visit(child, i + 1, node, trailingNewline, input);\n        }\n      }\n\n      // const variableMapping = (node.variableMapping || [])\n      //   .map(quotedVariableMapping)\n      //   .join(\", \");\n      source += `\\n})();\n    let output = ${SOURCE_CODE_VARIABLE};\n    _this = originalThis;\n  return typeof buildEval === 'undefined' ? output : buildEval;\n}));\\n\\n`;\n\n      break;\n    }\n\n    case ASTNodeKeyword.inline: {\n      throw \"Not implemented yet\";\n      break;\n    }\n\n    case ASTNodeKeyword.run: {\n      // if (parent.keyword !== ASTNodeKeyword.build) {\n      //   source += `(function run__${i}(${SOURCE_CODE_VARIABLE}, ${REPLACERS_VARIABLE}) {\n      //     ${node.value || \"\"}\n      //     `;\n      // }\n\n      if (node.children) {\n        for (let child of node.children) {\n          source += visit(child, i + 1, node, trailingNewline, input);\n        }\n      }\n\n      // if (parent.keyword !== ASTNodeKeyword.build) {\n      //   source += `})();\\n`;\n      // }\n\n      break;\n    }\n\n    case ASTNodeKeyword.source: {\n      let value = input.substring(node.from, Math.min(node.to, input.length));\n\n      if (\n        parent.keyword === ASTNodeKeyword.build ||\n        parent.keyword === ASTNodeKeyword.export ||\n        parent.keyword === ASTNodeKeyword.inline\n      ) {\n        return trailingNewline ? value : value.trimEnd();\n      } else if (\n        parent.keyword === ASTNodeKeyword.run ||\n        parent.keyword === ASTNodeKeyword.root\n      ) {\n        if (\n          node.children &&\n          node.children.length &&\n          parent &&\n          parent.variableMapping &&\n          parent.variableMapping.length\n        ) {\n          const slottedValue = [value];\n\n          let replacerIndex = -1;\n          let slotOffset = 0;\n          let positionOffset = node.from;\n          let position = 0;\n          for (let i = 0; i < node.children.length; i++) {\n            const replacer = node.children[i];\n            replacerIndex = parent.variableMapping.indexOf(replacer.name);\n\n            if (replacerIndex === -1) {\n              continue;\n            }\n\n            slottedValue.length += 2;\n\n            slottedValue[slotOffset++] = value.substring(\n              position - positionOffset,\n              replacer.from - positionOffset\n            );\n\n            slottedValue[\n              slotOffset++\n            ] = `\" + ${REPLACERS_VARIABLE}[${replacerIndex}] + \"`;\n\n            slottedValue[slotOffset++] = value.substring(\n              replacer.to - positionOffset + 1\n            );\n          }\n          value = slottedValue.join(\"\");\n        }\n        source += `${SOURCE_CODE_VARIABLE} += \"${value\n          .replace(/\\n/gm, \"\\\\n\")\n          .replace(/\"/gm, '\\\\\"')}\";${trailingNewline ? \"\\n\" : \"\"}`;\n      } else {\n        throw \"Unhandled keyword type\";\n      }\n\n      break;\n    }\n    default: {\n      debugger;\n      throw `Invalid ASTNodeKeyword: ${node.keyword}`;\n      break;\n    }\n  }\n\n  return source;\n}\n", "enum CharacterType {\n  ignore = 0,\n  newline = 13, // \\n\n  whitespace = 1, //\n\n  alphanumeric = 3, // [a-zA-Z0-9]\n  control = 4, // @\n  scopeOpener = 5, // {\n  scopeCloser = 6, // }\n  variableMapOpener = 7, // <\n  variableMapCloser = 8, // >\n  variableMapSeparator = 9, // ,\n  inlineOpener = 10, // (\n  inlineCloser = 11, // )\n  escape = 12, // \\\n  replacerStart = 2, // $\n  quote = 12,\n}\n\nexport enum Scope {\n  none = 0,\n  inline = 1,\n  multiline = 2,\n}\n\nenum ParseOperation {\n  findControl = 0,\n  determineKeyword = 1,\n  determineKeywordAttribute = 2,\n  closeVariableMap = 3,\n  closeInline = 4,\n  determineReplacer = 5,\n  closeScope = 6,\n  determineName = 7,\n  closeName = 8,\n}\n\nexport enum ASTNodeKeyword {\n  source = 0,\n  run = 1,\n  build = 2,\n  export = 3,\n  inline = 4,\n  replacer = 5,\n  root = 6,\n  interpolate = 7,\n}\n\nexport interface ASTNode {\n  parent?: ASTNode;\n  children?: ASTNode[];\n  variableMapping: string[];\n  keyword: ASTNodeKeyword;\n  name?: string;\n  scope: Scope;\n  value?: string;\n  lineStart: number;\n  functionDeclarationSuffix: string;\n  lineEnd: number;\n  colStart: number;\n  colEnd: number;\n  from: number;\n  to: number;\n}\n\nlet astNodeBase: ASTNode = {\n  children: [],\n  variableMapping: [],\n  scope: Scope.none,\n  keyword: ASTNodeKeyword.source,\n  name: \"\",\n  value: \"\",\n  functionDeclarationSuffix: \"\",\n  lineStart: 0,\n  lineEnd: 0,\n  colStart: 0,\n  colEnd: 0,\n  from: 0,\n  to: 0,\n};\n\nconst ScopeNames = {\n  [Scope.inline]: \"inline\",\n  [Scope.none]: null,\n  [Scope.multiline]: \"multiline\",\n};\n\nconst KeywordName = {\n  [ASTNodeKeyword.source]: \"source\",\n  [ASTNodeKeyword.run]: \"run\",\n  [ASTNodeKeyword.build]: \"build\",\n  [ASTNodeKeyword.export]: \"export\",\n  [ASTNodeKeyword.inline]: \"inline\",\n  [ASTNodeKeyword.replacer]: \"$\",\n  [ASTNodeKeyword.root]: \"root\",\n};\n\nconst _toJSON = (item) => item.toJSON();\n\nastNodeBase.toJSON = function () {\n  const {\n    parent,\n    _parent,\n    scope,\n    keyword,\n    children,\n    colStart,\n    lineStart,\n    lineEnd,\n    colEnd,\n    ...json\n  } = this as ASTNode;\n  return {\n    ...json,\n    children: children.map(_toJSON),\n    scope: ScopeNames[scope],\n    keyword: KeywordName[keyword],\n    column: {\n      start: colStart,\n      end: colEnd,\n    },\n    line: {\n      start: lineStart,\n      end: lineEnd,\n    },\n  };\n};\n\nif (typeof WeakRef !== \"undefined\") {\n  Object.defineProperty(astNodeBase, \"parent\", {\n    get() {\n      return this._parent && this._parent.deref();\n    },\n\n    set(parent) {\n      if (parent) {\n        return (this._parent = new WeakRef(parent));\n      } else {\n        return (this._parent = null);\n      }\n    },\n  });\n}\n\nif (process.env.NODE_ENV === \"test\") {\n  Object.defineProperty(astNodeBase, \"k\", {\n    get() {\n      return ASTNodeKeyword[this.keyword];\n    },\n  });\n\n  astNodeBase.original = function (source) {\n    return source.substring(this.from, this.to);\n  };\n}\n\nconst charTypes = new Uint8Array(255);\nconst emptyCharTypes = new Uint8Array(255);\nconst incrementLineNumber = new Uint8Array(255);\n\nenum ControlIdentifier {\n  invalid = 0,\n  inline = 1,\n  export = 2,\n  build = 3,\n  run = 4,\n  closeScope = 5,\n  interpolate = 6,\n}\n\nconst Keywords = {\n  run: {\n    start: \"run\",\n    scope: true,\n    inline: true,\n    variableMapper: true,\n    name: false,\n    arguments: false,\n    prefixCode: \"r\".charCodeAt(0),\n  },\n  build: {\n    start: \"build\",\n    scope: true,\n    inline: true,\n    variableMapper: true,\n    name: false,\n    arguments: false,\n    prefixCode: \"b\".charCodeAt(0),\n  },\n  export: {\n    start: \"export\",\n    scope: true,\n    inline: false,\n    variableMapper: false,\n    name: true,\n    arguments: true,\n    prefixCode: \"e\".charCodeAt(0),\n  },\n  inline: {\n    start: \"inline\",\n    scope: false,\n    inline: true,\n    variableMapper: true,\n    name: false,\n    arguments: false,\n    prefixCode: \"i\".charCodeAt(0),\n  },\n};\n\nconst controlIdentifierTypes = new Uint8Array(255);\n\nconst controlIdentifierSkipLength = new Uint8Array(8);\nconst operationsByControlIdentifier = new Uint8Array(8);\n\nconst keywordNames = new Array(6);\n\nfunction getControlIdentifier(code: string, position: number) {\n  if (code[position + 1] === \"e\" && code[position + 2] === \"n\") {\n    return ControlIdentifier.closeScope;\n  } else {\n    return controlIdentifierTypes[code.charCodeAt(position + 1)];\n  }\n}\n\nemptyCharTypes.fill(0);\nemptyCharTypes[CharacterType.whitespace] = 1;\nemptyCharTypes[CharacterType.newline] = 1;\ncontrolIdentifierTypes[Keywords.inline.prefixCode] = ControlIdentifier.inline;\ncontrolIdentifierTypes[Keywords.run.prefixCode] = ControlIdentifier.run;\ncontrolIdentifierTypes[Keywords.build.prefixCode] = ControlIdentifier.build;\ncontrolIdentifierTypes[Keywords.export.prefixCode] = ControlIdentifier.export;\ncontrolIdentifierTypes[\"(\".charCodeAt(0)] = ControlIdentifier.interpolate;\n\ncharTypes[`\"`.charCodeAt(0)] = CharacterType.quote;\ncharTypes[`'`.charCodeAt(0)] = CharacterType.quote;\ncharTypes[\"`\".charCodeAt(0)] = CharacterType.quote;\n\ncontrolIdentifierSkipLength[ControlIdentifier.inline] = \"inline\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.run] = \"run\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.build] = \"build\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.interpolate] = \"(\".length;\ncontrolIdentifierSkipLength[\n  ControlIdentifier.export\n] = \"export function\".length;\ncontrolIdentifierSkipLength[ControlIdentifier.closeScope] = \"end\".length;\n\nkeywordNames[ControlIdentifier.inline] = \"inline\";\nkeywordNames[ControlIdentifier.run] = \"run\";\nkeywordNames[ControlIdentifier.build] = \"build\";\nkeywordNames[ControlIdentifier.export] = \"export function\";\nkeywordNames[ControlIdentifier.closeScope] = \"end\";\nkeywordNames[ControlIdentifier.interpolate] = \"(\";\n\noperationsByControlIdentifier.fill(ParseOperation.determineKeywordAttribute);\noperationsByControlIdentifier[0] = ParseOperation.findControl;\noperationsByControlIdentifier[ControlIdentifier.export] =\n  ParseOperation.determineName;\noperationsByControlIdentifier[ControlIdentifier.interpolate] =\n  ParseOperation.closeInline;\n\nconst keywordTypes = new Uint8Array(8);\nkeywordTypes[ControlIdentifier.inline] = ASTNodeKeyword.inline;\nkeywordTypes[ControlIdentifier.run] = ASTNodeKeyword.run;\nkeywordTypes[ControlIdentifier.build] = ASTNodeKeyword.build;\nkeywordTypes[ControlIdentifier.interpolate] = ASTNodeKeyword.interpolate;\nkeywordTypes[ControlIdentifier.export] = ASTNodeKeyword.export;\n\nincrementLineNumber[CharacterType.newline] = 1;\n\nconst backtrackAmount = new Int8Array(16);\nbacktrackAmount[CharacterType.newline] = -1;\nbacktrackAmount[CharacterType.whitespace] = -1;\n\nfor (let code = 0; code < 256; code++) {\n  if ((code > 64 && code < 91) || (code > 96 && code < 123)) {\n    charTypes[code] = CharacterType.alphanumeric;\n  } else if (code === \"$\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.replacerStart;\n  } else if (code === \"\\n\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.newline;\n  } else if (code === \" \".charCodeAt(0)) {\n    charTypes[code] = CharacterType.whitespace;\n  } else if (code === \"@\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.control;\n  } else if (code === \"(\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.inlineOpener;\n  } else if (code === \")\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.inlineCloser;\n  } else if (code === \"<\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.variableMapOpener;\n  } else if (code === \",\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.variableMapSeparator;\n  } else if (code === \">\".charCodeAt(0)) {\n    charTypes[code] = CharacterType.variableMapCloser;\n  } else {\n  }\n}\n\nenum ParseErrorType {\n  invalidKeyword = 0,\n  invalidExportFunction = 1,\n  strayOpenBrace = 2,\n}\n\nconst ParseErrorNames = {\n  [ParseErrorType.strayOpenBrace]: \"Invalid {\",\n  [ParseErrorType.invalidKeyword]: \"Invalid keyword\",\n  [ParseErrorType.invalidExportFunction]: \"Invalid export function\",\n};\n\nclass AtbuildParseError extends Error {\n  constructor(type: ParseErrorType, name: string, message: string) {\n    super(message);\n    this.name = name;\n    this.type = type;\n  }\n  type: ParseErrorType;\n}\n\nexport function buildAST(code: string, filename: string = \"file.tsb\"): ASTNode {\n  const root: ASTNode = Object.create(astNodeBase);\n  let sourceNode: ASTNode;\n  let position = 0,\n    cursor: CharacterType = CharacterType.ignore,\n    operation = ParseOperation.findControl,\n    controlIdentifierType = ControlIdentifier.invalid,\n    prevCursor: CharacterType = cursor,\n    line = 0,\n    column = 0,\n    skipLength = 0,\n    parent: ASTNode = root,\n    replacerNode: ASTNode,\n    keywordNode: ASTNode,\n    inlineDepthCount = 0,\n    scopeDepthCount = 0,\n    inlineStart = 0,\n    nameStart = 0,\n    variableMapOpenerStart = 0,\n    variableMapArgumentStart = 0,\n    lastNode: ASTNode,\n    endOfPreviousLine = 0,\n    keywordNameMatch = false,\n    endOfPreviousLineColumn = 0,\n    isLineEmpty = 1,\n    inlineEnd = 0,\n    replacerStart = 0;\n\n  // sourceNode.parent = parent;\n  root.children = [];\n  root.keyword = ASTNodeKeyword.root;\n\n  for (position = 0; position < code.length; position++, prevCursor = cursor) {\n    cursor = charTypes[code.charCodeAt(position)];\n    if (incrementLineNumber[cursor]) {\n      endOfPreviousLine = position - 1;\n      endOfPreviousLineColumn = column;\n      line++;\n      column = -1;\n      isLineEmpty = 1;\n    } else {\n    }\n\n    isLineEmpty = Math.min(isLineEmpty, emptyCharTypes[cursor]);\n\n    column++;\n\n    if (\n      operation === ParseOperation.findControl &&\n      cursor === CharacterType.control\n    ) {\n      // Look at the letter after \"@\"\n      // Is it \"r\"? Its a run keyword. \"e\"? export. etc.\n      controlIdentifierType = getControlIdentifier(code, position);\n\n      skipLength = controlIdentifierSkipLength[controlIdentifierType] | 0;\n      keywordNameMatch =\n        keywordNames[controlIdentifierType] ===\n        code.substring(position + 1, position + skipLength + 1);\n\n      // Handle scoped imports\n      // If you import \"@babylonjs\" inside a .tsb file, it would think its a control character\n      // But, its just a package name\n      // The more reliable way to do this would be running a full JS parser.\n      // But, we're not going to bother.\n      // Instead, we say\n      // Is there a quote before the control character?\n      // If so, just ignore it.\n      if (\n        (controlIdentifierType === ControlIdentifier.invalid ||\n          !keywordNameMatch) &&\n        prevCursor === CharacterType.quote\n      ) {\n        continue;\n      }\n\n      // assert its what we expect.\n      if (\n        controlIdentifierType === ControlIdentifier.invalid ||\n        !keywordNameMatch\n      ) {\n        throw new AtbuildParseError(\n          ParseErrorType.invalidKeyword,\n          `Invalid @ keyword in ${filename}:${line}:${column - 1}`,\n          `Invalid @ keyword in ${filename}:${line}:${\n            column - 1\n          }. Must be @run, @build, @export function $, @inline, @(buildCode), or @end. Received \"${code\n            .substring(position)\n            .split(\" \")[0]\n            .slice(0, 10)\n            .replace(\"\\n\", \"\\\\n\")}\"\\n`\n        );\n      } else if (controlIdentifierType === ControlIdentifier.closeScope) {\n        keywordNode.to = position;\n        keywordNode.lineEnd = line - 1;\n        keywordNode.colEnd = endOfPreviousLineColumn;\n        keywordNode.scope = Scope.multiline;\n\n        // parent.children.push(keywordNode);\n\n        if (sourceNode) {\n          sourceNode.to = parent.to = keywordNode.to;\n          sourceNode.lineEnd = parent.lineEnd = line - 1;\n          sourceNode.colEnd = parent.colEnd = endOfPreviousLineColumn;\n          sourceNode.parent = parent;\n          // sourceNode.value = code.substring(sourceNode.from, sourceNode.to);\n          if (\n            sourceNode.value.length &&\n            !keywordNode.children.includes(sourceNode)\n          ) {\n            keywordNode.children.push(sourceNode);\n          }\n          sourceNode = null;\n        }\n        keywordNode = parent || root;\n        parent = keywordNode.parent || root;\n\n        scopeDepthCount = 0;\n\n        operation = ParseOperation.findControl;\n\n        // lastNode = sourceNode = Object.create(astNodeBase);\n        // sourceNode.children = [];\n        // sourceNode.keyword = ASTNodeKeyword.source;\n        // sourceNode.from = position + 1; //+ backtrackAmount[prevCursor];\n        // sourceNode.lineStart = line;\n        // sourceNode.colStart = column;\n        // sourceNode.parent = parent;\n        // lastNode = keywordNode;\n      } else {\n        operation = operationsByControlIdentifier[controlIdentifierType];\n        if (sourceNode) {\n          sourceNode.colEnd = column;\n          sourceNode.lineEnd = line;\n          sourceNode.to = position;\n          sourceNode = null;\n          //sourceNode.value = code.substring(sourceNode.from, position);\n        }\n\n        variableMapOpenerStart = variableMapArgumentStart = inlineStart = 0;\n\n        keywordNode = Object.create(astNodeBase);\n        keywordNode.children = [];\n        keywordNode.from = position;\n        keywordNode.colStart = column;\n        keywordNode.lineStart = line;\n\n        keywordNode.keyword = keywordTypes[controlIdentifierType];\n        if (keywordNode.keyword === ASTNodeKeyword.export) {\n          keywordNode.parent = parent = root;\n        } else {\n          keywordNode.parent = parent;\n        }\n\n        if (operation === ParseOperation.closeInline) {\n          // @(bacon)\n          // ^ === position\n          //   ^ === desired position\n          inlineStart = position + 2;\n\n          sourceNode = Object.create(astNodeBase);\n          sourceNode.lineStart = line;\n          sourceNode.from = inlineStart;\n          sourceNode.parent = keywordNode;\n          sourceNode.colStart = column;\n        }\n      }\n\n      // Skip ahead\n      position += skipLength;\n\n      // @run <a\n      //      ^ cursor is here\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.variableMapOpener\n    ) {\n      variableMapOpenerStart = position;\n      variableMapArgumentStart = position + 1;\n      operation = ParseOperation.closeVariableMap;\n      // @run <date, toast> (boom)\n      //           ^ cursor is here\n      lastNode = keywordNode;\n    } else if (\n      operation === ParseOperation.closeVariableMap &&\n      cursor === CharacterType.variableMapSeparator\n    ) {\n      lastNode = keywordNode;\n      variableMapArgumentStart = position + 1;\n      (keywordNode.variableMapping || (keywordNode.variableMapping = [])).push(\n        code.substring(variableMapArgumentStart, position).trim()\n      );\n    } else if (\n      operation === ParseOperation.closeVariableMap &&\n      cursor === CharacterType.variableMapCloser\n    ) {\n      lastNode = keywordNode;\n      // if non-empty variable map, add the variable in\n      if (position - 1 !== variableMapArgumentStart) {\n        (\n          keywordNode.variableMapping || (keywordNode.variableMapping = [])\n        ).push(code.substring(variableMapArgumentStart, position - 1).trim());\n      }\n\n      operation = ParseOperation.determineKeywordAttribute;\n      variableMapOpenerStart = variableMapArgumentStart = inlineStart = 0;\n      // @export function $Foo(bacon) {\n      //                      ^ cursor is here\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.inlineOpener &&\n      keywordNode.keyword === ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      inlineStart = position;\n      operation = ParseOperation.closeInline;\n      inlineDepthCount = 0;\n      keywordNode.scope = Scope.multiline;\n\n      // @run (bacon(\n      //            ^ cursor is here\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.newline &&\n      (keywordNode.keyword === ASTNodeKeyword.build ||\n        keywordNode.keyword === ASTNodeKeyword.run) &&\n      keywordNode.scope === Scope.none\n    ) {\n      operation = ParseOperation.findControl;\n      lastNode = keywordNode;\n      keywordNode.scope = Scope.multiline;\n      parent.children.push(keywordNode);\n      parent = keywordNode;\n      // sourceNode = null;\n      sourceNode = null;\n    } else if (\n      operation === ParseOperation.determineKeywordAttribute &&\n      cursor === CharacterType.inlineOpener &&\n      keywordNode.keyword !== ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      inlineStart = position;\n      operation = ParseOperation.closeInline;\n      inlineDepthCount = 0;\n      keywordNode.scope = Scope.inline;\n      sourceNode = Object.create(astNodeBase);\n      sourceNode.from = position + 1;\n      sourceNode.parent = keywordNode;\n      sourceNode.colStart = column;\n      sourceNode.lineStart = line;\n\n      // @run (bacon(\n      //            ^ cursor is here\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineOpener\n    ) {\n      lastNode = keywordNode;\n      inlineDepthCount++;\n      // @run (bacon()\n      //             ^ cursor is here\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineCloser &&\n      inlineDepthCount > 0\n    ) {\n      lastNode = keywordNode;\n      inlineDepthCount--;\n      // @run (bacon())\n      //              ^ cursor is here\n      // This is the end of the node.\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineCloser &&\n      inlineDepthCount === 0 &&\n      keywordNode.keyword !== ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      keywordNode.lineEnd = keywordNode.lineStart = line;\n      keywordNode.to = position;\n      keywordNode.colEnd = column;\n      keywordNode.parent = parent;\n      keywordNode.scope = Scope.inline;\n\n      if (sourceNode) {\n        sourceNode.to = position;\n        // sourceNode.value = code.substring(sourceNode.from, sourceNode.to);\n        sourceNode.parent = keywordNode;\n        keywordNode.children = [sourceNode];\n        sourceNode = null;\n      }\n\n      (parent.children || (parent.children = [])).push(keywordNode);\n      keywordNode = parent;\n\n      operation = ParseOperation.findControl;\n      sourceNode = Object.create(astNodeBase);\n\n      sourceNode.from = position + 1;\n      sourceNode.parent = keywordNode;\n      keywordNode.children.push(sourceNode);\n      // sourceNode = null;\n\n      // @export function $BitField (bacon) {\n      //                                  ^ cursor is here\n    } else if (\n      operation === ParseOperation.closeInline &&\n      cursor === CharacterType.inlineCloser &&\n      inlineDepthCount === 0 &&\n      keywordNode.keyword === ASTNodeKeyword.export\n    ) {\n      lastNode = keywordNode;\n      keywordNode.value = code.substring(inlineStart + 1, position);\n      keywordNode.lineStart = line;\n      // Everything after this is the source of the function\n      operation = ParseOperation.findControl;\n      root.children.push(keywordNode);\n      keywordNode.parent = root;\n      inlineEnd = position + 1;\n      parent = keywordNode;\n\n      // @run {\n      //      ^ cursor is here\n      // This is the start of a new scope.\n    } else if (\n      cursor === CharacterType.newline &&\n      parent.keyword === ASTNodeKeyword.export &&\n      line - 1 === parent.lineStart\n    ) {\n      parent.functionDeclarationSuffix = code.substring(inlineEnd, position);\n      if (\n        parent.functionDeclarationSuffix.length &&\n        parent.functionDeclarationSuffix.lastIndexOf(\"{\") ===\n          parent.functionDeclarationSuffix.length - 1\n      ) {\n        throw new AtbuildParseError(\n          ParseErrorType.strayOpenBrace,\n          `Unnecessary { at ${\n            line - 1\n          }:${endOfPreviousLineColumn} in ${filename}`,\n          `@export function should not have \"{\" or \"}\" at the start or end, it will be added at build-time. Use @end at the end.`\n        );\n      }\n    } else if (\n      operation === ParseOperation.findControl &&\n      cursor === CharacterType.replacerStart\n    ) {\n      replacerStart = position;\n      operation = ParseOperation.determineReplacer;\n      lastNode = keywordNode;\n      // const bacon = $variable;\n      //                        ^ cursor is here.\n    } else if (\n      operation === ParseOperation.determineReplacer &&\n      cursor !== CharacterType.alphanumeric &&\n      position - replacerStart > 0 &&\n      sourceNode\n    ) {\n      replacerNode = Object.create(astNodeBase);\n      replacerNode.value = code.substring(replacerStart, position);\n      replacerNode.from = replacerStart;\n      replacerNode.to = position - 1;\n      replacerNode.parent = sourceNode;\n      (sourceNode.children || (sourceNode.children = [])).push(replacerNode);\n      operation = ParseOperation.findControl;\n      lastNode = sourceNode;\n    } else if (\n      operation === ParseOperation.determineName &&\n      cursor !== CharacterType.alphanumeric &&\n      cursor !== CharacterType.whitespace &&\n      cursor !== CharacterType.replacerStart\n    ) {\n      throw new AtbuildParseError(\n        ParseErrorType.invalidExportFunction,\n        `Invalid @export function`,\n        `\"@export function\" must have a name that starts with \"$\" on the same line (${line}:${column} in ${filename})`\n      );\n      // @export function $CreateBitField\n      //                  ^ cursor is here.\n    } else if (\n      operation === ParseOperation.determineName &&\n      cursor === CharacterType.replacerStart\n    ) {\n      nameStart = position;\n      operation = ParseOperation.closeName;\n      lastNode = keywordNode;\n      // @export function $CreateBitField (\n      //                                  ^ cursor is here.\n    } else if (\n      operation === ParseOperation.closeName &&\n      (cursor === CharacterType.whitespace || cursor === CharacterType.newline)\n    ) {\n      operation = ParseOperation.closeName;\n      keywordNode.name = code.substring(nameStart, position);\n      // Look for function arguments\n      operation = ParseOperation.determineKeywordAttribute;\n      lastNode = keywordNode;\n    }\n    // @export function $CreateBitField(\n    //                                 ^ cursor is here.\n    else if (\n      operation === ParseOperation.closeName &&\n      cursor === CharacterType.inlineOpener\n    ) {\n      operation = ParseOperation.closeName;\n      keywordNode.name = code.substring(nameStart, position);\n      // Look for function arguments\n      operation = ParseOperation.closeInline;\n      inlineStart = position;\n      lastNode = keywordNode;\n    } else if (\n      operation === ParseOperation.findControl &&\n      cursor !== CharacterType.whitespace &&\n      cursor !== CharacterType.newline &&\n      !isLineEmpty &&\n      !sourceNode &&\n      !(\n        keywordNode &&\n        keywordNode.keyword === ASTNodeKeyword.export &&\n        line === keywordNode.lineStart\n      )\n    ) {\n      lastNode = sourceNode = Object.create(astNodeBase);\n      sourceNode.children = [];\n      sourceNode.keyword = ASTNodeKeyword.source;\n      sourceNode.from = position;\n      sourceNode.lineStart = line;\n      sourceNode.colStart = column;\n      sourceNode.parent = parent;\n      parent.children.push(sourceNode);\n    }\n  }\n\n  if (sourceNode && sourceNode.parent === root) {\n    sourceNode.to = root.to = position;\n  }\n\n  // if (sourceNode) {\n  //   sourceNode.to = Math.min(position - 1, sourceNode.to);\n  // }\n\n  // if (keywordNode) {\n  //   keywordNode.to = Math.min(position - 1, keywordNode.to);\n  // }\n\n  // if (parent) {\n  //   parent.to = Math.min(position - 1, parent.to);\n  // }\n\n  // if (sourceNode) {\n  //   sourceNode.value = code.substring(sourceNode.from, sourceNode.to);\n  //   if (\n  //     sourceNode.parent &&\n  //     sourceNode.parent.children &&\n  //     !sourceNode.parent.children.includes(sourceNode)\n  //   ) {\n  //     sourceNode.parent.children.push(sourceNode);\n  //   } else if (!sourceNode.parent.children) {\n  //     sourceNode.parent.children.push(sourceNode);\n  //   }\n  // }\n\n  return root;\n}\n\nexport function transformAST(root: ASTNode, code: string): string {\n  let source = `var _this = {[\"${PARTIAL_SOURCE_CODE_VARIABLE}\"]: \"\"};\\n`;\n  let needsRootSource = false;\n  for (let i = 0; i < root.children.length; i++) {\n    if (\n      !needsRootSource &&\n      root.children[i].keyword !== ASTNodeKeyword.export\n    ) {\n      needsRootSource = true;\n    }\n\n    source += visit(root.children[i], i, root, true, code);\n  }\n\n  if (needsRootSource) {\n    if (\n      !(\n        source[source.length - 1] === \";\" ||\n        (source[source.length - 2] === \";\" &&\n          source[source.length - 1] === \"\\n\")\n      )\n    ) {\n      source += \";\";\n    }\n\n    source += `\\nmodule.exports.default = ${SOURCE_CODE_VARIABLE};\\n${SOURCE_CODE_VARIABLE} = \"\";\\n`;\n  }\n\n  return source;\n}\n\nconst PARTIAL_SOURCE_CODE_VARIABLE = \"___source___\";\nconst SOURCE_CODE_VARIABLE = `_this.${PARTIAL_SOURCE_CODE_VARIABLE}`;\n\nconst REPLACERS_VARIABLE = \"___replacers___\";\n\nfunction quotedVariableMapping(value: string, index: number) {\n  return `\"${value}\"`;\n}\n\nfunction visit(\n  node: ASTNode,\n  i: number,\n  parent: ASTNode | null,\n  trailingNewline = true,\n  input: string\n): string {\n  let functionName = `${ASTNodeKeyword[node.keyword]}___${node.lineStart}_${\n    node.colStart\n  }__${node.lineEnd}_${node.colEnd}`;\n  let source = \"\";\n\n  switch (node.keyword) {\n    case ASTNodeKeyword.interpolate: {\n      switch (parent.keyword) {\n        case ASTNodeKeyword.build:\n        case ASTNodeKeyword.export:\n        case ASTNodeKeyword.root: {\n          node.keyword = ASTNodeKeyword.run;\n          return visit(node, i, parent, trailingNewline, input);\n        }\n        case ASTNodeKeyword.run: {\n          node.keyword = ASTNodeKeyword.build;\n          return visit(node, i, parent, trailingNewline, input);\n        }\n\n        default:\n          throw \"Invalid input\";\n      }\n    }\n\n    case ASTNodeKeyword.build: {\n      if (node.scope === Scope.inline) {\n        if (node.parent && node.parent.keyword === ASTNodeKeyword.run) {\n          source += `${SOURCE_CODE_VARIABLE} += (`;\n        }\n        // source += `(function ${functionName}(${SOURCE_CODE_VARIABLE})  { return (`;\n        if (node.children) {\n          for (let child of node.children) {\n            source += visit(child, i + 1, node, false, input);\n          }\n        }\n        // const variableMapping = (node.variableMapping || [])\n        //   .map(quotedVariableMapping)\n        //   .join(\", \");\n        // source += `);})(${SOURCE_CODE_VARIABLE}, [${variableMapping}])`;\n      } else if (\n        node.scope === Scope.multiline &&\n        parent.keyword !== ASTNodeKeyword.root\n      ) {\n        // source += `(function build__${i}(){${node.value || \"\"}\\n`;\n        if (node.children) {\n          for (let child of node.children) {\n            source += visit(child, i + 1, node, trailingNewline, input);\n          }\n        }\n\n        // source += `\\n`;\n      } else if (\n        node.scope === Scope.multiline &&\n        parent.keyword === ASTNodeKeyword.root\n      ) {\n        if (node.children) {\n          for (let child of node.children) {\n            source += visit(child, i + 1, node, trailingNewline, input);\n          }\n        }\n      } else {\n        throw \"Not implemented\";\n      }\n\n      if (\n        node.scope === Scope.inline &&\n        parent &&\n        parent.keyword === ASTNodeKeyword.run\n      ) {\n        source += `);`;\n      }\n\n      break;\n    }\n\n    case ASTNodeKeyword.export: {\n      source += `\\n;var ${node.name} = (module.exports.${\n        node.name\n      } = (function ${node.name}(${node.value.trim().split(\",\").join(\", \")})${\n        node.functionDeclarationSuffix\n      } {\n        let originalThis = _this;\n\n        if (!this || typeof this[\"${PARTIAL_SOURCE_CODE_VARIABLE}\"] === 'undefined') {\n          _this = {\n            [\"${PARTIAL_SOURCE_CODE_VARIABLE}\"]: \"\"\n          }\n        } else {\n          _this = this;\n        }\n\n        const buildEval = (function ${functionName}() {\\n`;\n      if (node.children) {\n        for (let child of node.children) {\n          source += visit(child, i + 1, node, trailingNewline, input);\n        }\n      }\n\n      // const variableMapping = (node.variableMapping || [])\n      //   .map(quotedVariableMapping)\n      //   .join(\", \");\n      source += `\\n})();\n    let output = ${SOURCE_CODE_VARIABLE};\n    _this = originalThis;\n  return typeof buildEval === 'undefined' ? output : buildEval;\n}));\\n\\n`;\n\n      break;\n    }\n\n    case ASTNodeKeyword.inline: {\n      throw \"Not implemented yet\";\n      break;\n    }\n\n    case ASTNodeKeyword.run: {\n      // if (parent.keyword !== ASTNodeKeyword.build) {\n      //   source += `(function run__${i}(${SOURCE_CODE_VARIABLE}, ${REPLACERS_VARIABLE}) {\n      //     ${node.value || \"\"}\n      //     `;\n      // }\n\n      if (node.children) {\n        for (let child of node.children) {\n          source += visit(child, i + 1, node, trailingNewline, input);\n        }\n      }\n\n      // if (parent.keyword !== ASTNodeKeyword.build) {\n      //   source += `})();\\n`;\n      // }\n\n      break;\n    }\n\n    case ASTNodeKeyword.source: {\n      let value = input.substring(node.from, Math.min(node.to, input.length));\n\n      if (\n        parent.keyword === ASTNodeKeyword.build ||\n        parent.keyword === ASTNodeKeyword.export ||\n        parent.keyword === ASTNodeKeyword.inline\n      ) {\n        return trailingNewline ? value : value.trimEnd();\n      } else if (\n        parent.keyword === ASTNodeKeyword.run ||\n        parent.keyword === ASTNodeKeyword.root\n      ) {\n        if (\n          node.children &&\n          node.children.length &&\n          parent &&\n          parent.variableMapping &&\n          parent.variableMapping.length\n        ) {\n          const slottedValue = [value];\n\n          let replacerIndex = -1;\n          let slotOffset = 0;\n          let positionOffset = node.from;\n          let position = 0;\n          for (let i = 0; i < node.children.length; i++) {\n            const replacer = node.children[i];\n            replacerIndex = parent.variableMapping.indexOf(replacer.name);\n\n            if (replacerIndex === -1) {\n              continue;\n            }\n\n            slottedValue.length += 2;\n\n            slottedValue[slotOffset++] = value.substring(\n              position - positionOffset,\n              replacer.from - positionOffset\n            );\n\n            slottedValue[\n              slotOffset++\n            ] = `\" + ${REPLACERS_VARIABLE}[${replacerIndex}] + \"`;\n\n            slottedValue[slotOffset++] = value.substring(\n              replacer.to - positionOffset + 1\n            );\n          }\n          value = slottedValue.join(\"\");\n        }\n        source += `${SOURCE_CODE_VARIABLE} += \"${value\n          .replace(/\\n/gm, \"\\\\n\")\n          .replace(/\"/gm, '\\\\\"')}\";${trailingNewline ? \"\\n\" : \"\"}`;\n      } else {\n        throw \"Unhandled keyword type\";\n      }\n\n      break;\n    }\n    default: {\n      debugger;\n      throw `Invalid ASTNodeKeyword: ${node.keyword}`;\n      break;\n    }\n  }\n\n  return source;\n}\n"],
  "mappings": "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",
  "names": []
}
