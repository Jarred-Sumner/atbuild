{
  "version": 3,
  "sources": ["../src/atbuild.ts", "../src/fullAst.ts", "../src/fullAst.ts"],
  "sourcesContent": ["import { buildAST, transformAST } from \"./fullAst\";\n\nlet fs;\n\nconst HEADER_STRING =\n  \"/* eslint-disable */\" +\n  \"\\n\" +\n  \"// @ts-nocheck\" +\n  \"\\n\" +\n  \"// @ts-ignore\\n\" +\n  \"// @noflow\\n\" +\n  '\"use strict\";\\n\\n';\n\nconst getMaxLine = function (currentLine, node) {\n  return Math.max(currentLine, node.lineNumber);\n};\n\nexport let requireFromString;\n\nlet bundle;\n\nif (process.env.WEB) {\n  requireFromString = (code) =>\n    eval(\n      `\n  () => {\n    var exports = {default: null};\n` +\n        code.replace(\"module.exports\", \"exports\") +\n        `\n  }()\n`\n    );\n} else {\n  requireFromString = require(\"./requireFromString\").requireFromString;\n  fs = require(\"fs\");\n}\n\nexport class AtBuild {\n  static buildAST(code) {\n    return buildAST(code);\n  }\n\n  static transformASTBuildTimeOnly(nodes) {\n    const maxLineNumber = nodes.reduce(getMaxLine, 0);\n    let lines = new Array(maxLineNumber + 1);\n\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = \"\";\n    }\n\n    for (let node of nodes) {\n      switch (node.type) {\n        case \"BuildtimeCode\": {\n          lines[node.lineNumber] += node.value;\n          if (!lines[node.lineNumber].endsWith(\"\\n\")) {\n            lines[node.lineNumber] += \"\\n\";\n          }\n          break;\n        }\n\n        case \"InterpolatedCode\": {\n          lines[node.lineNumber] += \"${\" + node.value + \"}\";\n          break;\n        }\n\n        case \"RuntimeCode\": {\n          lines[node.lineNumber] += node.value;\n          break;\n        }\n\n        case \"RuntimecodeLineStart\": {\n          lines[node.lineNumber] += \"`\";\n          break;\n        }\n\n        case \"RuntimecodeLineEnd\": {\n          lines[node.lineNumber] += \"`;\\n\";\n          break;\n        }\n      }\n    }\n\n    return lines.join(\"\");\n  }\n\n  static transformAST = transformAST;\n\n  static *findNodesAtLine(nodes, lineNumber) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (node.lineNumber === lineNumber) {\n        yield node;\n      }\n    }\n  }\n\n  static ASTResponseType = {\n    BuildtimeCode: 0,\n    RuntimeCode: 1,\n  };\n\n  static transformASTForLineColumn(nodes, lineNumber, column, response) {\n    // go to the line.\n    let lineNode = this.findNodesAtLine(nodes, lineNumber).next().value;\n\n    if (!lineNode) {\n      response[0] = \"\";\n      response[1] = this.ASTResponseType.RuntimeCode;\n      response[2] = lineNumber;\n      response[3] = column;\n      return;\n    }\n\n    if (\n      lineNode.type === \"BuildtimeCode\" ||\n      lineNode.type === \"InterpolatedCode\"\n    ) {\n      response[0] = this.transformASTBuildTimeOnly(nodes);\n      response[1] = this.ASTResponseType.BuildtimeCode;\n      response[2] = lineNumber;\n      response[3] = column;\n      return;\n    }\n\n    let code = \"var __CODE__ = [];\\n\\n\";\n    const maxLineNumber = nodes.reduce(getMaxLine, 0);\n    let lines = new Array(maxLineNumber + 3);\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = \"\";\n    }\n\n    let lineOffset = 0;\n    for (let node of nodes) {\n      switch (node.type) {\n        case \"BuildtimeCode\": {\n          lines[node.lineNumber] += node.value + \"\\n\";\n          lineOffset++;\n          break;\n        }\n\n        case \"InterpolatedCode\": {\n          lines[node.lineNumber] += \"${\" + node.value + \"}\";\n          break;\n        }\n        case \"RuntimeCode\": {\n          lines[node.lineNumber] +=\n            `/* ATBuildColumnMap: ${node.column} */` + node.value;\n          break;\n        }\n\n        case \"RuntimecodeLineStart\": {\n          lines[\n            node.lineNumber\n          ] += `__CODE__.push(\\`/* ATBuildLineMap: ${node.lineNumber} */`;\n          break;\n        }\n\n        case \"RuntimecodeLineEnd\": {\n          lines[node.lineNumber] += \"`);\\n\";\n          break;\n        }\n      }\n    }\n\n    lines.unshift(code);\n\n    lines[lines.length - 1] = `module.exports = __CODE__.join(\"\\\\n\");`;\n    response[0] = lines.join(\"\\n\");\n    response[1] = this.ASTResponseType.RuntimeCode;\n    response[2] = lineNumber;\n    response[3] = column;\n    return;\n  }\n\n  static extractSourceAndType(code, filepath, line, column, response) {\n    const ast = AtBuild.buildAST(code);\n    response[2] = response[3] = 0;\n    AtBuild.transformASTForLineColumn(ast, line, column, response);\n\n    if (\n      response[0] !== \"\" &&\n      response[1] === this.ASTResponseType.RuntimeCode\n    ) {\n      const source = this._eval(response[0], filepath, false);\n\n      const lines = source.split(\"\\n\");\n\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].indexOf(`/* AtBuildLineMap: ${line} */`) > -1) {\n          response[2] = i;\n          for (let offset = 0; offset < lines[i]; offset++) {\n            const line = lines[i].substring(offset);\n            let _offset = line.indexOf(`/* AtBuildColumnMap: ${column} */`);\n            let match = null;\n            if (_offset > -1) {\n              response[3] = offset + _offset;\n              break;\n            } else if (\n              (match = line.match(/\\/\\* AtBuildColumnMap: (\\d*) \\*\\//))\n            ) {\n            }\n          }\n          response[3] = lines[i].indexOf(`/* AtBuildColumnMap: ${column} */`);\n          break;\n        }\n      }\n\n      response[0] = source\n        .replace(/\\/\\* AtBuildColumnMap: \\d* \\*\\//gim, \"\")\n        .replace(/\\/\\* AtBuildLineMap: \\d* \\*\\//gim, \"\");\n    }\n  }\n\n  static evalFile(path, header) {\n    return this.eval(fs.readFileSync(path), path, header, module.parent);\n  }\n\n  static async evalFileAsync(path, header) {\n    return await this.evalAsync(\n      fs.readFileSync(path),\n      path,\n      header,\n      module.parent\n    );\n  }\n\n  static _eval(\n    code,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    let source = requireFromString(code, filepath, requireFunc);\n    if (addHeader) {\n      source = HEADER_STRING + source;\n      source += `\n        module.exports = __atBuild\n      `;\n    }\n\n    return source;\n  }\n\n  static eval(\n    code: string,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    const ast = AtBuild.buildAST(code);\n    const processed = AtBuild.transformAST(ast, false);\n    const res = this._eval(processed, filepath, addHeader, requireFunc);\n    if (res && res.default) {\n      return res.default;\n    } else {\n      return res;\n    }\n  }\n\n  static async evalAsync(\n    code: string,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    const ast = AtBuild.buildAST(code);\n    const processed = AtBuild.transformAST(ast, true);\n\n    let source = await requireFromString(processed, filepath, requireFunc);\n    if (addHeader) {\n      source = HEADER_STRING + source;\n    }\n\n    return source;\n  }\n}\n\nexport default function $(arg: any) {\n  return arg;\n}\n", "const BUILD_TIME_MATCHER = /^\\s*@(.*)/;\nconst MULTILINE_BUILD_TIME_MATCHER = /^\\s*@@(.*)/;\nconst RUNTIME_MATCHER = /\\@\\{([^@}]*)\\}/gm;\nconst EXPORT_FUNCTION_LINE_START = /^\\s*@lib function\\s*\\$*(\\w*)\\((.*)\\)\\s*\\{?$/;\nconst EXPORT_FUNCTION_LINE_END = /\\s*@lib-\\s*$/;\n\nexport enum ASTNode {\n  RuntimeCode = 0,\n  BuildtimeCode = 1,\n  MultilineBuildtimeCode = 2,\n  RuntimecodeLineStart = 3,\n  InterpolatedCode = 4,\n  RuntimecodeLineEnd = 5,\n  ExportFunctionStart = 6,\n  ExportFunctionEnd = 7,\n}\n\nexport function buildAST(code: string) {\n  const nodes = [];\n  let lineMatch = null;\n  let lines = String(code).split(\"\\n\");\n  let isMultiline = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].trim().length === 0) {\n      continue;\n    }\n\n    if ((lineMatch = lines[i].match(MULTILINE_BUILD_TIME_MATCHER))) {\n      if (isMultiline) {\n        isMultiline = false;\n      } else {\n        isMultiline = true;\n      }\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.MultilineBuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else if (isMultiline) {\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.MultilineBuildtimeCode,\n        value: lines[i],\n        // scope: scopeValue,\n      });\n    } else if ((lineMatch = lines[i].match(BUILD_TIME_MATCHER))) {\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.BuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else if ((lineMatch = lines[i].match(BUILD_TIME_MATCHER))) {\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.BuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else if ((lineMatch = lines[i].match(BUILD_TIME_MATCHER))) {\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.BuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else {\n      let line = [\n        {\n          lineNumber: i,\n          type: ASTNode.RuntimecodeLineStart,\n        },\n        {\n          lineNumber: i,\n          type: ASTNode.RuntimeCode,\n          value: lines[i],\n          column: 0,\n        },\n      ];\n\n      let result;\n      let lineToMatch = lines[i];\n      let offset = 0;\n\n      for (let result of lineToMatch.matchAll(RUNTIME_MATCHER)) {\n        const [input, match] = result;\n        const index = result.index;\n\n        const original = line[line.length - 1].value;\n        line[line.length - 1].value = original.substring(0, index - offset);\n\n        line.length += 2;\n\n        line[line.length - 2] = {\n          lineNumber: i,\n          type: ASTNode.InterpolatedCode,\n          value: match,\n          column: index - offset,\n        };\n\n        lineToMatch = result.input.substring((offset = index + input.length));\n\n        line[line.length - 1] = {\n          type: ASTNode.RuntimeCode,\n          lineNumber: i,\n          value: lineToMatch,\n          column: offset,\n        };\n      }\n\n      nodes.push(...line);\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.RuntimecodeLineEnd,\n      });\n    }\n  }\n\n  return nodes;\n}\n\nexport function transformAST(nodes, asFunction, exposeFunctions = false) {\n  let code;\n  if (asFunction) {\n    code =\n      \"module.exports.default = async function __atBuild(require) {  var __CODE__ = [];\\n\\n\";\n  } else {\n    code = \"var __CODE__ = [];\\n\\n\";\n  }\n  const maxLineNumber = nodes.reduce(getMaxLine, 0);\n  let lines = new Array(maxLineNumber + 3 + (exposeFunctions | 0));\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = \"\";\n  }\n\n  for (let node of nodes) {\n    switch (node.type) {\n      case ASTNode.MultilineBuildtimeCode:\n      case ASTNode.BuildtimeCode: {\n        lines[node.lineNumber] += node.value + \"\\n\";\n        break;\n      }\n\n      case ASTNode.InterpolatedCode: {\n        lines[node.lineNumber] += \"${\" + node.value + \"}\";\n        break;\n      }\n      case ASTNode.RuntimeCode: {\n        // prettier-ignore\n        lines[node.lineNumber] += node.value.replace(/`/igm, \"\\\\`\")\n        break;\n      }\n\n      case ASTNode.RuntimecodeLineStart: {\n        lines[node.lineNumber] += \"__CODE__.push(`\";\n        break;\n      }\n\n      case ASTNode.RuntimecodeLineEnd: {\n        lines[node.lineNumber] += \"`);\\n\";\n        break;\n      }\n    }\n  }\n  lines.unshift(code);\n\n  if (exposeFunctions) {\n    lines[\n      lines.length - 2\n    ] = `for (let key of Object.keys(module.exports)) { module.exports[\"$\" + key] = module.exports[key]; }\\n`;\n  }\n\n  if (asFunction) {\n    lines[\n      lines.length - 1\n    ] = `return __CODE__.join(\"\\\\n\");\\n}; module.exports.__specialInitFunction = true;`;\n  } else {\n    lines[lines.length - 1] = `module.exports.default =  __CODE__.join(\"\\\\n\");`;\n  }\n\n  return lines.join(\"\");\n}\n", "const BUILD_TIME_MATCHER = /^\\s*@(.*)/;\nconst MULTILINE_BUILD_TIME_MATCHER = /^\\s*@@(.*)/;\nconst RUNTIME_MATCHER = /\\@\\{([^@}]*)\\}/gm;\nconst EXPORT_FUNCTION_LINE_START = /^\\s*@lib function\\s*\\$*(\\w*)\\((.*)\\)\\s*\\{?$/;\nconst EXPORT_FUNCTION_LINE_END = /\\s*@lib-\\s*$/;\n\nexport enum ASTNode {\n  RuntimeCode = 0,\n  BuildtimeCode = 1,\n  MultilineBuildtimeCode = 2,\n  RuntimecodeLineStart = 3,\n  InterpolatedCode = 4,\n  RuntimecodeLineEnd = 5,\n  ExportFunctionStart = 6,\n  ExportFunctionEnd = 7,\n}\n\nexport function buildAST(code: string) {\n  const nodes = [];\n  let lineMatch = null;\n  let lines = String(code).split(\"\\n\");\n  let isMultiline = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].trim().length === 0) {\n      continue;\n    }\n\n    if ((lineMatch = lines[i].match(MULTILINE_BUILD_TIME_MATCHER))) {\n      if (isMultiline) {\n        isMultiline = false;\n      } else {\n        isMultiline = true;\n      }\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.MultilineBuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else if (isMultiline) {\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.MultilineBuildtimeCode,\n        value: lines[i],\n        // scope: scopeValue,\n      });\n    } else if ((lineMatch = lines[i].match(BUILD_TIME_MATCHER))) {\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.BuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else if ((lineMatch = lines[i].match(BUILD_TIME_MATCHER))) {\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.BuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else if ((lineMatch = lines[i].match(BUILD_TIME_MATCHER))) {\n      let scopeValue = 0;\n\n      if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue++;\n      } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n        scopeValue--;\n      }\n      let string = lineMatch[1];\n      for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n        string = \" \" + string;\n      }\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.BuildtimeCode,\n        value: string,\n        scope: scopeValue,\n      });\n    } else {\n      let line = [\n        {\n          lineNumber: i,\n          type: ASTNode.RuntimecodeLineStart,\n        },\n        {\n          lineNumber: i,\n          type: ASTNode.RuntimeCode,\n          value: lines[i],\n          column: 0,\n        },\n      ];\n\n      let result;\n      let lineToMatch = lines[i];\n      let offset = 0;\n\n      for (let result of lineToMatch.matchAll(RUNTIME_MATCHER)) {\n        const [input, match] = result;\n        const index = result.index;\n\n        const original = line[line.length - 1].value;\n        line[line.length - 1].value = original.substring(0, index - offset);\n\n        line.length += 2;\n\n        line[line.length - 2] = {\n          lineNumber: i,\n          type: ASTNode.InterpolatedCode,\n          value: match,\n          column: index - offset,\n        };\n\n        lineToMatch = result.input.substring((offset = index + input.length));\n\n        line[line.length - 1] = {\n          type: ASTNode.RuntimeCode,\n          lineNumber: i,\n          value: lineToMatch,\n          column: offset,\n        };\n      }\n\n      nodes.push(...line);\n\n      nodes.push({\n        lineNumber: i,\n        type: ASTNode.RuntimecodeLineEnd,\n      });\n    }\n  }\n\n  return nodes;\n}\n\nexport function transformAST(nodes, asFunction, exposeFunctions = false) {\n  let code;\n  if (asFunction) {\n    code =\n      \"module.exports.default = async function __atBuild(require) {  var __CODE__ = [];\\n\\n\";\n  } else {\n    code = \"var __CODE__ = [];\\n\\n\";\n  }\n  const maxLineNumber = nodes.reduce(getMaxLine, 0);\n  let lines = new Array(maxLineNumber + 3 + (exposeFunctions | 0));\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = \"\";\n  }\n\n  for (let node of nodes) {\n    switch (node.type) {\n      case ASTNode.MultilineBuildtimeCode:\n      case ASTNode.BuildtimeCode: {\n        lines[node.lineNumber] += node.value + \"\\n\";\n        break;\n      }\n\n      case ASTNode.InterpolatedCode: {\n        lines[node.lineNumber] += \"${\" + node.value + \"}\";\n        break;\n      }\n      case ASTNode.RuntimeCode: {\n        // prettier-ignore\n        lines[node.lineNumber] += node.value.replace(/`/igm, \"\\\\`\")\n        break;\n      }\n\n      case ASTNode.RuntimecodeLineStart: {\n        lines[node.lineNumber] += \"__CODE__.push(`\";\n        break;\n      }\n\n      case ASTNode.RuntimecodeLineEnd: {\n        lines[node.lineNumber] += \"`);\\n\";\n        break;\n      }\n    }\n  }\n  lines.unshift(code);\n\n  if (exposeFunctions) {\n    lines[\n      lines.length - 2\n    ] = `for (let key of Object.keys(module.exports)) { module.exports[\"$\" + key] = module.exports[key]; }\\n`;\n  }\n\n  if (asFunction) {\n    lines[\n      lines.length - 1\n    ] = `return __CODE__.join(\"\\\\n\");\\n}; module.exports.__specialInitFunction = true;`;\n  } else {\n    lines[lines.length - 1] = `module.exports.default =  __CODE__.join(\"\\\\n\");`;\n  }\n\n  return lines.join(\"\");\n}\n"],
  "mappings": "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",
  "names": []
}
