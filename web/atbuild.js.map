{
  "version": 3,
  "sources": ["../src/atbuild.ts"],
  "sourcesContent": ["let fs;\nconst BUILD_TIME_MATCHER = /^\\s*@(.*)/;\nconst MULTILINE_BUILD_TIME_MATCHER = /^\\s*@@(.*)/;\nconst RUNTIME_MATCHER = /\\@\\{([^@}]*)\\}/gm;\n\nconst HEADER_STRING =\n  \"/* eslint-disable */\" +\n  \"\\n\" +\n  \"// @ts-nocheck\" +\n  \"\\n\" +\n  \"// @ts-ignore\\n\" +\n  \"// @noflow\\n\" +\n  '\"use strict\";\\n\\n';\n\nconst getMaxLine = function (currentLine, node) {\n  return Math.max(currentLine, node.lineNumber);\n};\n\nexport let requireFromString;\n\nlet bundle;\n\nif (process.env.WEB) {\n  requireFromString = (code) =>\n    eval(\n      `\n  () => {\n    var exports = {default: null};\n` +\n        code.replace(\"module.exports\", \"exports\") +\n        `\n  }()\n`\n    );\n} else {\n  requireFromString = require(\"./requireFromString\").requireFromString;\n  fs = require(\"fs\");\n}\n\nexport class AtBuild {\n  static buildAST(code) {\n    const nodes = [];\n    let lineMatch = null;\n    let lines = String(code).split(\"\\n\");\n    let isMultiline = false;\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].trim().length === 0) {\n        continue;\n      }\n\n      if ((lineMatch = lines[i].match(MULTILINE_BUILD_TIME_MATCHER))) {\n        if (isMultiline) {\n          isMultiline = false;\n        } else {\n          isMultiline = true;\n        }\n        let scopeValue = 0;\n\n        if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n          scopeValue++;\n        } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n          scopeValue--;\n        }\n        let string = lineMatch[1];\n        for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n          string = \" \" + string;\n        }\n\n        nodes.push({\n          lineNumber: i,\n          type: \"MultilineBuildtimeCode\",\n          value: string,\n          scope: scopeValue,\n        });\n      } else if (isMultiline) {\n        nodes.push({\n          lineNumber: i,\n          type: \"MultilineBuildtimeCode\",\n          value: lines[i],\n          // scope: scopeValue,\n        });\n      } else if ((lineMatch = lines[i].match(BUILD_TIME_MATCHER))) {\n        let scopeValue = 0;\n\n        if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n          scopeValue++;\n        } else if (lineMatch[1].trimEnd().endsWith(\"{\")) {\n          scopeValue--;\n        }\n        let string = lineMatch[1];\n        for (let i = 0; i < lineMatch[0].indexOf(lineMatch[1]) + 1; i++) {\n          string = \" \" + string;\n        }\n\n        nodes.push({\n          lineNumber: i,\n          type: \"BuildtimeCode\",\n          value: string,\n          scope: scopeValue,\n        });\n      } else {\n        let line = [\n          {\n            lineNumber: i,\n            type: \"RuntimecodeLineStart\",\n          },\n          {\n            lineNumber: i,\n            type: \"RuntimeCode\",\n            value: lines[i],\n            column: 0,\n          },\n        ];\n\n        let result;\n        let lineToMatch = lines[i];\n        let offset = 0;\n\n        for (let result of lineToMatch.matchAll(RUNTIME_MATCHER)) {\n          const [input, match] = result;\n          const index = result.index;\n\n          const original = line[line.length - 1].value;\n          line[line.length - 1].value = original.substring(0, index - offset);\n\n          line.length += 2;\n\n          line[line.length - 2] = {\n            lineNumber: i,\n            type: \"InterpolatedCode\",\n            value: match,\n            column: index - offset,\n          };\n\n          lineToMatch = result.input.substring((offset = index + input.length));\n\n          line[line.length - 1] = {\n            type: \"RuntimeCode\",\n            lineNumber: i,\n            value: lineToMatch,\n            column: offset,\n          };\n        }\n\n        nodes.push(...line);\n\n        nodes.push({\n          lineNumber: i,\n          type: \"RuntimecodeLineEnd\",\n        });\n      }\n    }\n\n    return nodes;\n  }\n\n  static transformASTBuildTimeOnly(nodes) {\n    const maxLineNumber = nodes.reduce(getMaxLine, 0);\n    let lines = new Array(maxLineNumber + 1);\n\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = \"\";\n    }\n\n    for (let node of nodes) {\n      switch (node.type) {\n        case \"BuildtimeCode\": {\n          lines[node.lineNumber] += node.value;\n          if (!lines[node.lineNumber].endsWith(\"\\n\")) {\n            lines[node.lineNumber] += \"\\n\";\n          }\n          break;\n        }\n\n        case \"InterpolatedCode\": {\n          lines[node.lineNumber] += \"${\" + node.value + \"}\";\n          break;\n        }\n\n        case \"RuntimeCode\": {\n          lines[node.lineNumber] += node.value;\n          break;\n        }\n\n        case \"RuntimecodeLineStart\": {\n          lines[node.lineNumber] += \"`\";\n          break;\n        }\n\n        case \"RuntimecodeLineEnd\": {\n          lines[node.lineNumber] += \"`;\\n\";\n          break;\n        }\n      }\n    }\n\n    return lines.join(\"\");\n  }\n\n  static transformAST(nodes, asFunction, exposeFunctions = false) {\n    let code;\n    if (asFunction) {\n      code =\n        \"module.exports.default = async function __atBuild(require) {  var __CODE__ = [];\\n\\n\";\n    } else {\n      code = \"var __CODE__ = [];\\n\\n\";\n    }\n    const maxLineNumber = nodes.reduce(getMaxLine, 0);\n    let lines = new Array(maxLineNumber + 3 + (exposeFunctions | 0));\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = \"\";\n    }\n\n    for (let node of nodes) {\n      switch (node.type) {\n        case \"MultilineBuildtimeCode\":\n        case \"BuildtimeCode\": {\n          lines[node.lineNumber] += node.value + \"\\n\";\n          break;\n        }\n\n        case \"InterpolatedCode\": {\n          lines[node.lineNumber] += \"${\" + node.value + \"}\";\n          break;\n        }\n        case \"RuntimeCode\": {\n          // prettier-ignore\n          lines[node.lineNumber] += node.value.replace(/`/igm, \"\\\\`\")\n          break;\n        }\n\n        case \"RuntimecodeLineStart\": {\n          lines[node.lineNumber] += \"__CODE__.push(`\";\n          break;\n        }\n\n        case \"RuntimecodeLineEnd\": {\n          lines[node.lineNumber] += \"`);\\n\";\n          break;\n        }\n      }\n    }\n    lines.unshift(code);\n\n    if (exposeFunctions) {\n      lines[\n        lines.length - 2\n      ] = `for (let key of Object.keys(module.exports)) { module.exports[\"$\" + key] = module.exports[key]; }\\n`;\n    }\n\n    if (asFunction) {\n      lines[\n        lines.length - 1\n      ] = `return __CODE__.join(\"\\\\n\");\\n}; module.exports.__specialInitFunction = true;`;\n    } else {\n      lines[\n        lines.length - 1\n      ] = `module.exports.default =  __CODE__.join(\"\\\\n\");`;\n    }\n\n    return lines.join(\"\");\n  }\n\n  static *findNodesAtLine(nodes, lineNumber) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (node.lineNumber === lineNumber) {\n        yield node;\n      }\n    }\n  }\n\n  static ASTResponseType = {\n    BuildtimeCode: 0,\n    RuntimeCode: 1,\n  };\n\n  static transformASTForLineColumn(nodes, lineNumber, column, response) {\n    // go to the line.\n    let lineNode = this.findNodesAtLine(nodes, lineNumber).next().value;\n\n    if (!lineNode) {\n      response[0] = \"\";\n      response[1] = this.ASTResponseType.RuntimeCode;\n      response[2] = lineNumber;\n      response[3] = column;\n      return;\n    }\n\n    if (\n      lineNode.type === \"BuildtimeCode\" ||\n      lineNode.type === \"InterpolatedCode\"\n    ) {\n      response[0] = this.transformASTBuildTimeOnly(nodes);\n      response[1] = this.ASTResponseType.BuildtimeCode;\n      response[2] = lineNumber;\n      response[3] = column;\n      return;\n    }\n\n    let code = \"var __CODE__ = [];\\n\\n\";\n    const maxLineNumber = nodes.reduce(getMaxLine, 0);\n    let lines = new Array(maxLineNumber + 3);\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = \"\";\n    }\n\n    let lineOffset = 0;\n    for (let node of nodes) {\n      switch (node.type) {\n        case \"BuildtimeCode\": {\n          lines[node.lineNumber] += node.value + \"\\n\";\n          lineOffset++;\n          break;\n        }\n\n        case \"InterpolatedCode\": {\n          lines[node.lineNumber] += \"${\" + node.value + \"}\";\n          break;\n        }\n        case \"RuntimeCode\": {\n          lines[node.lineNumber] +=\n            `/* ATBuildColumnMap: ${node.column} */` + node.value;\n          break;\n        }\n\n        case \"RuntimecodeLineStart\": {\n          lines[\n            node.lineNumber\n          ] += `__CODE__.push(\\`/* ATBuildLineMap: ${node.lineNumber} */`;\n          break;\n        }\n\n        case \"RuntimecodeLineEnd\": {\n          lines[node.lineNumber] += \"`);\\n\";\n          break;\n        }\n      }\n    }\n\n    lines.unshift(code);\n\n    lines[lines.length - 1] = `module.exports = __CODE__.join(\"\\\\n\");`;\n    response[0] = lines.join(\"\\n\");\n    response[1] = this.ASTResponseType.RuntimeCode;\n    response[2] = lineNumber;\n    response[3] = column;\n    return;\n  }\n\n  static extractSourceAndType(code, filepath, line, column, response) {\n    const ast = AtBuild.buildAST(code);\n    response[2] = response[3] = 0;\n    AtBuild.transformASTForLineColumn(ast, line, column, response);\n\n    if (\n      response[0] !== \"\" &&\n      response[1] === this.ASTResponseType.RuntimeCode\n    ) {\n      const source = this._eval(response[0], filepath, false);\n\n      const lines = source.split(\"\\n\");\n\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].indexOf(`/* AtBuildLineMap: ${line} */`) > -1) {\n          response[2] = i;\n          for (let offset = 0; offset < lines[i]; offset++) {\n            const line = lines[i].substring(offset);\n            let _offset = line.indexOf(`/* AtBuildColumnMap: ${column} */`);\n            let match = null;\n            if (_offset > -1) {\n              response[3] = offset + _offset;\n              break;\n            } else if (\n              (match = line.match(/\\/\\* AtBuildColumnMap: (\\d*) \\*\\//))\n            ) {\n            }\n          }\n          response[3] = lines[i].indexOf(`/* AtBuildColumnMap: ${column} */`);\n          break;\n        }\n      }\n\n      response[0] = source\n        .replace(/\\/\\* AtBuildColumnMap: \\d* \\*\\//gim, \"\")\n        .replace(/\\/\\* AtBuildLineMap: \\d* \\*\\//gim, \"\");\n    }\n  }\n\n  static evalFile(path, header) {\n    return this.eval(fs.readFileSync(path), path, header, module.parent);\n  }\n\n  static async evalFileAsync(path, header) {\n    return await this.evalAsync(\n      fs.readFileSync(path),\n      path,\n      header,\n      module.parent\n    );\n  }\n\n  static _eval(\n    code,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    let source = requireFromString(code, filepath, requireFunc);\n    if (addHeader) {\n      source = HEADER_STRING + source;\n      source += `\n        module.exports = __atBuild\n      `;\n    }\n\n    return source;\n  }\n\n  static eval(\n    code: string,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    const ast = AtBuild.buildAST(code);\n    const processed = AtBuild.transformAST(ast, false);\n    const res = this._eval(processed, filepath, addHeader, requireFunc);\n    if (res && res.default) {\n      return res.default;\n    } else {\n      return res;\n    }\n  }\n\n  static async evalAsync(\n    code: string,\n    filepath: string = null,\n    addHeader = false,\n    requireFunc = module.require\n  ) {\n    const ast = AtBuild.buildAST(code);\n    const processed = AtBuild.transformAST(ast, true);\n\n    let source = await requireFromString(processed, filepath, requireFunc);\n    if (addHeader) {\n      source = HEADER_STRING + source;\n    }\n\n    return source;\n  }\n}\n\nconst _AtBuild: typeof AtBuild = function $(args) {\n  return args;\n};\nfor (let key in AtBuild) {\n  _AtBuild[key] = AtBuild[key].bind(_AtBuild);\n}\nexport { $ };\nexport default _AtBuild;\n"],
  "mappings": "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",
  "names": []
}
